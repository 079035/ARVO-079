From 8ee2c721d91522db582301c2f0ce2d8a403f910c Mon Sep 17 00:00:00 2001
From: xiaohunqupo <xiaohunqupo@users.noreply.github.com>
Date: Wed, 28 Jul 2021 16:32:27 +0800
Subject: [PATCH 1/7] StepExporter support polygon mesh

StepExporter support polygon mesh
---
 code/AssetLib/Step/StepExporter.cpp | 126 +++++++++++++++++-----------
 1 file changed, 79 insertions(+), 47 deletions(-)

diff --git a/code/AssetLib/Step/StepExporter.cpp b/code/AssetLib/Step/StepExporter.cpp
index dfe5bab67c..1228c72eaa 100644
--- a/code/AssetLib/Step/StepExporter.cpp
+++ b/code/AssetLib/Step/StepExporter.cpp
@@ -175,12 +175,11 @@ void StepExporter::WriteFile()
     fColor.b = 0.8f;
 
     int ind = 100; // the start index to be used
-    int faceEntryLen = 30; // number of entries for a triangle/face
+    std::vector<int> faceEntryLen; // numbers of entries for a triangle/face
     // prepare unique (count triangles and vertices)
 
     VectorIndexUMap uniqueVerts; // use a map to reduce find complexity to log(n)
     VectorIndexUMap::iterator it;
-    int countFace = 0;
 
     for (unsigned int i=0; i<mScene->mNumMeshes; ++i)
     {
@@ -189,7 +188,7 @@ void StepExporter::WriteFile()
         {
             aiFace* face = &(mesh->mFaces[j]);
 
-            if (face->mNumIndices == 3) countFace++;
+            if (face->mNumIndices >= 3) faceEntryLen.push_back(15 + 5 * face->mNumIndices);
         }
         for (unsigned int j=0; j<mesh->mNumVertices; ++j)
         {
@@ -218,10 +217,13 @@ void StepExporter::WriteFile()
     // write the top of data
     mOutput << "DATA" << endstr;
     mOutput << "#1=MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION(' ',(";
-    for (int i=0; i<countFace; ++i)
+    size_t countFace = faceEntryLen.size();
+    size_t faceLenIndex = ind + 2 * uniqueVerts.size();
+    for (size_t i=0; i<countFace; ++i)
     {
-        mOutput << "#" << i*faceEntryLen + ind + 2*uniqueVerts.size();
+        mOutput << "#" << faceLenIndex;
         if (i!=countFace-1) mOutput << ",";
+        faceLenIndex += faceEntryLen[i];
     }
     mOutput << "),#6)" << endstr;
 
@@ -253,10 +255,12 @@ void StepExporter::WriteFile()
     mOutput << "#27=DIRECTION('',(1.0,0.0,0.0))" << endstr;
     mOutput << "#28= (NAMED_UNIT(#21)LENGTH_UNIT()SI_UNIT(.MILLI.,.METRE.))" << endstr;
     mOutput << "#29=CLOSED_SHELL('',(";
-    for (int i=0; i<countFace; ++i)
+    faceLenIndex = ind + 2 * uniqueVerts.size() + 8;
+    for (size_t i=0; i<countFace; ++i)
     {
-        mOutput << "#" << i*faceEntryLen + ind + 2*uniqueVerts.size() + 8;
+        mOutput << "#" << faceLenIndex;
         if (i!=countFace-1) mOutput << ",";
+        faceLenIndex += faceEntryLen[i];
     }
     mOutput << "))" << endstr;
 
@@ -289,27 +293,28 @@ void StepExporter::WriteFile()
         {
             aiFace* face = &(mesh->mFaces[j]);
 
-            if (face->mNumIndices != 3) continue;
-
-            aiVector3D* v1 = &(mesh->mVertices[face->mIndices[0]]);
-            aiVector3D* v2 = &(mesh->mVertices[face->mIndices[1]]);
-            aiVector3D* v3 = &(mesh->mVertices[face->mIndices[2]]);
-            aiVector3D dv12 = *v2 - *v1;
-            aiVector3D dv23 = *v3 - *v2;
-            aiVector3D dv31 = *v1 - *v3;
-            aiVector3D dv13 = *v3 - *v1;
-            dv12.Normalize();
-            dv23.Normalize();
-            dv31.Normalize();
-            dv13.Normalize();
-
-            aiVector3D dvY = dv12;
-            aiVector3D dvX = dvY ^ dv13;
-            dvX.Normalize();
+            const int numIndices = face->mNumIndices;
+            if (numIndices < 3) continue;
 
-            int pid1 = uniqueVerts.find(v1)->second;
-            int pid2 = uniqueVerts.find(v2)->second;
-            int pid3 = uniqueVerts.find(v3)->second;
+            std::vector<int> pidArray(numIndices, -1); // vertex id
+            std::vector<aiVector3D> dvArray(numIndices); // edge dir
+            for (int k = 0; k < numIndices; ++k)
+            {
+                aiVector3D *v1 = &(mesh->mVertices[face->mIndices[k]]);
+                pidArray[k] = uniqueVerts.find(v1)->second;
+
+                aiVector3D *v2 = nullptr;
+                if (k + 1 == numIndices)
+                    v2 = &(mesh->mVertices[face->mIndices[0]]);
+                else
+                    v2 = &(mesh->mVertices[face->mIndices[k + 1]]);
+                dvArray[k] = *v2 - *v1;
+                dvArray[k].Normalize();
+            }
+
+            aiVector3D dvY = dvArray[1];
+            aiVector3D dvX = dvY ^ dvArray[0];
+            dvX.Normalize();
 
             // mean vertex color for the face if available
             if (mesh->HasVertexColors(0))
@@ -339,35 +344,62 @@ void StepExporter::WriteFile()
 
             /* 2 directions of the plane */
             mOutput << "#" << sid+9 << "=PLANE('',#" << sid+10 << ")" << endstr;
-            mOutput << "#" << sid+10 << "=AXIS2_PLACEMENT_3D('',#" << pid1 << ", #" << sid+11 << ",#" << sid+12 << ")" << endstr;
+            mOutput << "#" << sid+10 << "=AXIS2_PLACEMENT_3D('',#" << pidArray[0] << ",#" << sid+11 << ",#" << sid+12 << ")" << endstr;
 
             mOutput << "#" << sid + 11 << "=DIRECTION('',(" << dvX.x << "," << dvX.y << "," << dvX.z << "))" << endstr;
             mOutput << "#" << sid + 12 << "=DIRECTION('',(" << dvY.x << "," << dvY.y << "," << dvY.z << "))" << endstr;
 
             mOutput << "#" << sid+13 << "=FACE_BOUND('',#" << sid+14 << ",.T.)" << endstr;
-            mOutput << "#" << sid+14 << "=EDGE_LOOP('',(#" << sid+15 << ",#" << sid+16 << ",#" << sid+17 << "))" << endstr;
+            mOutput << "#" << sid+14 << "=EDGE_LOOP('',(";
+            int edgeLoopStart = sid + 15;
+            for (int k = 0; k < numIndices; ++k)
+            {
+                if (k == 0)
+                    mOutput << "#";
+                else
+                    mOutput << ",#";
+                mOutput << edgeLoopStart + k;
+            }
+            mOutput << "))" << endstr;
 
             /* edge loop  */
-            mOutput << "#" << sid+15 << "=ORIENTED_EDGE('',*,*,#" << sid+18 << ",.T.)" << endstr;
-            mOutput << "#" << sid+16 << "=ORIENTED_EDGE('',*,*,#" << sid+19 << ",.T.)" << endstr;
-            mOutput << "#" << sid+17 << "=ORIENTED_EDGE('',*,*,#" << sid+20 << ",.T.)" << endstr;
+            int orientedEdgesStart = edgeLoopStart + numIndices;
+            for (int k=0; k < numIndices; k++)
+            {
+                mOutput << "#" << edgeLoopStart+k << "=ORIENTED_EDGE('',*,*,#" << orientedEdgesStart + k << ",.T.)" << endstr;
+            }
 
             /* oriented edges */
-            mOutput << "#" << sid+18 << "=EDGE_CURVE('',#" << pid1+1 << ",#" << pid2+1 << ",#" << sid+21 << ",.F.)" << endstr;
-            mOutput << "#" << sid+19 << "=EDGE_CURVE('',#" << pid2+1 << ",#" << pid3+1 << ",#" << sid+22 << ",.T.)" << endstr;
-            mOutput << "#" << sid+20 << "=EDGE_CURVE('',#" << pid3+1 << ",#" << pid1+1 << ",#" << sid+23 << ",.T.)" << endstr;
-
-            /* 3 lines and 3 vectors for the lines for the 3 edge curves */
-            mOutput << "#" << sid+21 << "=LINE('',#" << pid1 << ",#" << sid+24 << ")" << endstr;
-            mOutput << "#" << sid+22 << "=LINE('',#" << pid2 << ",#" << sid+25 << ")" << endstr;
-            mOutput << "#" << sid+23 << "=LINE('',#" << pid3 << ",#" << sid+26 << ")" << endstr;
-            mOutput << "#" << sid+24 << "=VECTOR('',#" << sid+27 << ",1.0)" << endstr;
-            mOutput << "#" << sid+25 << "=VECTOR('',#" << sid+28 << ",1.0)" << endstr;
-            mOutput << "#" << sid+26 << "=VECTOR('',#" << sid+29 << ",1.0)" << endstr;
-            mOutput << "#" << sid+27 << "=DIRECTION('',(" << dv12.x << "," << dv12.y << "," << dv12.z << "))" << endstr;
-            mOutput << "#" << sid+28 << "=DIRECTION('',(" << dv23.x << "," << dv23.y << "," << dv23.z << "))" << endstr;
-            mOutput << "#" << sid+29 << "=DIRECTION('',(" << dv31.x << "," << dv31.y << "," << dv31.z << "))" << endstr;
-            ind += faceEntryLen; // increase counter
+            int lineStart = orientedEdgesStart + numIndices;
+            for (int k=0; k < numIndices; ++k)
+            {
+                if (k == 0)
+                    mOutput << "#" << orientedEdgesStart+k << "=EDGE_CURVE('',#" << pidArray[k]+1 << ",#" << pidArray[k+1]+1 << ",#" << lineStart+k << ",.F.)" << endstr;
+                else if (k+1 == numIndices)
+                    mOutput << "#" << orientedEdgesStart+k << "=EDGE_CURVE('',#" << pidArray[k]+1 << ",#" << pidArray[0]+1 << ",#" << lineStart+k << ",.T.)" << endstr;
+                else
+                    mOutput << "#" << orientedEdgesStart+k << "=EDGE_CURVE('',#" << pidArray[k]+1 << ",#" << pidArray[k+1]+1 << ",#" << lineStart+k << ",.T.)" << endstr;
+            }
+
+            /* n lines and n vectors for the lines for the n edge curves */
+            int vectorStart = lineStart + numIndices;
+            for (int k=0; k < numIndices; ++k)
+            {
+                mOutput << "#" << lineStart+k << "=LINE('',#" << pidArray[k] << ",#" << vectorStart+k << ")" << endstr;
+            }
+
+            int directionStart = vectorStart + numIndices;
+            for (int k=0; k < numIndices; ++k)
+            {
+                mOutput << "#" << vectorStart+k << "=VECTOR('',#" << directionStart+k << ",1.0)" << endstr;
+            }
+
+            for (int k=0; k < numIndices; ++k)
+            {
+                const aiVector3D &dv = dvArray[k];
+                mOutput << "#" << directionStart + k << "=DIRECTION('',(" << dv.x << "," << dv.y << "," << dv.z << "))" << endstr;
+            }
+            ind += 15 + 5*numIndices; // increase counter
         }
     }
 

From 738c31c3eabb2b35af5d6eeb69b368f1128971e2 Mon Sep 17 00:00:00 2001
From: Krishty <krishty@krishty.com>
Date: Wed, 28 Jul 2021 16:44:46 +0200
Subject: [PATCH 2/7] removed useless code

Found while reviewing #3880
---
 code/AssetLib/Collada/ColladaParser.cpp | 4 ----
 code/AssetLib/X/XFileImporter.cpp       | 4 +---
 2 files changed, 1 insertion(+), 7 deletions(-)

diff --git a/code/AssetLib/Collada/ColladaParser.cpp b/code/AssetLib/Collada/ColladaParser.cpp
index 37c7274f44..7aa37a1121 100644
--- a/code/AssetLib/Collada/ColladaParser.cpp
+++ b/code/AssetLib/Collada/ColladaParser.cpp
@@ -231,11 +231,7 @@ void ColladaParser::UriDecodePath(aiString &ss) {
 
     // Maxon Cinema Collada Export writes "file:///C:\andsoon" with three slashes...
     // I need to filter it without destroying linux paths starting with "/somewhere"
-#if defined(_MSC_VER)
     if (ss.data[0] == '/' && isalpha((unsigned char)ss.data[1]) && ss.data[2] == ':') {
-#else
-    if (ss.data[0] == '/' && isalpha((unsigned char)ss.data[1]) && ss.data[2] == ':') {
-#endif
         --ss.length;
         ::memmove(ss.data, ss.data + 1, ss.length);
         ss.data[ss.length] = 0;
diff --git a/code/AssetLib/X/XFileImporter.cpp b/code/AssetLib/X/XFileImporter.cpp
index df1aba3316..4c8c54551c 100644
--- a/code/AssetLib/X/XFileImporter.cpp
+++ b/code/AssetLib/X/XFileImporter.cpp
@@ -667,9 +667,7 @@ void XFileImporter::ConvertMaterials( aiScene* pScene, std::vector<XFile::Materi
 
                 // convert to lower case for easier comparison
                 for ( unsigned int c = 0; c < sz.length(); ++c ) {
-                    if ( isalpha( (unsigned char) sz[ c ] ) ) {
-                        sz[ c ] = (char) tolower( (unsigned char) sz[ c ] );
-                    }
+                    sz[ c ] = (char) tolower( (unsigned char) sz[ c ] );
                 }
 
                 // Place texture filename property under the corresponding name

From 758116b083b803d413549e7ebac3d8657b738e55 Mon Sep 17 00:00:00 2001
From: Krishty <krishty@krishty.com>
Date: Thu, 29 Jul 2021 13:28:51 +0200
Subject: [PATCH 3/7] removed trailing spaces and tabs from source and text
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This commit ignores the “contrib” folder in order to prevent merge conflicts in dependencies, should these be updated via git.
---
 code/AssetLib/3DS/3DSExporter.cpp             |   2 +-
 code/AssetLib/3MF/D3MFImporter.cpp            |   2 +-
 code/AssetLib/AMF/AMFImporter.cpp             |   2 +-
 code/AssetLib/AMF/AMFImporter_Geometry.cpp    |   6 +-
 code/AssetLib/AMF/AMFImporter_Postprocess.cpp |   6 +-
 code/AssetLib/Assjson/mesh_splitter.cpp       |   8 +-
 code/AssetLib/Assjson/mesh_splitter.h         |   6 +-
 code/AssetLib/Assxml/AssxmlExporter.cpp       |   2 +-
 code/AssetLib/Blender/BlenderModifier.h       |  18 +-
 code/AssetLib/C4D/C4DImporter.cpp             |   6 +-
 code/AssetLib/COB/COBLoader.cpp               |   2 +-
 code/AssetLib/COB/COBLoader.h                 |   2 +-
 code/AssetLib/Collada/ColladaLoader.cpp       |   2 +-
 code/AssetLib/DXF/DXFLoader.cpp               |   2 +-
 code/AssetLib/DXF/DXFLoader.h                 |   2 +-
 code/AssetLib/FBX/FBXConverter.cpp            |   4 +-
 code/AssetLib/FBX/FBXConverter.h              |   4 +-
 code/AssetLib/FBX/FBXDocument.cpp             |   2 +-
 code/AssetLib/FBX/FBXExportNode.h             |   2 +-
 code/AssetLib/FBX/FBXExporter.cpp             |  12 +-
 code/AssetLib/FBX/FBXMaterial.cpp             |   8 +-
 code/AssetLib/FBX/FBXMeshGeometry.cpp         |   2 +-
 code/AssetLib/FBX/FBXMeshGeometry.h           |   8 +-
 code/AssetLib/FBX/FBXProperties.h             |   6 +-
 code/AssetLib/FBX/FBXUtil.cpp                 |   2 +-
 code/AssetLib/HMP/HMPLoader.cpp               |   4 +-
 code/AssetLib/IFC/IFCCurve.cpp                |   2 +-
 code/AssetLib/IFC/IFCOpenings.cpp             |   8 +-
 code/AssetLib/IFC/IFCReaderGen1_2x3.cpp       | 232 +++++------
 code/AssetLib/IFC/IFCReaderGen2_2x3.cpp       | 162 ++++----
 code/AssetLib/IFC/IFCReaderGen_4.cpp          | 392 +++++++++---------
 code/AssetLib/IFC/IFCReaderGen_4.h            |  26 +-
 code/AssetLib/Irr/IRRLoader.h                 |   2 +-
 code/AssetLib/LWO/LWOAnimation.h              |   2 +-
 code/AssetLib/LWS/LWSLoader.cpp               |   4 +-
 code/AssetLib/M3D/M3DWrapper.h                |  12 +-
 code/AssetLib/M3D/m3d.h                       |   6 +-
 code/AssetLib/MD5/MD5Loader.cpp               |   2 +-
 code/AssetLib/MDC/MDCFileData.h               |   4 +-
 code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp   |   4 +-
 code/AssetLib/MMD/MMDPmxParser.cpp            |   2 +-
 code/AssetLib/OFF/OFFLoader.cpp               |  10 +-
 code/AssetLib/Obj/ObjExporter.h               |  18 +-
 code/AssetLib/Obj/ObjFileMtlImporter.cpp      |   2 +-
 code/AssetLib/SMD/SMDLoader.cpp               |   2 +-
 code/AssetLib/STL/STLExporter.cpp             |   8 +-
 code/AssetLib/STL/STLLoader.cpp               |   4 +-
 code/AssetLib/X/XFileExporter.cpp             |   2 +-
 code/AssetLib/X/XFileExporter.h               |   6 +-
 code/AssetLib/X3D/X3DImporter.cpp             |   2 +-
 code/AssetLib/XGL/XGLLoader.cpp               |   2 +-
 code/AssetLib/glTF2/glTF2Asset.h              |   4 +-
 code/AssetLib/glTF2/glTF2Asset.inl            |  32 +-
 code/AssetLib/glTF2/glTF2AssetWriter.inl      |  16 +-
 code/Common/DefaultIOStream.cpp               |   6 +-
 code/Common/DefaultIOSystem.cpp               |   6 +-
 code/Common/Exporter.cpp                      |   4 +-
 code/Common/FileSystemFilter.h                |   4 +-
 code/Common/Importer.cpp                      |  80 ++--
 code/Common/Importer.h                        |   6 +-
 code/Common/ImporterRegistry.cpp              |   4 +-
 code/Common/Win32DebugLogStream.h             |   8 +-
 code/PostProcessing/ArmaturePopulate.h        |   2 +-
 .../PostProcessing/DropFaceNormalsProcess.cpp |   2 +-
 code/PostProcessing/EmbedTexturesProcess.cpp  |   2 +-
 code/PostProcessing/FindDegenerates.cpp       |   2 +-
 code/PostProcessing/FindInstancesProcess.cpp  |   2 +-
 code/PostProcessing/MakeVerboseFormat.h       |   2 +-
 .../RemoveRedundantMaterials.cpp              |   2 +-
 code/PostProcessing/ScaleProcess.cpp          |  38 +-
 code/PostProcessing/ScaleProcess.h            |   4 +-
 .../SplitByBoneCountProcess.cpp               |  12 +-
 code/PostProcessing/SplitLargeMeshes.cpp      |   4 +-
 code/PostProcessing/TextureTransform.cpp      |   2 +-
 code/PostProcessing/TriangulateProcess.cpp    |  12 +-
 doc/dox.h                                     |  18 +-
 doc/dox_cmd.h                                 |  38 +-
 fuzz/assimp_fuzzer.cc                         |   2 +-
 include/assimp/BaseImporter.h                 |   2 +-
 include/assimp/Compiler/poppack1.h            |   4 +-
 include/assimp/Compiler/pushpack1.h           |   4 +-
 include/assimp/Exceptional.h                  |   2 +-
 include/assimp/Exporter.hpp                   |   2 +-
 include/assimp/IOStreamBuffer.h               |   6 +-
 include/assimp/IOSystem.hpp                   |   8 +-
 include/assimp/Logger.hpp                     |   2 +-
 include/assimp/MemoryIOWrapper.h              |   6 +-
 include/assimp/SmallVector.h                  |   8 +-
 include/assimp/SmoothingGroups.inl            |  22 +-
 include/assimp/XmlParser.h                    |  10 +-
 include/assimp/ai_assert.h                    |   2 +-
 include/assimp/anim.h                         |   6 +-
 include/assimp/cimport.h                      |  12 +-
 include/assimp/defs.h                         |   2 +-
 include/assimp/light.h                        |   2 +-
 include/assimp/material.h                     |   8 +-
 include/assimp/matrix4x4.h                    |   2 +-
 include/assimp/matrix4x4.inl                  |   2 +-
 include/assimp/mesh.h                         |  10 +-
 include/assimp/postprocess.h                  |  14 +-
 include/assimp/scene.h                        |  26 +-
 include/assimp/vector2.inl                    |  14 +-
 .../windows-innosetup/readme_installer.txt    |   2 +-
 .../readme_installer_vieweronly.txt           |   2 +-
 packaging/windows-mkzip/bin_readme.txt        |   2 +-
 port/AndroidJNI/CMakeLists.txt                |   4 +-
 port/AssimpDelphi/Readme.txt                  |   2 +-
 port/jassimp/jassimp-native/src/jassimp.cpp   | 164 ++++----
 .../ModelLoaderHelperClasses.h                |  26 +-
 samples/SimpleAssimpViewX/MyDocument.h        |  18 +-
 samples/SimpleOpenGL/Sample_SimpleOpenGL.c    |   4 +-
 .../SimpleTexturedDirectx11/CMakeLists.txt    |   6 +-
 .../SimpleTexturedDirectx11/ModelLoader.cpp   |   2 +-
 .../SimpleTexturedDirectx11/TextureLoader.cpp |  56 +--
 .../SimpleTexturedDirectx11/main.cpp          |  10 +-
 .../src/model_loading.cpp                     |   4 +-
 test/models-nonbsd/3D/mar_rifle.source.txt    |   6 +-
 test/models-nonbsd/3DS/cart_wheel.source.txt  |   6 +-
 test/models-nonbsd/3DS/mar_rifle.source.txt   |   6 +-
 test/models-nonbsd/3DS/mp5_sil.source.txt     |   6 +-
 test/models-nonbsd/ASE/Rifle.source.txt       |   6 +-
 test/models-nonbsd/ASE/Rifle2.source.txt      |   6 +-
 .../BLEND/fleurOptonl.source.txt              |  16 +-
 test/models-nonbsd/DXF/rifle.source.txt       |   6 +-
 .../FBX/2013_ASCII/cart_wheel.source.txt      |   6 +-
 .../kwxport_test_vcolors.fbx.source.txt       |   6 +-
 .../FBX/2013_ASCII/mar_rifle.source.txt       |   6 +-
 .../FBX/2013_ASCII/mp5_sil.source.txt         |   6 +-
 .../FBX/2013_BINARY/cart_wheel.source.txt     |   6 +-
 .../kwxport_test_vcolors.fbx.source.txt       |   6 +-
 .../FBX/2013_BINARY/mar_rifle.source.txt      |   6 +-
 .../FBX/2013_BINARY/mp5_sil.source.txt        |   6 +-
 .../LWO2/LWSReferences/QuickDraw.source.txt   |  10 +-
 test/models-nonbsd/LWO/LWO2/rifle.source.txt  |   6 +-
 test/models-nonbsd/MD2/source.txt             |   6 +-
 test/models-nonbsd/MD5/BoarMan.source.txt     |   4 +-
 .../MDL/IDPO (Quake1)/gijoe-readme.txt        |  14 +-
 test/models-nonbsd/MDL/IDPO (Quake1)/steg.txt |   8 +-
 .../MDL/IDPO (Quake1)/tekmechbot.txt          |   6 +-
 test/models-nonbsd/NFF/NFFSense8/credits.txt  |   2 +-
 test/models-nonbsd/OBJ/rifle.source.txt       |   6 +-
 test/models/3DS/UVTransformTest/note.txt      |   4 +-
 test/models/ASE/MotionCaptureROM.source.txt   |   2 +-
 .../kwxport_test_vcolors.dae.source.txt       |   6 +-
 .../IRR/warn_dwarf_scaling_is_intended.txt    |   2 +-
 test/models/MD2/faerie-source.txt             |   2 +-
 test/models/MD2/sidney-source.txt             |   2 +-
 test/models/Q3D/E-AT-AT.source.txt            |   2 +-
 test/models/Q3D/earth.source.txt              |   2 +-
 test/models/WRL/credits.txt                   |   2 +-
 test/models/X/anim_test.txt                   |   2 +-
 .../X/kwxport_test_cubewithvcolors.source.txt |   6 +-
 test/models/X/test.txt                        |   2 +-
 test/models/invalid/readme.txt                |   8 +-
 test/regression/README.txt                    |   6 +-
 test/unit/AbstractImportExportBase.h          |   2 +-
 test/unit/Common/utStandardShapes.cpp         |   2 +-
 .../MDL/utMDLImporter_HL1_Nodes.cpp           |   4 +-
 test/unit/RandomNumberGeneration.h            |   4 +-
 test/unit/SceneDiffer.cpp                     |   2 +-
 test/unit/SceneDiffer.h                       |   2 +-
 test/unit/TestIOSystem.h                      |   2 +-
 test/unit/utDefaultIOStream.cpp               |   2 +-
 test/unit/utFBXImporterExporter.cpp           |   4 +-
 test/unit/utFindDegenerates.cpp               |   4 +-
 test/unit/utIOStreamBuffer.cpp                |   6 +-
 test/unit/utIOSystem.cpp                      |  10 +-
 test/unit/utIssues.cpp                        |   2 +-
 test/unit/utVersion.cpp                       |   2 +-
 test/unit/utglTF2ImportExport.cpp             |   2 +-
 tools/assimp_cmd/CMakeLists.txt               |   2 +-
 tools/assimp_cmd/Export.cpp                   |  18 +-
 tools/assimp_cmd/ImageExtractor.cpp           |  20 +-
 tools/assimp_cmd/Info.cpp                     |   2 +-
 tools/assimp_cmd/Main.cpp                     |  62 +--
 tools/assimp_cmd/Main.h                       |  40 +-
 tools/assimp_cmd/WriteDump.cpp                |  18 +-
 tools/assimp_cmd/resource.h                   |   2 +-
 tools/assimp_view/AnimEvaluator.h             |  12 +-
 tools/assimp_view/CMakeLists.txt              |   2 +-
 tools/assimp_view/Display.cpp                 |   6 +-
 tools/assimp_view/MessageProc.cpp             |   2 +-
 tools/assimp_view/Shaders.cpp                 |  18 +-
 tools/assimp_view/assimp_view.cpp             |  18 +-
 tools/assimp_view/resource.h                  |   2 +-
 185 files changed, 1160 insertions(+), 1160 deletions(-)

diff --git a/code/AssetLib/3DS/3DSExporter.cpp b/code/AssetLib/3DS/3DSExporter.cpp
index 92a6d5aa7c..0beecd5636 100644
--- a/code/AssetLib/3DS/3DSExporter.cpp
+++ b/code/AssetLib/3DS/3DSExporter.cpp
@@ -291,7 +291,7 @@ void Discreet3DSExporter::WriteMaterials() {
             ChunkWriter curChunk(writer, Discreet3DS::CHUNK_MAT_SPECULAR);
             WriteColor(color);
         }
-                
+
         if (mat.Get(AI_MATKEY_COLOR_AMBIENT, color) == AI_SUCCESS) {
             ChunkWriter curChunk(writer, Discreet3DS::CHUNK_MAT_AMBIENT);
             WriteColor(color);
diff --git a/code/AssetLib/3MF/D3MFImporter.cpp b/code/AssetLib/3MF/D3MFImporter.cpp
index 747af7cfc4..a56b82d632 100644
--- a/code/AssetLib/3MF/D3MFImporter.cpp
+++ b/code/AssetLib/3MF/D3MFImporter.cpp
@@ -274,7 +274,7 @@ class XmlSerializer {
         if (ret) {
             value = std::atoi(strValue.c_str());
             return true;
-        } 
+        }
 
         return false;
     }
diff --git a/code/AssetLib/AMF/AMFImporter.cpp b/code/AssetLib/AMF/AMFImporter.cpp
index 615882b6ad..88a38b827f 100644
--- a/code/AssetLib/AMF/AMFImporter.cpp
+++ b/code/AssetLib/AMF/AMFImporter.cpp
@@ -303,7 +303,7 @@ void AMFImporter::ParseNode_Root() {
     }
     XmlNode node = *root;
     mUnit = ai_tolower(std::string(node.attribute("unit").as_string()));
-    
+
     mVersion = node.attribute("version").as_string();
 
     // Read attributes for node <amf>.
diff --git a/code/AssetLib/AMF/AMFImporter_Geometry.cpp b/code/AssetLib/AMF/AMFImporter_Geometry.cpp
index 1fd2c49a48..1d2a1f5b46 100644
--- a/code/AssetLib/AMF/AMFImporter_Geometry.cpp
+++ b/code/AssetLib/AMF/AMFImporter_Geometry.cpp
@@ -75,7 +75,7 @@ void AMFImporter::ParseNode_Mesh(XmlNode &node) {
             found_volumes = true;
         }
         ParseHelper_Node_Exit();
-    } 
+    }
 
     if (!found_verts && !found_volumes) {
         mNodeElement_Cur->Child.push_back(ne);
@@ -199,9 +199,9 @@ void AMFImporter::ParseNode_Volume(XmlNode &node) {
 
     // Read attributes for node <color>.
     // and assign read data
-   
+
     ((AMFVolume *)ne)->MaterialID = node.attribute("materialid").as_string();
-     
+
     ((AMFVolume *)ne)->Type = type;
     // Check for child nodes
     bool col_read = false;
diff --git a/code/AssetLib/AMF/AMFImporter_Postprocess.cpp b/code/AssetLib/AMF/AMFImporter_Postprocess.cpp
index 43d0de52f5..d56d6681d7 100644
--- a/code/AssetLib/AMF/AMFImporter_Postprocess.cpp
+++ b/code/AssetLib/AMF/AMFImporter_Postprocess.cpp
@@ -69,7 +69,7 @@ aiColor4D AMFImporter::SPP_Material::GetColor(const float /*pX*/, const float /*
     }
 
     tcol = Color->Color;
-    
+
     // Check if default color must be used
     if ((tcol.r == 0) && (tcol.g == 0) && (tcol.b == 0) && (tcol.a == 0)) {
         tcol.r = 0.5f;
@@ -99,10 +99,10 @@ void AMFImporter::PostprocessHelper_CreateMeshDataArray(const AMFMesh &nodeEleme
     }
 
     // all coordinates stored as child and we need to reserve space for future push_back's.
-    vertexCoordinateArray.reserve(vn->Child.size()); 
+    vertexCoordinateArray.reserve(vn->Child.size());
 
     // colors count equal vertices count.
-    pVertexColorArray.resize(vn->Child.size()); 
+    pVertexColorArray.resize(vn->Child.size());
     col_idx = 0;
 
     // Inside vertices collect all data and place to arrays
diff --git a/code/AssetLib/Assjson/mesh_splitter.cpp b/code/AssetLib/Assjson/mesh_splitter.cpp
index 24385f9a07..9301cc27e9 100644
--- a/code/AssetLib/Assjson/mesh_splitter.cpp
+++ b/code/AssetLib/Assjson/mesh_splitter.cpp
@@ -110,7 +110,7 @@ void MeshSplitter :: SplitMesh(unsigned int a, aiMesh* in_mesh, std::vector<std:
 	// we need to split this mesh into sub meshes. Estimate submesh size
 	const unsigned int sub_meshes = (in_mesh->mNumVertices / LIMIT) + 1;
 
-	// create a std::vector<unsigned int> to remember which vertices have already 
+	// create a std::vector<unsigned int> to remember which vertices have already
 	// been copied and to which position (i.e. output index)
 	std::vector<unsigned int> was_copied_to;
 	was_copied_to.resize(in_mesh->mNumVertices,WAS_NOT_COPIED);
@@ -125,7 +125,7 @@ void MeshSplitter :: SplitMesh(unsigned int a, aiMesh* in_mesh, std::vector<std:
 	while (true) {
 		const unsigned int out_vertex_index = LIMIT;
 
-		aiMesh* out_mesh = new aiMesh();			
+		aiMesh* out_mesh = new aiMesh();
 		out_mesh->mNumVertices = 0;
 		out_mesh->mMaterialIndex = in_mesh->mMaterialIndex;
 
@@ -179,7 +179,7 @@ void MeshSplitter :: SplitMesh(unsigned int a, aiMesh* in_mesh, std::vector<std:
 
 				// check whether we do already have this vertex
 				if (WAS_NOT_COPIED == was_copied_to[index])	{
-					iNeed++; 
+					iNeed++;
 				}
 			}
 			if (out_mesh->mNumVertices + iNeed > out_vertex_index)	{
@@ -240,7 +240,7 @@ void MeshSplitter :: SplitMesh(unsigned int a, aiMesh* in_mesh, std::vector<std:
 						out_mesh->mTextureCoords[c][out_mesh->mNumVertices] = in_mesh->mTextureCoords[c][index];
 					}
 				}
-				// vertex colors 
+				// vertex colors
 				for (unsigned int c = 0;  c < AI_MAX_NUMBER_OF_COLOR_SETS;++c) {
 					if (in_mesh->HasVertexColors( c)) {
 						out_mesh->mColors[c][out_mesh->mNumVertices] = in_mesh->mColors[c][index];
diff --git a/code/AssetLib/Assjson/mesh_splitter.h b/code/AssetLib/Assjson/mesh_splitter.h
index 326f73b41e..3bb26118a3 100644
--- a/code/AssetLib/Assjson/mesh_splitter.h
+++ b/code/AssetLib/Assjson/mesh_splitter.h
@@ -22,13 +22,13 @@ struct aiNode;
 
 // ---------------------------------------------------------------------------
 /** Splits meshes of unique vertices into meshes with no more vertices than
- *  a given, configurable threshold value. 
+ *  a given, configurable threshold value.
  */
-class MeshSplitter 
+class MeshSplitter
 {
 
 public:
-	
+
 	void SetLimit(unsigned int l) {
 		LIMIT = l;
 	}
diff --git a/code/AssetLib/Assxml/AssxmlExporter.cpp b/code/AssetLib/Assxml/AssxmlExporter.cpp
index 847ba0d7e3..d244813b14 100644
--- a/code/AssetLib/Assxml/AssxmlExporter.cpp
+++ b/code/AssetLib/Assxml/AssxmlExporter.cpp
@@ -50,7 +50,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <assimp/IOSystem.hpp>
 #include <assimp/Exporter.hpp>
 
-namespace Assimp   { 
+namespace Assimp   {
 
 void ExportSceneAssxml(const char* pFile, IOSystem* pIOSystem, const aiScene* pScene, const ExportProperties* /*pProperties*/)
 {
diff --git a/code/AssetLib/Blender/BlenderModifier.h b/code/AssetLib/Blender/BlenderModifier.h
index daf120087d..d2fea43c10 100644
--- a/code/AssetLib/Blender/BlenderModifier.h
+++ b/code/AssetLib/Blender/BlenderModifier.h
@@ -52,9 +52,9 @@ namespace Assimp {
 namespace Blender {
 
 // -------------------------------------------------------------------------------------------
-/** 
+/**
  *  Dummy base class for all blender modifiers. Modifiers are reused between imports, so
- *  they should be stateless and not try to cache model data. 
+ *  they should be stateless and not try to cache model data.
  */
 // -------------------------------------------------------------------------------------------
 class BlenderModifier {
@@ -67,7 +67,7 @@ class BlenderModifier {
     }
 
     // --------------------
-    /** 
+    /**
      *  Check if *this* modifier is active, given a ModifierData& block.
      */
     virtual bool IsActive( const ModifierData& /*modin*/) {
@@ -75,10 +75,10 @@ class BlenderModifier {
     }
 
     // --------------------
-    /** 
+    /**
      *  Apply the modifier to a given output node. The original data used
      *  to construct the node is given as well. Not called unless IsActive()
-     *  was called and gave positive response. 
+     *  was called and gave positive response.
      */
     virtual void DoIt(aiNode& /*out*/,
         ConversionData& /*conv_data*/,
@@ -92,8 +92,8 @@ class BlenderModifier {
 };
 
 // -------------------------------------------------------------------------------------------
-/** 
- *  Manage all known modifiers and instance and apply them if necessary 
+/**
+ *  Manage all known modifiers and instance and apply them if necessary
  */
 // -------------------------------------------------------------------------------------------
 class BlenderModifierShowcase {
@@ -113,8 +113,8 @@ class BlenderModifierShowcase {
 // MODIFIERS /////////////////////////////////////////////////////////////////////////////////
 
 // -------------------------------------------------------------------------------------------
-/** 
- *  Mirror modifier. Status: implemented. 
+/**
+ *  Mirror modifier. Status: implemented.
  */
 // -------------------------------------------------------------------------------------------
 class BlenderModifier_Mirror : public BlenderModifier {
diff --git a/code/AssetLib/C4D/C4DImporter.cpp b/code/AssetLib/C4D/C4DImporter.cpp
index 5408daa68d..14a94958be 100644
--- a/code/AssetLib/C4D/C4DImporter.cpp
+++ b/code/AssetLib/C4D/C4DImporter.cpp
@@ -148,12 +148,12 @@ void C4DImporter::InternReadFile( const std::string& pFile, aiScene* pScene, IOS
 
     // Generate the root-node
     pScene->mRootNode = new aiNode("<C4DRoot>");
-    
+
     // convert left-handed to right-handed
     pScene->mRootNode->mTransformation.a1 = 0.01f;
     pScene->mRootNode->mTransformation.b2 = 0.01f;
-    pScene->mRootNode->mTransformation.c3 = -0.01f; 
-    
+    pScene->mRootNode->mTransformation.c3 = -0.01f;
+
     // first convert all materials
     ReadMaterials(doc->GetFirstMaterial());
 
diff --git a/code/AssetLib/COB/COBLoader.cpp b/code/AssetLib/COB/COBLoader.cpp
index 822bce16df..3bef260e51 100644
--- a/code/AssetLib/COB/COBLoader.cpp
+++ b/code/AssetLib/COB/COBLoader.cpp
@@ -884,7 +884,7 @@ void COBImporter::ReadBinaryFile(Scene &out, StreamReaderLE *reader) {
         std::string type;
         type += reader->GetI1();
         type += reader->GetI1();
-        type += reader->GetI1(); 
+        type += reader->GetI1();
         type += reader->GetI1();
 
         ChunkInfo nfo;
diff --git a/code/AssetLib/COB/COBLoader.h b/code/AssetLib/COB/COBLoader.h
index 2317d094e6..e4d41e5009 100644
--- a/code/AssetLib/COB/COBLoader.h
+++ b/code/AssetLib/COB/COBLoader.h
@@ -77,7 +77,7 @@ class COBImporter : public BaseImporter
 public:
     COBImporter();
     ~COBImporter();
-    
+
     // --------------------
     bool CanRead( const std::string& pFile, IOSystem* pIOHandler,
         bool checkSig) const;
diff --git a/code/AssetLib/Collada/ColladaLoader.cpp b/code/AssetLib/Collada/ColladaLoader.cpp
index ee8f97203b..ccb2bb336f 100644
--- a/code/AssetLib/Collada/ColladaLoader.cpp
+++ b/code/AssetLib/Collada/ColladaLoader.cpp
@@ -1675,7 +1675,7 @@ void ColladaLoader::BuildMaterials(ColladaParser &pParser, aiScene * /*pScene*/)
         const Material &material = matIt->second;
         // a material is only a reference to an effect
         ColladaParser::EffectLibrary::iterator effIt = pParser.mEffectLibrary.find(material.mEffect);
-        if (effIt == pParser.mEffectLibrary.end())  
+        if (effIt == pParser.mEffectLibrary.end())
             continue;
         Effect &effect = effIt->second;
 
diff --git a/code/AssetLib/DXF/DXFLoader.cpp b/code/AssetLib/DXF/DXFLoader.cpp
index 49d572b0bf..2e38ed9761 100644
--- a/code/AssetLib/DXF/DXFLoader.cpp
+++ b/code/AssetLib/DXF/DXFLoader.cpp
@@ -547,7 +547,7 @@ void DXFImporter::ParseEntities(DXF::LineReader& reader, DXF::FileData& output)
         ++reader;
     }
 
-    ASSIMP_LOG_VERBOSE_DEBUG( "DXF: got ", block.lines.size()," polylines and ", block.insertions.size(), 
+    ASSIMP_LOG_VERBOSE_DEBUG( "DXF: got ", block.lines.size()," polylines and ", block.insertions.size(),
         " inserted blocks in ENTITIES" );
 }
 
diff --git a/code/AssetLib/DXF/DXFLoader.h b/code/AssetLib/DXF/DXFLoader.h
index 5319d2528b..6649deb344 100644
--- a/code/AssetLib/DXF/DXFLoader.h
+++ b/code/AssetLib/DXF/DXFLoader.h
@@ -63,7 +63,7 @@ namespace DXF {
 }
 
 // ---------------------------------------------------------------------------
-/** 
+/**
  *  @brief  DXF importer implementation.
  */
 class DXFImporter : public BaseImporter {
diff --git a/code/AssetLib/FBX/FBXConverter.cpp b/code/AssetLib/FBX/FBXConverter.cpp
index f489e37a40..e0da78583e 100644
--- a/code/AssetLib/FBX/FBXConverter.cpp
+++ b/code/AssetLib/FBX/FBXConverter.cpp
@@ -862,7 +862,7 @@ bool FBXConverter::GenerateTransformationNodeChain(const Model &model, const std
     output_nodes.push_back(std::move(nd));
     return false;
 }
-  
+
 void FBXConverter::SetupNodeMetadata(const Model &model, aiNode &nd) {
     const PropertyTable &props = model.Props();
     DirectPropertyMap unparsedProperties = props.GetUnparsedProperties();
@@ -3572,7 +3572,7 @@ void FBXConverter::ConvertOrphanedEmbeddedTextures() {
                         if (texture->Media() && texture->Media()->ContentLength() > 0) {
                             realTexture = texture;
                         }
-                    }    
+                    }
                 }
             } catch (...) {
                 // do nothing
diff --git a/code/AssetLib/FBX/FBXConverter.h b/code/AssetLib/FBX/FBXConverter.h
index d208ab429c..b9a494695e 100644
--- a/code/AssetLib/FBX/FBXConverter.h
+++ b/code/AssetLib/FBX/FBXConverter.h
@@ -76,7 +76,7 @@ namespace Assimp {
 namespace FBX {
 
 class Document;
-/** 
+/**
  *  Convert a FBX #Document to #aiScene
  *  @param out Empty scene to be populated
  *  @param doc Parsed FBX document
@@ -182,7 +182,7 @@ class FBXConverter {
     // ------------------------------------------------------------------------------------------------
     void ConvertModel(const Model &model, aiNode *parent, aiNode *root_node,
                       const aiMatrix4x4 &absolute_transform);
-    
+
     // ------------------------------------------------------------------------------------------------
     // MeshGeometry -> aiMesh, return mesh index + 1 or 0 if the conversion failed
     std::vector<unsigned int>
diff --git a/code/AssetLib/FBX/FBXDocument.cpp b/code/AssetLib/FBX/FBXDocument.cpp
index 0c4435348a..8e0439e189 100644
--- a/code/AssetLib/FBX/FBXDocument.cpp
+++ b/code/AssetLib/FBX/FBXDocument.cpp
@@ -635,7 +635,7 @@ std::vector<const Connection*> Document::GetConnectionsBySourceSequenced(uint64_
 }
 
 // ------------------------------------------------------------------------------------------------
-std::vector<const Connection*> Document::GetConnectionsBySourceSequenced(uint64_t source, 
+std::vector<const Connection*> Document::GetConnectionsBySourceSequenced(uint64_t source,
         const char* const* classnames, size_t count) const
 {
     return GetConnectionsSequenced(source, true, ConnectionsBySource(),classnames, count);
diff --git a/code/AssetLib/FBX/FBXExportNode.h b/code/AssetLib/FBX/FBXExportNode.h
index 6ef27972da..3aca989390 100644
--- a/code/AssetLib/FBX/FBXExportNode.h
+++ b/code/AssetLib/FBX/FBXExportNode.h
@@ -60,7 +60,7 @@ namespace FBX {
 }
 
 class FBX::Node {
-public: 
+public:
     // TODO: accessors
     std::string name; // node name
     std::vector<FBX::FBXExportProperty> properties; // node properties
diff --git a/code/AssetLib/FBX/FBXExporter.cpp b/code/AssetLib/FBX/FBXExporter.cpp
index c19c593dd2..84a77e18d8 100644
--- a/code/AssetLib/FBX/FBXExporter.cpp
+++ b/code/AssetLib/FBX/FBXExporter.cpp
@@ -498,7 +498,7 @@ void FBXExporter::WriteDocuments ()
     if (!binary) {
         WriteAsciiSectionHeader("Documents Description");
     }
-    
+
     // not sure what the use of multiple documents would be,
     // or whether any end-application supports it
     FBX::Node docs("Documents");
@@ -1258,7 +1258,7 @@ void FBXExporter::WriteObjects ()
             indent = 2;
             vertexcolors.End(outstream, binary, indent, true);
         }
-        
+
         // uvs, if any
         for (size_t uvi = 0; uvi < m->GetNumUVChannels(); ++uvi) {
             if (m->mNumUVComponents[uvi] > 2) {
@@ -1751,7 +1751,7 @@ void FBXExporter::WriteObjects ()
         bsnode.AddProperty(blendshape_uid);
         bsnode.AddProperty(blendshape_name + FBX::SEPARATOR + "Blendshape");
         bsnode.AddProperty("Shape");
-        bsnode.AddChild("Version", int32_t(100));        
+        bsnode.AddChild("Version", int32_t(100));
         bsnode.Begin(outstream, binary, indent);
         bsnode.DumpProperties(outstream, binary, indent);
         bsnode.EndProperties(outstream, binary, indent);
@@ -1877,7 +1877,7 @@ void FBXExporter::WriteObjects ()
     // at the same time we can build a list of all the skeleton nodes,
     // which will be used later to mark them as type "limbNode".
     std::unordered_set<const aiNode*> limbnodes;
-    
+
     //actual bone nodes in fbx, without parenting-up
     std::unordered_set<std::string> setAllBoneNamesInScene;
     for(unsigned int m = 0; m < mScene->mNumMeshes; ++ m)
@@ -1887,7 +1887,7 @@ void FBXExporter::WriteObjects ()
             setAllBoneNamesInScene.insert(pMesh->mBones[b]->mName.data);
     }
     aiMatrix4x4 mxTransIdentity;
-    
+
     // and a map of nodes by bone name, as finding them is annoying.
     std::map<std::string,aiNode*> node_by_bone;
     for (size_t mi = 0; mi < mScene->mNumMeshes; ++mi) {
@@ -1956,7 +1956,7 @@ void FBXExporter::WriteObjects ()
                     }
                     if (end) { break; }
                 }
-                
+
                 // if it was the skeleton root we can finish here
                 if (end) { break; }
             }
diff --git a/code/AssetLib/FBX/FBXMaterial.cpp b/code/AssetLib/FBX/FBXMaterial.cpp
index aaa043c127..7eb0471772 100644
--- a/code/AssetLib/FBX/FBXMaterial.cpp
+++ b/code/AssetLib/FBX/FBXMaterial.cpp
@@ -142,8 +142,8 @@ Material::~Material() {
 
 // ------------------------------------------------------------------------------------------------
 Texture::Texture(uint64_t id, const Element& element, const Document& doc, const std::string& name) :
-        Object(id,element,name), 
-        uvScaling(1.0f,1.0f), 
+        Object(id,element,name),
+        uvScaling(1.0f,1.0f),
         media(0) {
     const Scope& sc = GetRequiredScope(element);
 
@@ -278,8 +278,8 @@ void LayeredTexture::fillTexture(const Document& doc) {
 
 // ------------------------------------------------------------------------------------------------
 Video::Video(uint64_t id, const Element& element, const Document& doc, const std::string& name) :
-        Object(id,element,name), 
-        contentLength(0), 
+        Object(id,element,name),
+        contentLength(0),
         content(0) {
     const Scope& sc = GetRequiredScope(element);
 
diff --git a/code/AssetLib/FBX/FBXMeshGeometry.cpp b/code/AssetLib/FBX/FBXMeshGeometry.cpp
index 5aecb61b58..6aeebcbe3c 100644
--- a/code/AssetLib/FBX/FBXMeshGeometry.cpp
+++ b/code/AssetLib/FBX/FBXMeshGeometry.cpp
@@ -633,7 +633,7 @@ void MeshGeometry::ReadVertexDataMaterials(std::vector<int>& materials_out, cons
     {
         return;
     }
-    
+
     // materials are handled separately. First of all, they are assigned per-face
     // and not per polyvert. Secondly, ReferenceInformationType=IndexToDirect
     // has a slightly different meaning for materials.
diff --git a/code/AssetLib/FBX/FBXMeshGeometry.h b/code/AssetLib/FBX/FBXMeshGeometry.h
index ae17860e30..862693b4bb 100644
--- a/code/AssetLib/FBX/FBXMeshGeometry.h
+++ b/code/AssetLib/FBX/FBXMeshGeometry.h
@@ -52,8 +52,8 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 namespace Assimp {
 namespace FBX {
 
-/** 
- *  DOM base class for all kinds of FBX geometry 
+/**
+ *  DOM base class for all kinds of FBX geometry
  */
 class Geometry : public Object
 {
@@ -76,7 +76,7 @@ class Geometry : public Object
 typedef std::vector<int> MatIndexArray;
 
 
-/** 
+/**
  *  DOM class for FBX geometry of type "Mesh"
  */
 class MeshGeometry : public Geometry
@@ -84,7 +84,7 @@ class MeshGeometry : public Geometry
 public:
     /** The class constructor */
     MeshGeometry( uint64_t id, const Element& element, const std::string& name, const Document& doc );
-    
+
     /** The class destructor */
     virtual ~MeshGeometry();
 
diff --git a/code/AssetLib/FBX/FBXProperties.h b/code/AssetLib/FBX/FBXProperties.h
index 9ab784fa70..d1d6b87abd 100644
--- a/code/AssetLib/FBX/FBXProperties.h
+++ b/code/AssetLib/FBX/FBXProperties.h
@@ -98,7 +98,7 @@ typedef std::fbx_unordered_map<std::string,std::shared_ptr<Property> > DirectPro
 typedef std::fbx_unordered_map<std::string,const Property*>            PropertyMap;
 typedef std::fbx_unordered_map<std::string,const Element*>             LazyPropertyMap;
 
-/** 
+/**
  *  Represents a property table as can be found in the newer FBX files (Properties60, Properties70)
  */
 class PropertyTable {
@@ -130,7 +130,7 @@ class PropertyTable {
 
 // ------------------------------------------------------------------------------------------------
 template <typename T>
-inline 
+inline
 T PropertyGet(const PropertyTable& in, const std::string& name, const T& defaultValue) {
     const Property* const prop = in.Get(name);
     if( nullptr == prop) {
@@ -148,7 +148,7 @@ T PropertyGet(const PropertyTable& in, const std::string& name, const T& default
 
 // ------------------------------------------------------------------------------------------------
 template <typename T>
-inline 
+inline
 T PropertyGet(const PropertyTable& in, const std::string& name, bool& result, bool useTemplate=false ) {
     const Property* prop = in.Get(name);
     if( nullptr == prop) {
diff --git a/code/AssetLib/FBX/FBXUtil.cpp b/code/AssetLib/FBX/FBXUtil.cpp
index 66abf0565f..3fe791b974 100644
--- a/code/AssetLib/FBX/FBXUtil.cpp
+++ b/code/AssetLib/FBX/FBXUtil.cpp
@@ -101,7 +101,7 @@ std::string GetLineAndColumnText(unsigned int line, unsigned int column)
 std::string GetTokenText(const Token* tok)
 {
     if(tok->IsBinary()) {
-        return static_cast<std::string>( Formatter::format() << 
+        return static_cast<std::string>( Formatter::format() <<
             " (" << TokenTypeString(tok->Type()) <<
             ", offset 0x" << std::hex << tok->Offset() << ") " );
     }
diff --git a/code/AssetLib/HMP/HMPLoader.cpp b/code/AssetLib/HMP/HMPLoader.cpp
index cd14cb9c3c..97c1858fbe 100644
--- a/code/AssetLib/HMP/HMPLoader.cpp
+++ b/code/AssetLib/HMP/HMPLoader.cpp
@@ -153,10 +153,10 @@ void HMPImporter::InternReadFile(const std::string &pFile,
     } else {
         // Print the magic word to the logger
         std::string szBuffer = ai_str_toprintable((const char *)&iMagic, sizeof(iMagic));
-    
+
         delete[] mBuffer;
         mBuffer = nullptr;
-        
+
         // We're definitely unable to load this file
         throw DeadlyImportError("Unknown HMP subformat ", pFile,
                                 ". Magic word (", szBuffer, ") is not known");
diff --git a/code/AssetLib/IFC/IFCCurve.cpp b/code/AssetLib/IFC/IFCCurve.cpp
index 28cd9690c8..3ded43bc0f 100644
--- a/code/AssetLib/IFC/IFCCurve.cpp
+++ b/code/AssetLib/IFC/IFCCurve.cpp
@@ -514,7 +514,7 @@ IfcFloat Curve::GetParametricRangeDelta() const {
 
 // ------------------------------------------------------------------------------------------------
 size_t Curve::EstimateSampleCount(IfcFloat a, IfcFloat b) const {
-    (void)(a); (void)(b);  
+    (void)(a); (void)(b);
     ai_assert( InRange( a ) );
     ai_assert( InRange( b ) );
 
diff --git a/code/AssetLib/IFC/IFCOpenings.cpp b/code/AssetLib/IFC/IFCOpenings.cpp
index b7665582cc..d6671b885e 100644
--- a/code/AssetLib/IFC/IFCOpenings.cpp
+++ b/code/AssetLib/IFC/IFCOpenings.cpp
@@ -911,14 +911,14 @@ size_t CloseWindows(ContourVector& contours,
             // compare base poly normal and contour normal to detect if we need to reverse the face winding
 			if(curmesh.mVertcnt.size() > 0) {
 				IfcVector3 basePolyNormal = TempMesh::ComputePolygonNormal(curmesh.mVerts.data(), curmesh.mVertcnt.front());
-				
+
 				std::vector<IfcVector3> worldSpaceContourVtx(it->contour.size());
-				
+
 				for(size_t a = 0; a < it->contour.size(); ++a)
 					worldSpaceContourVtx[a] = minv * IfcVector3(it->contour[a].x, it->contour[a].y, 0.0);
-				
+
 				IfcVector3 contourNormal = TempMesh::ComputePolygonNormal(worldSpaceContourVtx.data(), worldSpaceContourVtx.size());
-				
+
 				reverseCountourFaces = (contourNormal * basePolyNormal) > 0.0;
 			}
 
diff --git a/code/AssetLib/IFC/IFCReaderGen1_2x3.cpp b/code/AssetLib/IFC/IFCReaderGen1_2x3.cpp
index 2cfa225301..a6f7ae3eb9 100644
--- a/code/AssetLib/IFC/IFCReaderGen1_2x3.cpp
+++ b/code/AssetLib/IFC/IFCReaderGen1_2x3.cpp
@@ -5,8 +5,8 @@ Open Asset Import Library (ASSIMP)
 Copyright (c) 2006-2020, ASSIMP Development Team
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the
 following conditions are met:
 
 * Redistributions of source code must retain the above
@@ -23,16 +23,16 @@ following conditions are met:
   derived from this software without specific prior
   written permission of the ASSIMP Development Team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
@@ -1063,27 +1063,27 @@ template <> size_t GenericFill<IfcRoot>(const DB& db, const LIST& params, IfcRoo
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRoot"); }    do { // convert the 'GlobalId' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRoot,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->GlobalId, arg, db ); break; } 
+        try { GenericConvert( in->GlobalId, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRoot to be a `IfcGloballyUniqueId`")); }
     } while(0);
     do { // convert the 'OwnerHistory' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRoot,4>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->OwnerHistory, arg, db ); break; } 
+        try { GenericConvert( in->OwnerHistory, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRoot to be a `IfcOwnerHistory`")); }
     } while(0);
     do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRoot,4>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRoot to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Description' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRoot,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRoot to be a `IfcText`")); }
     } while(0);
 	return base;
@@ -1150,27 +1150,27 @@ template <> size_t GenericFill<IfcRepresentation>(const DB& db, const LIST& para
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRepresentation"); }    do { // convert the 'ContextOfItems' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentation,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ContextOfItems, arg, db ); break; } 
+        try { GenericConvert( in->ContextOfItems, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentation to be a `IfcRepresentationContext`")); }
     } while(0);
     do { // convert the 'RepresentationIdentifier' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentation,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationIdentifier, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationIdentifier, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'RepresentationType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentation,4>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationType, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Items' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentation,4>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->Items, arg, db ); break; } 
+        try { GenericConvert( in->Items, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRepresentation to be a `SET [1:?] OF IfcRepresentationItem`")); }
     } while(0);
 	return base;
@@ -1237,7 +1237,7 @@ template <> size_t GenericFill<IfcObject>(const DB& db, const LIST& params, IfcO
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcObject,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectType, arg, db ); break; } 
+        try { GenericConvert( in->ObjectType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcObject to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -1290,20 +1290,20 @@ template <> size_t GenericFill<IfcProductRepresentation>(const DB& db, const LIS
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProductRepresentation,3>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProductRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Description' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProductRepresentation,3>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProductRepresentation to be a `IfcText`")); }
     } while(0);
     do { // convert the 'Representations' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProductRepresentation,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->Representations, arg, db ); break; } 
+        try { GenericConvert( in->Representations, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcProductRepresentation to be a `LIST [1:?] OF IfcRepresentation`")); }
     } while(0);
 	return base;
@@ -1316,14 +1316,14 @@ template <> size_t GenericFill<IfcProduct>(const DB& db, const LIST& params, Ifc
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProduct,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectPlacement, arg, db ); break; } 
+        try { GenericConvert( in->ObjectPlacement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcProduct to be a `IfcObjectPlacement`")); }
     } while(0);
     do { // convert the 'Representation' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProduct,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Representation, arg, db ); break; } 
+        try { GenericConvert( in->Representation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcProduct to be a `IfcProductRepresentation`")); }
     } while(0);
 	return base;
@@ -1336,7 +1336,7 @@ template <> size_t GenericFill<IfcElement>(const DB& db, const LIST& params, Ifc
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Tag, arg, db ); break; } 
+        try { GenericConvert( in->Tag, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcElement to be a `IfcIdentifier`")); }
     } while(0);
 	return base;
@@ -1374,13 +1374,13 @@ template <> size_t GenericFill<IfcCompositeCurve>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCompositeCurve"); }    do { // convert the 'Segments' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCompositeCurve,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Segments, arg, db ); break; } 
+        try { GenericConvert( in->Segments, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurve to be a `LIST [1:?] OF IfcCompositeCurveSegment`")); }
     } while(0);
     do { // convert the 'SelfIntersect' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCompositeCurve,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->SelfIntersect, arg, db ); break; } 
+        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurve to be a `LOGICAL`")); }
     } while(0);
 	return base;
@@ -1400,27 +1400,27 @@ template <> size_t GenericFill<IfcCartesianTransformationOperator>(const DB& db,
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator,4>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis1, arg, db ); break; } 
+        try { GenericConvert( in->Axis1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Axis2' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis2, arg, db ); break; } 
+        try { GenericConvert( in->Axis2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'LocalOrigin' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator,4>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->LocalOrigin, arg, db ); break; } 
+        try { GenericConvert( in->LocalOrigin, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCartesianTransformationOperator to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'Scale' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale, arg, db ); break; } 
+        try { GenericConvert( in->Scale, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCartesianTransformationOperator to be a `REAL`")); }
     } while(0);
 	return base;
@@ -1433,7 +1433,7 @@ template <> size_t GenericFill<IfcCartesianTransformationOperator3D>(const DB& d
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCartesianTransformationOperator3D,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis3, arg, db ); break; } 
+        try { GenericConvert( in->Axis3, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCartesianTransformationOperator3D to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -1445,14 +1445,14 @@ template <> size_t GenericFill<IfcProperty>(const DB& db, const LIST& params, If
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProperty"); }    do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProperty,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProperty to be a `IfcIdentifier`")); }
     } while(0);
     do { // convert the 'Description' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProperty,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProperty to be a `IfcText`")); }
     } while(0);
 	return base;
@@ -1497,7 +1497,7 @@ template <> size_t GenericFill<IfcElementarySurface>(const DB& db, const LIST& p
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcElementarySurface"); }    do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcElementarySurface,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcElementarySurface to be a `IfcAxis2Placement3D`")); }
     } while(0);
 	return base;
@@ -1515,19 +1515,19 @@ template <> size_t GenericFill<IfcBooleanResult>(const DB& db, const LIST& param
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcBooleanResult"); }    do { // convert the 'Operator' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBooleanResult,3>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Operator, arg, db ); break; } 
+        try { GenericConvert( in->Operator, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBooleanResult to be a `IfcBooleanOperator`")); }
     } while(0);
     do { // convert the 'FirstOperand' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBooleanResult,3>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->FirstOperand, arg, db ); break; } 
+        try { GenericConvert( in->FirstOperand, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
     } while(0);
     do { // convert the 'SecondOperand' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBooleanResult,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->SecondOperand, arg, db ); break; } 
+        try { GenericConvert( in->SecondOperand, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
     } while(0);
 	return base;
@@ -1551,7 +1551,7 @@ template <> size_t GenericFill<IfcManifoldSolidBrep>(const DB& db, const LIST& p
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcManifoldSolidBrep"); }    do { // convert the 'Outer' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcManifoldSolidBrep,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Outer, arg, db ); break; } 
+        try { GenericConvert( in->Outer, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcManifoldSolidBrep to be a `IfcClosedShell`")); }
     } while(0);
 	return base;
@@ -1630,12 +1630,12 @@ template <> size_t GenericFill<IfcRelFillsElement>(const DB& db, const LIST& par
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelFillsElement"); }    do { // convert the 'RelatingOpeningElement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingOpeningElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatingOpeningElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelFillsElement to be a `IfcOpeningElement`")); }
     } while(0);
     do { // convert the 'RelatedBuildingElement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedBuildingElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatedBuildingElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelFillsElement to be a `IfcElement`")); }
     } while(0);
 	return base;
@@ -1681,12 +1681,12 @@ template <> size_t GenericFill<IfcRelContainedInSpatialStructure>(const DB& db,
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelContainedInSpatialStructure"); }    do { // convert the 'RelatedElements' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedElements, arg, db ); break; } 
+        try { GenericConvert( in->RelatedElements, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelContainedInSpatialStructure to be a `SET [1:?] OF IfcProduct`")); }
     } while(0);
     do { // convert the 'RelatingStructure' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingStructure, arg, db ); break; } 
+        try { GenericConvert( in->RelatingStructure, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelContainedInSpatialStructure to be a `IfcSpatialStructureElement`")); }
     } while(0);
 	return base;
@@ -1772,7 +1772,7 @@ template <> size_t GenericFill<IfcDirection>(const DB& db, const LIST& params, I
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcDirection"); }    do { // convert the 'DirectionRatios' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->DirectionRatios, arg, db ); break; } 
+        try { GenericConvert( in->DirectionRatios, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcDirection to be a `LIST [2:3] OF REAL`")); }
     } while(0);
 	return base;
@@ -1784,14 +1784,14 @@ template <> size_t GenericFill<IfcProfileDef>(const DB& db, const LIST& params,
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProfileDef"); }    do { // convert the 'ProfileType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProfileDef,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ProfileType, arg, db ); break; } 
+        try { GenericConvert( in->ProfileType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProfileDef to be a `IfcProfileTypeEnum`")); }
     } while(0);
     do { // convert the 'ProfileName' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcProfileDef,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ProfileName, arg, db ); break; } 
+        try { GenericConvert( in->ProfileName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProfileDef to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -1803,7 +1803,7 @@ template <> size_t GenericFill<IfcParameterizedProfileDef>(const DB& db, const L
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcParameterizedProfileDef"); }    do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcParameterizedProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcParameterizedProfileDef to be a `IfcAxis2Placement2D`")); }
     } while(0);
 	return base;
@@ -1910,7 +1910,7 @@ template <> size_t GenericFill<IfcCircleProfileDef>(const DB& db, const LIST& pa
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcCircleProfileDef"); }    do { // convert the 'Radius' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcCircleProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCircleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -1921,7 +1921,7 @@ template <> size_t GenericFill<IfcCircleHollowProfileDef>(const DB& db, const LI
 	size_t base = GenericFill(db,params,static_cast<IfcCircleProfileDef*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcCircleHollowProfileDef"); }    do { // convert the 'WallThickness' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->WallThickness, arg, db ); break; } 
+        try { GenericConvert( in->WallThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCircleHollowProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -1933,7 +1933,7 @@ template <> size_t GenericFill<IfcPlacement>(const DB& db, const LIST& params, I
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPlacement"); }    do { // convert the 'Location' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcPlacement,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Location, arg, db ); break; } 
+        try { GenericConvert( in->Location, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPlacement to be a `IfcCartesianPoint`")); }
     } while(0);
 	return base;
@@ -1945,13 +1945,13 @@ template <> size_t GenericFill<IfcAxis2Placement3D>(const DB& db, const LIST& pa
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcAxis2Placement3D"); }    do { // convert the 'Axis' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement3D to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'RefDirection' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefDirection, arg, db ); break; } 
+        try { GenericConvert( in->RefDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcAxis2Placement3D to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -1964,7 +1964,7 @@ template <> size_t GenericFill<IfcPresentationStyle>(const DB& db, const LIST& p
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcPresentationStyle,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyle to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -1982,17 +1982,17 @@ template <> size_t GenericFill<IfcCompositeCurveSegment>(const DB& db, const LIS
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcCompositeCurveSegment"); }    do { // convert the 'Transition' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Transition, arg, db ); break; } 
+        try { GenericConvert( in->Transition, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurveSegment to be a `IfcTransitionCode`")); }
     } while(0);
     do { // convert the 'SameSense' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SameSense, arg, db ); break; } 
+        try { GenericConvert( in->SameSense, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurveSegment to be a `BOOLEAN`")); }
     } while(0);
     do { // convert the 'ParentCurve' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ParentCurve, arg, db ); break; } 
+        try { GenericConvert( in->ParentCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCompositeCurveSegment to be a `IfcCurve`")); }
     } while(0);
 	return base;
@@ -2004,13 +2004,13 @@ template <> size_t GenericFill<IfcRectangleProfileDef>(const DB& db, const LIST&
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcRectangleProfileDef"); }    do { // convert the 'XDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRectangleProfileDef,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->XDim, arg, db ); break; } 
+        try { GenericConvert( in->XDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'YDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRectangleProfileDef,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->YDim, arg, db ); break; } 
+        try { GenericConvert( in->YDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -2106,12 +2106,12 @@ template <> size_t GenericFill<IfcLocalPlacement>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLocalPlacement"); }    do { // convert the 'PlacementRelTo' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PlacementRelTo, arg, db ); break; } 
+        try { GenericConvert( in->PlacementRelTo, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLocalPlacement to be a `IfcObjectPlacement`")); }
     } while(0);
     do { // convert the 'RelativePlacement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelativePlacement, arg, db ); break; } 
+        try { GenericConvert( in->RelativePlacement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLocalPlacement to be a `IfcAxis2Placement`")); }
     } while(0);
 	return base;
@@ -2123,13 +2123,13 @@ template <> size_t GenericFill<IfcSweptAreaSolid>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcSweptAreaSolid"); }    do { // convert the 'SweptArea' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSweptAreaSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->SweptArea, arg, db ); break; } 
+        try { GenericConvert( in->SweptArea, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptAreaSolid to be a `IfcProfileDef`")); }
     } while(0);
     do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSweptAreaSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptAreaSolid to be a `IfcAxis2Placement3D`")); }
     } while(0);
 	return base;
@@ -2140,12 +2140,12 @@ template <> size_t GenericFill<IfcRevolvedAreaSolid>(const DB& db, const LIST& p
 	size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRevolvedAreaSolid"); }    do { // convert the 'Axis' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRevolvedAreaSolid to be a `IfcAxis1Placement`")); }
     } while(0);
     do { // convert the 'Angle' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Angle, arg, db ); break; } 
+        try { GenericConvert( in->Angle, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRevolvedAreaSolid to be a `IfcPlaneAngleMeasure`")); }
     } while(0);
 	return base;
@@ -2170,28 +2170,28 @@ template <> size_t GenericFill<IfcSweptDiskSolid>(const DB& db, const LIST& para
 	size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcSweptDiskSolid"); }    do { // convert the 'Directrix' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Directrix, arg, db ); break; } 
+        try { GenericConvert( in->Directrix, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptDiskSolid to be a `IfcCurve`")); }
     } while(0);
     do { // convert the 'Radius' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'InnerRadius' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->InnerRadius, arg, db ); break; } 
+        try { GenericConvert( in->InnerRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'StartParam' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->StartParam, arg, db ); break; } 
+        try { GenericConvert( in->StartParam, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
     } while(0);
     do { // convert the 'EndParam' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->EndParam, arg, db ); break; } 
+        try { GenericConvert( in->EndParam, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
     } while(0);
 	return base;
@@ -2203,13 +2203,13 @@ template <> size_t GenericFill<IfcHalfSpaceSolid>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcHalfSpaceSolid"); }    do { // convert the 'BaseSurface' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcHalfSpaceSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->BaseSurface, arg, db ); break; } 
+        try { GenericConvert( in->BaseSurface, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcHalfSpaceSolid to be a `IfcSurface`")); }
     } while(0);
     do { // convert the 'AgreementFlag' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcHalfSpaceSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->AgreementFlag, arg, db ); break; } 
+        try { GenericConvert( in->AgreementFlag, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcHalfSpaceSolid to be a `BOOLEAN`")); }
     } while(0);
 	return base;
@@ -2220,12 +2220,12 @@ template <> size_t GenericFill<IfcPolygonalBoundedHalfSpace>(const DB& db, const
 	size_t base = GenericFill(db,params,static_cast<IfcHalfSpaceSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPolygonalBoundedHalfSpace"); }    do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPolygonalBoundedHalfSpace to be a `IfcAxis2Placement3D`")); }
     } while(0);
     do { // convert the 'PolygonalBoundary' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->PolygonalBoundary, arg, db ); break; } 
+        try { GenericConvert( in->PolygonalBoundary, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPolygonalBoundedHalfSpace to be a `IfcBoundedCurve`")); }
     } while(0);
 	return base;
@@ -2251,23 +2251,23 @@ template <> size_t GenericFill<IfcProject>(const DB& db, const LIST& params, Ifc
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcProject"); }    do { // convert the 'LongName' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LongName, arg, db ); break; } 
+        try { GenericConvert( in->LongName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcProject to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Phase' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Phase, arg, db ); break; } 
+        try { GenericConvert( in->Phase, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcProject to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'RepresentationContexts' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RepresentationContexts, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationContexts, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcProject to be a `SET [1:?] OF IfcRepresentationContext`")); }
     } while(0);
     do { // convert the 'UnitsInContext' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UnitsInContext, arg, db ); break; } 
+        try { GenericConvert( in->UnitsInContext, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcProject to be a `IfcUnitAssignment`")); }
     } while(0);
 	return base;
@@ -2327,27 +2327,27 @@ template <> size_t GenericFill<IfcTrimmedCurve>(const DB& db, const LIST& params
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcTrimmedCurve"); }    do { // convert the 'BasisCurve' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->BasisCurve, arg, db ); break; } 
+        try { GenericConvert( in->BasisCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcTrimmedCurve to be a `IfcCurve`")); }
     } while(0);
     do { // convert the 'Trim1' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Trim1, arg, db ); break; } 
+        try { GenericConvert( in->Trim1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
     } while(0);
     do { // convert the 'Trim2' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Trim2, arg, db ); break; } 
+        try { GenericConvert( in->Trim2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
     } while(0);
     do { // convert the 'SenseAgreement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SenseAgreement, arg, db ); break; } 
+        try { GenericConvert( in->SenseAgreement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcTrimmedCurve to be a `BOOLEAN`")); }
     } while(0);
     do { // convert the 'MasterRepresentation' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MasterRepresentation, arg, db ); break; } 
+        try { GenericConvert( in->MasterRepresentation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcTrimmedCurve to be a `IfcTrimmingPreference`")); }
     } while(0);
 	return base;
@@ -2359,7 +2359,7 @@ template <> size_t GenericFill<IfcRelDefines>(const DB& db, const LIST& params,
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcRelDefines"); }    do { // convert the 'RelatedObjects' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRelDefines,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->RelatedObjects, arg, db ); break; } 
+        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelDefines to be a `SET [1:?] OF IfcObject`")); }
     } while(0);
 	return base;
@@ -2371,7 +2371,7 @@ template <> size_t GenericFill<IfcRelDefinesByProperties>(const DB& db, const LI
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelDefinesByProperties"); }    do { // convert the 'RelatingPropertyDefinition' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRelDefinesByProperties,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->RelatingPropertyDefinition, arg, db ); break; } 
+        try { GenericConvert( in->RelatingPropertyDefinition, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelDefinesByProperties to be a `IfcPropertySetDefinition`")); }
     } while(0);
 	return base;
@@ -2404,7 +2404,7 @@ template <> size_t GenericFill<IfcArbitraryOpenProfileDef>(const DB& db, const L
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryOpenProfileDef"); }    do { // convert the 'Curve' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcArbitraryOpenProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Curve, arg, db ); break; } 
+        try { GenericConvert( in->Curve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryOpenProfileDef to be a `IfcBoundedCurve`")); }
     } while(0);
 	return base;
@@ -2570,13 +2570,13 @@ template <> size_t GenericFill<IfcRelDecomposes>(const DB& db, const LIST& param
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelDecomposes"); }    do { // convert the 'RelatingObject' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRelDecomposes,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->RelatingObject, arg, db ); break; } 
+        try { GenericConvert( in->RelatingObject, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelDecomposes to be a `IfcObjectDefinition`")); }
     } while(0);
     do { // convert the 'RelatedObjects' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRelDecomposes,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->RelatedObjects, arg, db ); break; } 
+        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelDecomposes to be a `SET [1:?] OF IfcObjectDefinition`")); }
     } while(0);
 	return base;
@@ -2594,7 +2594,7 @@ template <> size_t GenericFill<IfcPolyline>(const DB& db, const LIST& params, If
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyline"); }    do { // convert the 'Points' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Points, arg, db ); break; } 
+        try { GenericConvert( in->Points, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyline to be a `LIST [2:?] OF IfcCartesianPoint`")); }
     } while(0);
 	return base;
@@ -2626,12 +2626,12 @@ template <> size_t GenericFill<IfcMappedItem>(const DB& db, const LIST& params,
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMappedItem"); }    do { // convert the 'MappingSource' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingSource, arg, db ); break; } 
+        try { GenericConvert( in->MappingSource, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMappedItem to be a `IfcRepresentationMap`")); }
     } while(0);
     do { // convert the 'MappingTarget' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingTarget, arg, db ); break; } 
+        try { GenericConvert( in->MappingTarget, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMappedItem to be a `IfcCartesianTransformationOperator`")); }
     } while(0);
 	return base;
@@ -2658,13 +2658,13 @@ template <> size_t GenericFill<IfcNamedUnit>(const DB& db, const LIST& params, I
         std::shared_ptr<const DataType> arg = params[base++];
 		if (dynamic_cast<const UNSET*>(&*arg)) break;
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcNamedUnit,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Dimensions, arg, db ); break; } 
+        try { GenericConvert( in->Dimensions, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcNamedUnit to be a `IfcDimensionalExponents`")); }
     } while(0);
     do { // convert the 'UnitType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcNamedUnit,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->UnitType, arg, db ); break; } 
+        try { GenericConvert( in->UnitType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcNamedUnit to be a `IfcUnitEnum`")); }
     } while(0);
 	return base;
@@ -2719,13 +2719,13 @@ template <> size_t GenericFill<IfcSpatialStructureElement>(const DB& db, const L
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSpatialStructureElement,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LongName, arg, db ); break; } 
+        try { GenericConvert( in->LongName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSpatialStructureElement to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'CompositionType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSpatialStructureElement,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->CompositionType, arg, db ); break; } 
+        try { GenericConvert( in->CompositionType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSpatialStructureElement to be a `IfcElementCompositionEnum`")); }
     } while(0);
 	return base;
@@ -2737,19 +2737,19 @@ template <> size_t GenericFill<IfcBuilding>(const DB& db, const LIST& params, If
 	if (params.GetSize() < 12) { throw STEP::TypeError("expected 12 arguments to IfcBuilding"); }    do { // convert the 'ElevationOfRefHeight' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationOfRefHeight, arg, db ); break; } 
+        try { GenericConvert( in->ElevationOfRefHeight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcBuilding to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'ElevationOfTerrain' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationOfTerrain, arg, db ); break; } 
+        try { GenericConvert( in->ElevationOfTerrain, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcBuilding to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'BuildingAddress' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->BuildingAddress, arg, db ); break; } 
+        try { GenericConvert( in->BuildingAddress, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcBuilding to be a `IfcPostalAddress`")); }
     } while(0);
 	return base;
@@ -2761,7 +2761,7 @@ template <> size_t GenericFill<IfcConnectedFaceSet>(const DB& db, const LIST& pa
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConnectedFaceSet"); }    do { // convert the 'CfsFaces' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcConnectedFaceSet,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->CfsFaces, arg, db ); break; } 
+        try { GenericConvert( in->CfsFaces, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConnectedFaceSet to be a `SET [1:?] OF IfcFace`")); }
     } while(0);
 	return base;
@@ -2787,7 +2787,7 @@ template <> size_t GenericFill<IfcConic>(const DB& db, const LIST& params, IfcCo
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConic"); }    do { // convert the 'Position' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcConic,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConic to be a `IfcAxis2Placement`")); }
     } while(0);
 	return base;
@@ -2834,32 +2834,32 @@ template <> size_t GenericFill<IfcIShapeProfileDef>(const DB& db, const LIST& pa
 	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcIShapeProfileDef"); }    do { // convert the 'OverallWidth' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->OverallWidth, arg, db ); break; } 
+        try { GenericConvert( in->OverallWidth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'OverallDepth' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->OverallDepth, arg, db ); break; } 
+        try { GenericConvert( in->OverallDepth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'WebThickness' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->WebThickness, arg, db ); break; } 
+        try { GenericConvert( in->WebThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'FlangeThickness' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->FlangeThickness, arg, db ); break; } 
+        try { GenericConvert( in->FlangeThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'FilletRadius' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcIShapeProfileDef,5>::aux_is_derived[4]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->FilletRadius, arg, db ); break; } 
+        try { GenericConvert( in->FilletRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -2933,13 +2933,13 @@ template <> size_t GenericFill<IfcPropertyListValue>(const DB& db, const LIST& p
 	size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertyListValue"); }    do { // convert the 'ListValues' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ListValues, arg, db ); break; } 
+        try { GenericConvert( in->ListValues, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertyListValue to be a `LIST [1:?] OF IfcValue`")); }
     } while(0);
     do { // convert the 'Unit' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Unit, arg, db ); break; } 
+        try { GenericConvert( in->Unit, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertyListValue to be a `IfcUnit`")); }
     } while(0);
 	return base;
@@ -2965,13 +2965,13 @@ template <> size_t GenericFill<IfcDoor>(const DB& db, const LIST& params, IfcDoo
 	if (params.GetSize() < 10) { throw STEP::TypeError("expected 10 arguments to IfcDoor"); }    do { // convert the 'OverallHeight' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OverallHeight, arg, db ); break; } 
+        try { GenericConvert( in->OverallHeight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'OverallWidth' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OverallWidth, arg, db ); break; } 
+        try { GenericConvert( in->OverallWidth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -2984,20 +2984,20 @@ template <> size_t GenericFill<IfcStyledItem>(const DB& db, const LIST& params,
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcStyledItem,3>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Item, arg, db ); break; } 
+        try { GenericConvert( in->Item, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcStyledItem to be a `IfcRepresentationItem`")); }
     } while(0);
     do { // convert the 'Styles' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcStyledItem,3>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcStyledItem to be a `SET [1:?] OF IfcPresentationStyleAssignment`")); }
     } while(0);
     do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcStyledItem,3>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcStyledItem to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -3023,7 +3023,7 @@ template <> size_t GenericFill<IfcArbitraryClosedProfileDef>(const DB& db, const
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryClosedProfileDef"); }    do { // convert the 'OuterCurve' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcArbitraryClosedProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->OuterCurve, arg, db ); break; } 
+        try { GenericConvert( in->OuterCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryClosedProfileDef to be a `IfcCurve`")); }
     } while(0);
 	return base;
@@ -3041,12 +3041,12 @@ template <> size_t GenericFill<IfcLine>(const DB& db, const LIST& params, IfcLin
 	size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLine"); }    do { // convert the 'Pnt' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Pnt, arg, db ); break; } 
+        try { GenericConvert( in->Pnt, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLine to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'Dir' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Dir, arg, db ); break; } 
+        try { GenericConvert( in->Dir, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLine to be a `IfcVector`")); }
     } while(0);
 	return base;
@@ -3072,13 +3072,13 @@ template <> size_t GenericFill<IfcPropertySingleValue>(const DB& db, const LIST&
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertySingleValue"); }    do { // convert the 'NominalValue' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->NominalValue, arg, db ); break; } 
+        try { GenericConvert( in->NominalValue, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertySingleValue to be a `IfcValue`")); }
     } while(0);
     do { // convert the 'Unit' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Unit, arg, db ); break; } 
+        try { GenericConvert( in->Unit, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertySingleValue to be a `IfcUnit`")); }
     } while(0);
 	return base;
@@ -3111,7 +3111,7 @@ template <> size_t GenericFill<IfcSurfaceStyleShading>(const DB& db, const LIST&
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcSurfaceStyleShading"); }    do { // convert the 'SurfaceColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcSurfaceStyleShading,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->SurfaceColour, arg, db ); break; } 
+        try { GenericConvert( in->SurfaceColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleShading to be a `IfcColourRgb`")); }
     } while(0);
 	return base;
diff --git a/code/AssetLib/IFC/IFCReaderGen2_2x3.cpp b/code/AssetLib/IFC/IFCReaderGen2_2x3.cpp
index c58c7c42ff..0d7051195e 100644
--- a/code/AssetLib/IFC/IFCReaderGen2_2x3.cpp
+++ b/code/AssetLib/IFC/IFCReaderGen2_2x3.cpp
@@ -5,8 +5,8 @@ Open Asset Import Library (ASSIMP)
 Copyright (c) 2006-2020, ASSIMP Development Team
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the
 following conditions are met:
 
 * Redistributions of source code must retain the above
@@ -23,16 +23,16 @@ following conditions are met:
   derived from this software without specific prior
   written permission of the ASSIMP Development Team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
@@ -59,12 +59,12 @@ template <> size_t GenericFill<IfcSurfaceStyle>(const DB& db, const LIST& params
 	size_t base = GenericFill(db,params,static_cast<IfcPresentationStyle*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcSurfaceStyle"); }    do { // convert the 'Side' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Side, arg, db ); break; } 
+        try { GenericConvert( in->Side, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyle to be a `IfcSurfaceSide`")); }
     } while(0);
     do { // convert the 'Styles' argument
         std::shared_ptr<const DataType> arg = params[ base++ ];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyle to be a `SET [1:5] OF IfcSurfaceStyleElementSelect`")); }
     } while(0);
 	return base;
@@ -118,7 +118,7 @@ template <> size_t GenericFill<IfcFace>(const DB& db, const LIST& params, IfcFac
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFace"); }    do { // convert the 'Bounds' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcFace,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Bounds, arg, db ); break; } 
+        try { GenericConvert( in->Bounds, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFace to be a `SET [1:?] OF IfcFaceBound`")); }
     } while(0);
 	return base;
@@ -173,7 +173,7 @@ template <> size_t GenericFill<IfcColourSpecification>(const DB& db, const LIST&
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcColourSpecification,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcColourSpecification to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -184,12 +184,12 @@ template <> size_t GenericFill<IfcVector>(const DB& db, const LIST& params, IfcV
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcVector"); }    do { // convert the 'Orientation' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Orientation, arg, db ); break; } 
+        try { GenericConvert( in->Orientation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcVector to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Magnitude' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Magnitude, arg, db ); break; } 
+        try { GenericConvert( in->Magnitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcVector to be a `IfcLengthMeasure`")); }
     } while(0);
 	return base;
@@ -207,17 +207,17 @@ template <> size_t GenericFill<IfcColourRgb>(const DB& db, const LIST& params, I
 	size_t base = GenericFill(db,params,static_cast<IfcColourSpecification*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcColourRgb"); }    do { // convert the 'Red' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Red, arg, db ); break; } 
+        try { GenericConvert( in->Red, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'Green' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Green, arg, db ); break; } 
+        try { GenericConvert( in->Green, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'Blue' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Blue, arg, db ); break; } 
+        try { GenericConvert( in->Blue, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
 	return base;
@@ -243,31 +243,31 @@ template <> size_t GenericFill<IfcSite>(const DB& db, const LIST& params, IfcSit
 	if (params.GetSize() < 14) { throw STEP::TypeError("expected 14 arguments to IfcSite"); }    do { // convert the 'RefLatitude' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefLatitude, arg, db ); break; } 
+        try { GenericConvert( in->RefLatitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
     } while(0);
     do { // convert the 'RefLongitude' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefLongitude, arg, db ); break; } 
+        try { GenericConvert( in->RefLongitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
     } while(0);
     do { // convert the 'RefElevation' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefElevation, arg, db ); break; } 
+        try { GenericConvert( in->RefElevation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcSite to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'LandTitleNumber' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LandTitleNumber, arg, db ); break; } 
+        try { GenericConvert( in->LandTitleNumber, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 12 to IfcSite to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'SiteAddress' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SiteAddress, arg, db ); break; } 
+        try { GenericConvert( in->SiteAddress, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 13 to IfcSite to be a `IfcPostalAddress`")); }
     } while(0);
 	return base;
@@ -412,31 +412,31 @@ template <> size_t GenericFill<IfcBSplineCurve>(const DB& db, const LIST& params
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcBSplineCurve"); }    do { // convert the 'Degree' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Degree, arg, db ); break; } 
+        try { GenericConvert( in->Degree, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBSplineCurve to be a `INTEGER`")); }
     } while(0);
     do { // convert the 'ControlPointsList' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->ControlPointsList, arg, db ); break; } 
+        try { GenericConvert( in->ControlPointsList, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBSplineCurve to be a `LIST [2:?] OF IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'CurveForm' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->CurveForm, arg, db ); break; } 
+        try { GenericConvert( in->CurveForm, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBSplineCurve to be a `IfcBSplineCurveForm`")); }
     } while(0);
     do { // convert the 'ClosedCurve' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->ClosedCurve, arg, db ); break; } 
+        try { GenericConvert( in->ClosedCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBSplineCurve to be a `LOGICAL`")); }
     } while(0);
     do { // convert the 'SelfIntersect' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcBSplineCurve,5>::aux_is_derived[4]=true; break; }
-        try { GenericConvert( in->SelfIntersect, arg, db ); break; } 
+        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcBSplineCurve to be a `LOGICAL`")); }
     } while(0);
 	return base;
@@ -474,7 +474,7 @@ template <> size_t GenericFill<IfcShellBasedSurfaceModel>(const DB& db, const LI
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcShellBasedSurfaceModel"); }    do { // convert the 'SbsmBoundary' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SbsmBoundary, arg, db ); break; } 
+        try { GenericConvert( in->SbsmBoundary, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcShellBasedSurfaceModel to be a `SET [1:?] OF IfcShell`")); }
     } while(0);
 	return base;
@@ -492,12 +492,12 @@ template <> size_t GenericFill<IfcExtrudedAreaSolid>(const DB& db, const LIST& p
 	size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcExtrudedAreaSolid"); }    do { // convert the 'ExtrudedDirection' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; } 
+        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcExtrudedAreaSolid to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Depth' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Depth, arg, db ); break; } 
+        try { GenericConvert( in->Depth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcExtrudedAreaSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -522,12 +522,12 @@ template <> size_t GenericFill<IfcRelVoidsElement>(const DB& db, const LIST& par
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelVoidsElement"); }    do { // convert the 'RelatingBuildingElement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingBuildingElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatingBuildingElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelVoidsElement to be a `IfcElement`")); }
     } while(0);
     do { // convert the 'RelatedOpeningElement' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedOpeningElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatedOpeningElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelVoidsElement to be a `IfcFeatureElementSubtraction`")); }
     } while(0);
 	return base;
@@ -546,13 +546,13 @@ template <> size_t GenericFill<IfcCartesianTransformationOperator3DnonUniform>(c
 	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcCartesianTransformationOperator3DnonUniform"); }    do { // convert the 'Scale2' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale2, arg, db ); break; } 
+        try { GenericConvert( in->Scale2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcCartesianTransformationOperator3DnonUniform to be a `REAL`")); }
     } while(0);
     do { // convert the 'Scale3' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale3, arg, db ); break; } 
+        try { GenericConvert( in->Scale3, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcCartesianTransformationOperator3DnonUniform to be a `REAL`")); }
     } while(0);
 	return base;
@@ -634,7 +634,7 @@ template <> size_t GenericFill<IfcAxis2Placement2D>(const DB& db, const LIST& pa
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis2Placement2D"); }    do { // convert the 'RefDirection' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefDirection, arg, db ); break; } 
+        try { GenericConvert( in->RefDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement2D to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -658,7 +658,7 @@ template <> size_t GenericFill<IfcCartesianPoint>(const DB& db, const LIST& para
 	size_t base = GenericFill(db,params,static_cast<IfcPoint*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcCartesianPoint"); }    do { // convert the 'Coordinates' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Coordinates, arg, db ); break; } 
+        try { GenericConvert( in->Coordinates, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianPoint to be a `LIST [1:3] OF IfcLengthMeasure`")); }
     } while(0);
 	return base;
@@ -682,7 +682,7 @@ template <> size_t GenericFill<IfcPolyLoop>(const DB& db, const LIST& params, If
 	size_t base = GenericFill(db,params,static_cast<IfcLoop*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyLoop"); }    do { // convert the 'Polygon' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Polygon, arg, db ); break; } 
+        try { GenericConvert( in->Polygon, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyLoop to be a `LIST [3:?] OF IfcCartesianPoint`")); }
     } while(0);
 	return base;
@@ -716,14 +716,14 @@ template <> size_t GenericFill<IfcRepresentationContext>(const DB& db, const LIS
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentationContext,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ContextIdentifier, arg, db ); break; } 
+        try { GenericConvert( in->ContextIdentifier, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'ContextType' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcRepresentationContext,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ContextType, arg, db ); break; } 
+        try { GenericConvert( in->ContextType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationContext to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -735,27 +735,27 @@ template <> size_t GenericFill<IfcGeometricRepresentationContext>(const DB& db,
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcGeometricRepresentationContext"); }    do { // convert the 'CoordinateSpaceDimension' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcGeometricRepresentationContext,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; } 
+        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcGeometricRepresentationContext to be a `IfcDimensionCount`")); }
     } while(0);
     do { // convert the 'Precision' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcGeometricRepresentationContext,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Precision, arg, db ); break; } 
+        try { GenericConvert( in->Precision, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcGeometricRepresentationContext to be a `REAL`")); }
     } while(0);
     do { // convert the 'WorldCoordinateSystem' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcGeometricRepresentationContext,4>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->WorldCoordinateSystem, arg, db ); break; } 
+        try { GenericConvert( in->WorldCoordinateSystem, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcGeometricRepresentationContext to be a `IfcAxis2Placement`")); }
     } while(0);
     do { // convert the 'TrueNorth' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcGeometricRepresentationContext,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->TrueNorth, arg, db ); break; } 
+        try { GenericConvert( in->TrueNorth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcGeometricRepresentationContext to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -774,12 +774,12 @@ template <> size_t GenericFill<IfcSIUnit>(const DB& db, const LIST& params, IfcS
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcSIUnit"); }    do { // convert the 'Prefix' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Prefix, arg, db ); break; } 
+        try { GenericConvert( in->Prefix, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSIUnit to be a `IfcSIPrefix`")); }
     } while(0);
     do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSIUnit to be a `IfcSIUnitName`")); }
     } while(0);
 	return base;
@@ -805,7 +805,7 @@ template <> size_t GenericFill<IfcAxis1Placement>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis1Placement"); }    do { // convert the 'Axis' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis1Placement to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -858,12 +858,12 @@ template <> size_t GenericFill<IfcRepresentationMap>(const DB& db, const LIST& p
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcRepresentationMap"); }    do { // convert the 'MappingOrigin' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingOrigin, arg, db ); break; } 
+        try { GenericConvert( in->MappingOrigin, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationMap to be a `IfcAxis2Placement`")); }
     } while(0);
     do { // convert the 'MappedRepresentation' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappedRepresentation, arg, db ); break; } 
+        try { GenericConvert( in->MappedRepresentation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationMap to be a `IfcRepresentation`")); }
     } while(0);
 	return base;
@@ -1012,12 +1012,12 @@ template <> size_t GenericFill<IfcMeasureWithUnit>(const DB& db, const LIST& par
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMeasureWithUnit"); }    do { // convert the 'ValueComponent' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ValueComponent, arg, db ); break; } 
+        try { GenericConvert( in->ValueComponent, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMeasureWithUnit to be a `IfcValue`")); }
     } while(0);
     do { // convert the 'UnitComponent' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UnitComponent, arg, db ); break; } 
+        try { GenericConvert( in->UnitComponent, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMeasureWithUnit to be a `IfcUnit`")); }
     } while(0);
 	return base;
@@ -1125,7 +1125,7 @@ template <> size_t GenericFill<IfcFaceBasedSurfaceModel>(const DB& db, const LIS
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFaceBasedSurfaceModel"); }    do { // convert the 'FbsmFaces' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->FbsmFaces, arg, db ); break; } 
+        try { GenericConvert( in->FbsmFaces, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBasedSurfaceModel to be a `SET [1:?] OF IfcConnectedFaceSet`")); }
     } while(0);
 	return base;
@@ -1172,13 +1172,13 @@ template <> size_t GenericFill<IfcFaceBound>(const DB& db, const LIST& params, I
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcFaceBound"); }    do { // convert the 'Bound' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcFaceBound,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Bound, arg, db ); break; } 
+        try { GenericConvert( in->Bound, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBound to be a `IfcLoop`")); }
     } while(0);
     do { // convert the 'Orientation' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::Schema_2x3::IfcFaceBound,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Orientation, arg, db ); break; } 
+        try { GenericConvert( in->Orientation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcFaceBound to be a `BOOLEAN`")); }
     } while(0);
 	return base;
@@ -1216,12 +1216,12 @@ template <> size_t GenericFill<IfcComplexProperty>(const DB& db, const LIST& par
 	size_t base = GenericFill(db,params,static_cast<IfcProperty*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcComplexProperty"); }    do { // convert the 'UsageName' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UsageName, arg, db ); break; } 
+        try { GenericConvert( in->UsageName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcComplexProperty to be a `IfcIdentifier`")); }
     } while(0);
     do { // convert the 'HasProperties' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->HasProperties, arg, db ); break; } 
+        try { GenericConvert( in->HasProperties, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcComplexProperty to be a `SET [1:?] OF IfcProperty`")); }
     } while(0);
 	return base;
@@ -1274,7 +1274,7 @@ template <> size_t GenericFill<IfcUnitAssignment>(const DB& db, const LIST& para
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcUnitAssignment"); }    do { // convert the 'Units' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Units, arg, db ); break; } 
+        try { GenericConvert( in->Units, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcUnitAssignment to be a `SET [1:?] OF IfcUnit`")); }
     } while(0);
 	return base;
@@ -1307,12 +1307,12 @@ template <> size_t GenericFill<IfcElementQuantity>(const DB& db, const LIST& par
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcElementQuantity"); }    do { // convert the 'MethodOfMeasurement' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->MethodOfMeasurement, arg, db ); break; } 
+        try { GenericConvert( in->MethodOfMeasurement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcElementQuantity to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Quantities' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Quantities, arg, db ); break; } 
+        try { GenericConvert( in->Quantities, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcElementQuantity to be a `SET [1:?] OF IfcPhysicalQuantity`")); }
     } while(0);
 	return base;
@@ -1379,7 +1379,7 @@ template <> size_t GenericFill<IfcPresentationStyleAssignment>(const DB& db, con
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPresentationStyleAssignment"); }    do { // convert the 'Styles' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyleAssignment to be a `SET [1:?] OF IfcPresentationStyleSelect`")); }
     } while(0);
 	return base;
@@ -1418,13 +1418,13 @@ template <> size_t GenericFill<IfcSpace>(const DB& db, const LIST& params, IfcSp
 	size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
 	if (params.GetSize() < 11) { throw STEP::TypeError("expected 11 arguments to IfcSpace"); }    do { // convert the 'InteriorOrExteriorSpace' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->InteriorOrExteriorSpace, arg, db ); break; } 
+        try { GenericConvert( in->InteriorOrExteriorSpace, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSpace to be a `IfcInternalOrExternalEnum`")); }
     } while(0);
     do { // convert the 'ElevationWithFlooring' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationWithFlooring, arg, db ); break; } 
+        try { GenericConvert( in->ElevationWithFlooring, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSpace to be a `IfcLengthMeasure`")); }
     } while(0);
 	return base;
@@ -1484,7 +1484,7 @@ template <> size_t GenericFill<IfcSurfaceStyleWithTextures>(const DB& db, const
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcSurfaceStyleWithTextures"); }    do { // convert the 'Textures' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Textures, arg, db ); break; } 
+        try { GenericConvert( in->Textures, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleWithTextures to be a `LIST [1:?] OF IfcSurfaceTexture`")); }
     } while(0);
 	return base;
@@ -1495,22 +1495,22 @@ template <> size_t GenericFill<IfcBoundingBox>(const DB& db, const LIST& params,
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcBoundingBox"); }    do { // convert the 'Corner' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Corner, arg, db ); break; } 
+        try { GenericConvert( in->Corner, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBoundingBox to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'XDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->XDim, arg, db ); break; } 
+        try { GenericConvert( in->XDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'YDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->YDim, arg, db ); break; } 
+        try { GenericConvert( in->YDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'ZDim' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ZDim, arg, db ); break; } 
+        try { GenericConvert( in->ZDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -1535,7 +1535,7 @@ template <> size_t GenericFill<IfcCircle>(const DB& db, const LIST& params, IfcC
 	size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCircle"); }    do { // convert the 'Radius' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCircle to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -1623,12 +1623,12 @@ template <> size_t GenericFill<IfcConversionBasedUnit>(const DB& db, const LIST&
 	size_t base = GenericFill(db,params,static_cast<IfcNamedUnit*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcConversionBasedUnit"); }    do { // convert the 'Name' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcConversionBasedUnit to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'ConversionFactor' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ConversionFactor, arg, db ); break; } 
+        try { GenericConvert( in->ConversionFactor, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcConversionBasedUnit to be a `IfcMeasureWithUnit`")); }
     } while(0);
 	return base;
@@ -1744,12 +1744,12 @@ template <> size_t GenericFill<IfcEllipse>(const DB& db, const LIST& params, Ifc
 	size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcEllipse"); }    do { // convert the 'SemiAxis1' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SemiAxis1, arg, db ); break; } 
+        try { GenericConvert( in->SemiAxis1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'SemiAxis2' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SemiAxis2, arg, db ); break; } 
+        try { GenericConvert( in->SemiAxis2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -1816,7 +1816,7 @@ template <> size_t GenericFill<IfcPropertySet>(const DB& db, const LIST& params,
 	size_t base = GenericFill(db,params,static_cast<IfcPropertySetDefinition*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcPropertySet"); }    do { // convert the 'HasProperties' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->HasProperties, arg, db ); break; } 
+        try { GenericConvert( in->HasProperties, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcPropertySet to be a `SET [1:?] OF IfcProperty`")); }
     } while(0);
 	return base;
@@ -1828,48 +1828,48 @@ template <> size_t GenericFill<IfcSurfaceStyleRendering>(const DB& db, const LIS
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcSurfaceStyleRendering"); }    do { // convert the 'Transparency' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Transparency, arg, db ); break; } 
+        try { GenericConvert( in->Transparency, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyleRendering to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'DiffuseColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->DiffuseColour, arg, db ); break; } 
+        try { GenericConvert( in->DiffuseColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'TransmissionColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->TransmissionColour, arg, db ); break; } 
+        try { GenericConvert( in->TransmissionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'DiffuseTransmissionColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->DiffuseTransmissionColour, arg, db ); break; } 
+        try { GenericConvert( in->DiffuseTransmissionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'ReflectionColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ReflectionColour, arg, db ); break; } 
+        try { GenericConvert( in->ReflectionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'SpecularColour' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SpecularColour, arg, db ); break; } 
+        try { GenericConvert( in->SpecularColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'SpecularHighlight' argument
         std::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SpecularHighlight, arg, db ); break; } 
+        try { GenericConvert( in->SpecularHighlight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSurfaceStyleRendering to be a `IfcSpecularHighlightSelect`")); }
     } while(0);
     do { // convert the 'ReflectanceMethod' argument
         std::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ReflectanceMethod, arg, db ); break; } 
+        try { GenericConvert( in->ReflectanceMethod, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSurfaceStyleRendering to be a `IfcReflectanceMethodEnum`")); }
     } while(0);
 	return base;
diff --git a/code/AssetLib/IFC/IFCReaderGen_4.cpp b/code/AssetLib/IFC/IFCReaderGen_4.cpp
index 9eb3e24463..1793229026 100644
--- a/code/AssetLib/IFC/IFCReaderGen_4.cpp
+++ b/code/AssetLib/IFC/IFCReaderGen_4.cpp
@@ -5,8 +5,8 @@ Open Asset Import Library (ASSIMP)
 Copyright (c) 2006-2020, ASSIMP Development Team
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the
 following conditions are met:
 
 * Redistributions of source code must retain the above
@@ -23,16 +23,16 @@ following conditions are met:
   derived from this software without specific prior
   written permission of the ASSIMP Development Team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
@@ -1254,28 +1254,28 @@ template <> size_t GenericFill<IfcRoot>(const DB& db, const LIST& params, IfcRoo
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRoot"); }    do { // convert the 'GlobalId' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->GlobalId, arg, db ); break; } 
+        try { GenericConvert( in->GlobalId, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRoot to be a `IfcGloballyUniqueId`")); }
     } while(0);
     do { // convert the 'OwnerHistory' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OwnerHistory, arg, db ); break; } 
+        try { GenericConvert( in->OwnerHistory, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRoot to be a `IfcOwnerHistory`")); }
     } while(0);
     do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRoot to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Description' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRoot to be a `IfcText`")); }
     } while(0);
 	return base;
@@ -1294,7 +1294,7 @@ template <> size_t GenericFill<IfcObject>(const DB& db, const LIST& params, IfcO
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcObject,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectType, arg, db ); break; } 
+        try { GenericConvert( in->ObjectType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcObject to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -1328,14 +1328,14 @@ template <> size_t GenericFill<IfcProduct>(const DB& db, const LIST& params, Ifc
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProduct,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectPlacement, arg, db ); break; } 
+        try { GenericConvert( in->ObjectPlacement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcProduct to be a `IfcObjectPlacement`")); }
     } while(0);
     do { // convert the 'Representation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProduct,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Representation, arg, db ); break; } 
+        try { GenericConvert( in->Representation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcProduct to be a `IfcProductRepresentation`")); }
     } while(0);
 	return base;
@@ -1348,7 +1348,7 @@ template <> size_t GenericFill<IfcElement>(const DB& db, const LIST& params, Ifc
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Tag, arg, db ); break; } 
+        try { GenericConvert( in->Tag, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcElement to be a `IfcIdentifier`")); }
     } while(0);
 	return base;
@@ -1441,7 +1441,7 @@ template <> size_t GenericFill<IfcManifoldSolidBrep>(const DB& db, const LIST& p
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcManifoldSolidBrep"); }    do { // convert the 'Outer' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcManifoldSolidBrep,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Outer, arg, db ); break; } 
+        try { GenericConvert( in->Outer, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcManifoldSolidBrep to be a `IfcClosedShell`")); }
     } while(0);
 	return base;
@@ -1473,7 +1473,7 @@ template <> size_t GenericFill<IfcFace>(const DB& db, const LIST& params, IfcFac
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFace"); }    do { // convert the 'Bounds' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcFace,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Bounds, arg, db ); break; } 
+        try { GenericConvert( in->Bounds, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFace to be a `SET [1:?] OF IfcFaceBound`")); }
     } while(0);
 	return base;
@@ -1624,14 +1624,14 @@ template <> size_t GenericFill<IfcProfileDef>(const DB& db, const LIST& params,
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProfileDef"); }    do { // convert the 'ProfileType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProfileDef,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ProfileType, arg, db ); break; } 
+        try { GenericConvert( in->ProfileType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProfileDef to be a `IfcProfileTypeEnum`")); }
     } while(0);
     do { // convert the 'ProfileName' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProfileDef,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ProfileName, arg, db ); break; } 
+        try { GenericConvert( in->ProfileName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProfileDef to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -1643,7 +1643,7 @@ template <> size_t GenericFill<IfcArbitraryClosedProfileDef>(const DB& db, const
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryClosedProfileDef"); }    do { // convert the 'OuterCurve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcArbitraryClosedProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->OuterCurve, arg, db ); break; } 
+        try { GenericConvert( in->OuterCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryClosedProfileDef to be a `IfcCurve`")); }
     } while(0);
 	return base;
@@ -1655,7 +1655,7 @@ template <> size_t GenericFill<IfcArbitraryOpenProfileDef>(const DB& db, const L
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryOpenProfileDef"); }    do { // convert the 'Curve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcArbitraryOpenProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Curve, arg, db ); break; } 
+        try { GenericConvert( in->Curve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryOpenProfileDef to be a `IfcBoundedCurve`")); }
     } while(0);
 	return base;
@@ -1666,7 +1666,7 @@ template <> size_t GenericFill<IfcArbitraryProfileDefWithVoids>(const DB& db, co
 	size_t base = GenericFill(db,params,static_cast<IfcArbitraryClosedProfileDef*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcArbitraryProfileDefWithVoids"); }    do { // convert the 'InnerCurves' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->InnerCurves, arg, db ); break; } 
+        try { GenericConvert( in->InnerCurves, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcArbitraryProfileDefWithVoids to be a `SET [1:?] OF IfcCurve`")); }
     } while(0);
 	return base;
@@ -1693,7 +1693,7 @@ template <> size_t GenericFill<IfcParameterizedProfileDef>(const DB& db, const L
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcParameterizedProfileDef,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcParameterizedProfileDef to be a `IfcAxis2Placement2D`")); }
     } while(0);
 	return base;
@@ -1726,7 +1726,7 @@ template <> size_t GenericFill<IfcPlacement>(const DB& db, const LIST& params, I
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPlacement"); }    do { // convert the 'Location' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcPlacement,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Location, arg, db ); break; } 
+        try { GenericConvert( in->Location, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPlacement to be a `IfcCartesianPoint`")); }
     } while(0);
 	return base;
@@ -1738,7 +1738,7 @@ template <> size_t GenericFill<IfcAxis1Placement>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis1Placement"); }    do { // convert the 'Axis' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis1Placement to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -1750,7 +1750,7 @@ template <> size_t GenericFill<IfcAxis2Placement2D>(const DB& db, const LIST& pa
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis2Placement2D"); }    do { // convert the 'RefDirection' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefDirection, arg, db ); break; } 
+        try { GenericConvert( in->RefDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement2D to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -1762,13 +1762,13 @@ template <> size_t GenericFill<IfcAxis2Placement3D>(const DB& db, const LIST& pa
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcAxis2Placement3D"); }    do { // convert the 'Axis' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement3D to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'RefDirection' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefDirection, arg, db ); break; } 
+        try { GenericConvert( in->RefDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcAxis2Placement3D to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -1792,31 +1792,31 @@ template <> size_t GenericFill<IfcBSplineCurve>(const DB& db, const LIST& params
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcBSplineCurve"); }    do { // convert the 'Degree' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Degree, arg, db ); break; } 
+        try { GenericConvert( in->Degree, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBSplineCurve to be a `IfcInteger`")); }
     } while(0);
     do { // convert the 'ControlPointsList' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->ControlPointsList, arg, db ); break; } 
+        try { GenericConvert( in->ControlPointsList, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBSplineCurve to be a `LIST [2:?] OF IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'CurveForm' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->CurveForm, arg, db ); break; } 
+        try { GenericConvert( in->CurveForm, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBSplineCurve to be a `IfcBSplineCurveForm`")); }
     } while(0);
     do { // convert the 'ClosedCurve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->ClosedCurve, arg, db ); break; } 
+        try { GenericConvert( in->ClosedCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBSplineCurve to be a `IfcLogical`")); }
     } while(0);
     do { // convert the 'SelfIntersect' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[4]=true; break; }
-        try { GenericConvert( in->SelfIntersect, arg, db ); break; } 
+        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcBSplineCurve to be a `IfcLogical`")); }
     } while(0);
 	return base;
@@ -1930,19 +1930,19 @@ template <> size_t GenericFill<IfcBooleanResult>(const DB& db, const LIST& param
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcBooleanResult"); }    do { // convert the 'Operator' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBooleanResult,3>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Operator, arg, db ); break; } 
+        try { GenericConvert( in->Operator, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBooleanResult to be a `IfcBooleanOperator`")); }
     } while(0);
     do { // convert the 'FirstOperand' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBooleanResult,3>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->FirstOperand, arg, db ); break; } 
+        try { GenericConvert( in->FirstOperand, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
     } while(0);
     do { // convert the 'SecondOperand' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBooleanResult,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->SecondOperand, arg, db ); break; } 
+        try { GenericConvert( in->SecondOperand, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
     } while(0);
 	return base;
@@ -1960,13 +1960,13 @@ template <> size_t GenericFill<IfcCompositeCurve>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCompositeCurve"); }    do { // convert the 'Segments' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurve,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Segments, arg, db ); break; } 
+        try { GenericConvert( in->Segments, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurve to be a `LIST [1:?] OF IfcCompositeCurveSegment`")); }
     } while(0);
     do { // convert the 'SelfIntersect' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurve,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->SelfIntersect, arg, db ); break; } 
+        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurve to be a `IfcLogical`")); }
     } while(0);
 	return base;
@@ -1991,22 +1991,22 @@ template <> size_t GenericFill<IfcBoundingBox>(const DB& db, const LIST& params,
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcBoundingBox"); }    do { // convert the 'Corner' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Corner, arg, db ); break; } 
+        try { GenericConvert( in->Corner, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBoundingBox to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'XDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->XDim, arg, db ); break; } 
+        try { GenericConvert( in->XDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'YDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->YDim, arg, db ); break; } 
+        try { GenericConvert( in->YDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'ZDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ZDim, arg, db ); break; } 
+        try { GenericConvert( in->ZDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -2018,13 +2018,13 @@ template <> size_t GenericFill<IfcHalfSpaceSolid>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcHalfSpaceSolid"); }    do { // convert the 'BaseSurface' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcHalfSpaceSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->BaseSurface, arg, db ); break; } 
+        try { GenericConvert( in->BaseSurface, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcHalfSpaceSolid to be a `IfcSurface`")); }
     } while(0);
     do { // convert the 'AgreementFlag' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcHalfSpaceSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->AgreementFlag, arg, db ); break; } 
+        try { GenericConvert( in->AgreementFlag, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcHalfSpaceSolid to be a `IfcBoolean`")); }
     } while(0);
 	return base;
@@ -2044,7 +2044,7 @@ template <> size_t GenericFill<IfcSpatialElement>(const DB& db, const LIST& para
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSpatialElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LongName, arg, db ); break; } 
+        try { GenericConvert( in->LongName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSpatialElement to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -2057,7 +2057,7 @@ template <> size_t GenericFill<IfcSpatialStructureElement>(const DB& db, const L
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSpatialStructureElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->CompositionType, arg, db ); break; } 
+        try { GenericConvert( in->CompositionType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSpatialStructureElement to be a `IfcElementCompositionEnum`")); }
     } while(0);
 	return base;
@@ -2069,19 +2069,19 @@ template <> size_t GenericFill<IfcBuilding>(const DB& db, const LIST& params, If
 	if (params.GetSize() < 12) { throw STEP::TypeError("expected 12 arguments to IfcBuilding"); }    do { // convert the 'ElevationOfRefHeight' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationOfRefHeight, arg, db ); break; } 
+        try { GenericConvert( in->ElevationOfRefHeight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcBuilding to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'ElevationOfTerrain' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationOfTerrain, arg, db ); break; } 
+        try { GenericConvert( in->ElevationOfTerrain, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcBuilding to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'BuildingAddress' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->BuildingAddress, arg, db ); break; } 
+        try { GenericConvert( in->BuildingAddress, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcBuilding to be a `IfcPostalAddress`")); }
     } while(0);
 	return base;
@@ -2266,7 +2266,7 @@ template <> size_t GenericFill<IfcCartesianPoint>(const DB& db, const LIST& para
 	size_t base = GenericFill(db,params,static_cast<IfcPoint*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcCartesianPoint"); }    do { // convert the 'Coordinates' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Coordinates, arg, db ); break; } 
+        try { GenericConvert( in->Coordinates, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianPoint to be a `LIST [1:3] OF IfcLengthMeasure`")); }
     } while(0);
 	return base;
@@ -2300,27 +2300,27 @@ template <> size_t GenericFill<IfcCartesianTransformationOperator>(const DB& db,
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis1, arg, db ); break; } 
+        try { GenericConvert( in->Axis1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Axis2' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis2, arg, db ); break; } 
+        try { GenericConvert( in->Axis2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'LocalOrigin' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->LocalOrigin, arg, db ); break; } 
+        try { GenericConvert( in->LocalOrigin, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCartesianTransformationOperator to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'Scale' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale, arg, db ); break; } 
+        try { GenericConvert( in->Scale, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCartesianTransformationOperator to be a `IfcReal`")); }
     } while(0);
 	return base;
@@ -2347,7 +2347,7 @@ template <> size_t GenericFill<IfcCartesianTransformationOperator3D>(const DB& d
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator3D,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Axis3, arg, db ); break; } 
+        try { GenericConvert( in->Axis3, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCartesianTransformationOperator3D to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -2359,13 +2359,13 @@ template <> size_t GenericFill<IfcCartesianTransformationOperator3DnonUniform>(c
 	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcCartesianTransformationOperator3DnonUniform"); }    do { // convert the 'Scale2' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale2, arg, db ); break; } 
+        try { GenericConvert( in->Scale2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcCartesianTransformationOperator3DnonUniform to be a `IfcReal`")); }
     } while(0);
     do { // convert the 'Scale3' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Scale3, arg, db ); break; } 
+        try { GenericConvert( in->Scale3, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcCartesianTransformationOperator3DnonUniform to be a `IfcReal`")); }
     } while(0);
 	return base;
@@ -2412,7 +2412,7 @@ template <> size_t GenericFill<IfcConic>(const DB& db, const LIST& params, IfcCo
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConic"); }    do { // convert the 'Position' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConic,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConic to be a `IfcAxis2Placement`")); }
     } while(0);
 	return base;
@@ -2423,7 +2423,7 @@ template <> size_t GenericFill<IfcCircle>(const DB& db, const LIST& params, IfcC
 	size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCircle"); }    do { // convert the 'Radius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCircle to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -2435,7 +2435,7 @@ template <> size_t GenericFill<IfcCircleProfileDef>(const DB& db, const LIST& pa
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcCircleProfileDef"); }    do { // convert the 'Radius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCircleProfileDef,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCircleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -2446,7 +2446,7 @@ template <> size_t GenericFill<IfcCircleHollowProfileDef>(const DB& db, const LI
 	size_t base = GenericFill(db,params,static_cast<IfcCircleProfileDef*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcCircleHollowProfileDef"); }    do { // convert the 'WallThickness' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->WallThickness, arg, db ); break; } 
+        try { GenericConvert( in->WallThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCircleHollowProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -2472,7 +2472,7 @@ template <> size_t GenericFill<IfcConnectedFaceSet>(const DB& db, const LIST& pa
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConnectedFaceSet"); }    do { // convert the 'CfsFaces' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConnectedFaceSet,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->CfsFaces, arg, db ); break; } 
+        try { GenericConvert( in->CfsFaces, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConnectedFaceSet to be a `SET [1:?] OF IfcFace`")); }
     } while(0);
 	return base;
@@ -2505,7 +2505,7 @@ template <> size_t GenericFill<IfcColourSpecification>(const DB& db, const LIST&
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcColourSpecification,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcColourSpecification to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -2516,17 +2516,17 @@ template <> size_t GenericFill<IfcColourRgb>(const DB& db, const LIST& params, I
 	size_t base = GenericFill(db,params,static_cast<IfcColourSpecification*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcColourRgb"); }    do { // convert the 'Red' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Red, arg, db ); break; } 
+        try { GenericConvert( in->Red, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'Green' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Green, arg, db ); break; } 
+        try { GenericConvert( in->Green, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
     do { // convert the 'Blue' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Blue, arg, db ); break; } 
+        try { GenericConvert( in->Blue, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
 	return base;
@@ -2579,14 +2579,14 @@ template <> size_t GenericFill<IfcProperty>(const DB& db, const LIST& params, If
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProperty"); }    do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProperty,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProperty to be a `IfcIdentifier`")); }
     } while(0);
     do { // convert the 'Description' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProperty,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProperty to be a `IfcText`")); }
     } while(0);
 	return base;
@@ -2597,12 +2597,12 @@ template <> size_t GenericFill<IfcComplexProperty>(const DB& db, const LIST& par
 	size_t base = GenericFill(db,params,static_cast<IfcProperty*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcComplexProperty"); }    do { // convert the 'UsageName' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UsageName, arg, db ); break; } 
+        try { GenericConvert( in->UsageName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcComplexProperty to be a `IfcIdentifier`")); }
     } while(0);
     do { // convert the 'HasProperties' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->HasProperties, arg, db ); break; } 
+        try { GenericConvert( in->HasProperties, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcComplexProperty to be a `SET [1:?] OF IfcProperty`")); }
     } while(0);
 	return base;
@@ -2620,19 +2620,19 @@ template <> size_t GenericFill<IfcCompositeCurveSegment>(const DB& db, const LIS
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcCompositeCurveSegment"); }    do { // convert the 'Transition' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurveSegment,3>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Transition, arg, db ); break; } 
+        try { GenericConvert( in->Transition, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurveSegment to be a `IfcTransitionCode`")); }
     } while(0);
     do { // convert the 'SameSense' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurveSegment,3>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->SameSense, arg, db ); break; } 
+        try { GenericConvert( in->SameSense, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurveSegment to be a `IfcBoolean`")); }
     } while(0);
     do { // convert the 'ParentCurve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurveSegment,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->ParentCurve, arg, db ); break; } 
+        try { GenericConvert( in->ParentCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCompositeCurveSegment to be a `IfcCurve`")); }
     } while(0);
 	return base;
@@ -2764,35 +2764,35 @@ template <> size_t GenericFill<IfcContext>(const DB& db, const LIST& params, Ifc
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ObjectType, arg, db ); break; } 
+        try { GenericConvert( in->ObjectType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'LongName' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LongName, arg, db ); break; } 
+        try { GenericConvert( in->LongName, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Phase' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Phase, arg, db ); break; } 
+        try { GenericConvert( in->Phase, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'RepresentationContexts' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationContexts, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationContexts, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcContext to be a `SET [1:?] OF IfcRepresentationContext`")); }
     } while(0);
     do { // convert the 'UnitsInContext' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcContext,5>::aux_is_derived[4]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->UnitsInContext, arg, db ); break; } 
+        try { GenericConvert( in->UnitsInContext, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcContext to be a `IfcUnitAssignment`")); }
     } while(0);
 	return base;
@@ -2804,13 +2804,13 @@ template <> size_t GenericFill<IfcNamedUnit>(const DB& db, const LIST& params, I
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcNamedUnit"); }    do { // convert the 'Dimensions' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcNamedUnit,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Dimensions, arg, db ); break; } 
+        try { GenericConvert( in->Dimensions, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcNamedUnit to be a `IfcDimensionalExponents`")); }
     } while(0);
     do { // convert the 'UnitType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcNamedUnit,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->UnitType, arg, db ); break; } 
+        try { GenericConvert( in->UnitType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcNamedUnit to be a `IfcUnitEnum`")); }
     } while(0);
 	return base;
@@ -2843,13 +2843,13 @@ template <> size_t GenericFill<IfcConversionBasedUnit>(const DB& db, const LIST&
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcConversionBasedUnit"); }    do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConversionBasedUnit,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcConversionBasedUnit to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'ConversionFactor' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConversionBasedUnit,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->ConversionFactor, arg, db ); break; } 
+        try { GenericConvert( in->ConversionFactor, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcConversionBasedUnit to be a `IfcMeasureWithUnit`")); }
     } while(0);
 	return base;
@@ -2974,7 +2974,7 @@ template <> size_t GenericFill<IfcPresentationStyle>(const DB& db, const LIST& p
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcPresentationStyle,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyle to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -2986,7 +2986,7 @@ template <> size_t GenericFill<IfcElementarySurface>(const DB& db, const LIST& p
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcElementarySurface"); }    do { // convert the 'Position' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcElementarySurface,1>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcElementarySurface to be a `IfcAxis2Placement3D`")); }
     } while(0);
 	return base;
@@ -3025,7 +3025,7 @@ template <> size_t GenericFill<IfcDirection>(const DB& db, const LIST& params, I
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcDirection"); }    do { // convert the 'DirectionRatios' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->DirectionRatios, arg, db ); break; } 
+        try { GenericConvert( in->DirectionRatios, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcDirection to be a `LIST [2:3] OF IfcReal`")); }
     } while(0);
 	return base;
@@ -3094,35 +3094,35 @@ template <> size_t GenericFill<IfcDoor>(const DB& db, const LIST& params, IfcDoo
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OverallHeight, arg, db ); break; } 
+        try { GenericConvert( in->OverallHeight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'OverallWidth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OverallWidth, arg, db ); break; } 
+        try { GenericConvert( in->OverallWidth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'PredefinedType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PredefinedType, arg, db ); break; } 
+        try { GenericConvert( in->PredefinedType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcDoor to be a `IfcDoorTypeEnum`")); }
     } while(0);
     do { // convert the 'OperationType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->OperationType, arg, db ); break; } 
+        try { GenericConvert( in->OperationType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcDoor to be a `IfcDoorTypeOperationEnum`")); }
     } while(0);
     do { // convert the 'UserDefinedOperationType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcDoor,5>::aux_is_derived[4]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->UserDefinedOperationType, arg, db ); break; } 
+        try { GenericConvert( in->UserDefinedOperationType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 12 to IfcDoor to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -3362,12 +3362,12 @@ template <> size_t GenericFill<IfcElementQuantity>(const DB& db, const LIST& par
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcElementQuantity"); }    do { // convert the 'MethodOfMeasurement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->MethodOfMeasurement, arg, db ); break; } 
+        try { GenericConvert( in->MethodOfMeasurement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcElementQuantity to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Quantities' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Quantities, arg, db ); break; } 
+        try { GenericConvert( in->Quantities, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcElementQuantity to be a `SET [1:?] OF IfcPhysicalQuantity`")); }
     } while(0);
 	return base;
@@ -3378,12 +3378,12 @@ template <> size_t GenericFill<IfcEllipse>(const DB& db, const LIST& params, Ifc
 	size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcEllipse"); }    do { // convert the 'SemiAxis1' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SemiAxis1, arg, db ); break; } 
+        try { GenericConvert( in->SemiAxis1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'SemiAxis2' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SemiAxis2, arg, db ); break; } 
+        try { GenericConvert( in->SemiAxis2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -3486,14 +3486,14 @@ template <> size_t GenericFill<IfcSweptAreaSolid>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcSweptAreaSolid"); }    do { // convert the 'SweptArea' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptAreaSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->SweptArea, arg, db ); break; } 
+        try { GenericConvert( in->SweptArea, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptAreaSolid to be a `IfcProfileDef`")); }
     } while(0);
     do { // convert the 'Position' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptAreaSolid,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptAreaSolid to be a `IfcAxis2Placement3D`")); }
     } while(0);
 	return base;
@@ -3505,13 +3505,13 @@ template <> size_t GenericFill<IfcExtrudedAreaSolid>(const DB& db, const LIST& p
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcExtrudedAreaSolid"); }    do { // convert the 'ExtrudedDirection' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcExtrudedAreaSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; } 
+        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcExtrudedAreaSolid to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Depth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcExtrudedAreaSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Depth, arg, db ); break; } 
+        try { GenericConvert( in->Depth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcExtrudedAreaSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -3529,7 +3529,7 @@ template <> size_t GenericFill<IfcFaceBasedSurfaceModel>(const DB& db, const LIS
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFaceBasedSurfaceModel"); }    do { // convert the 'FbsmFaces' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->FbsmFaces, arg, db ); break; } 
+        try { GenericConvert( in->FbsmFaces, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBasedSurfaceModel to be a `SET [1:?] OF IfcConnectedFaceSet`")); }
     } while(0);
 	return base;
@@ -3541,13 +3541,13 @@ template <> size_t GenericFill<IfcFaceBound>(const DB& db, const LIST& params, I
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcFaceBound"); }    do { // convert the 'Bound' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcFaceBound,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Bound, arg, db ); break; } 
+        try { GenericConvert( in->Bound, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBound to be a `IfcLoop`")); }
     } while(0);
     do { // convert the 'Orientation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcFaceBound,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Orientation, arg, db ); break; } 
+        try { GenericConvert( in->Orientation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcFaceBound to be a `IfcBoolean`")); }
     } while(0);
 	return base;
@@ -3774,14 +3774,14 @@ template <> size_t GenericFill<IfcRepresentationContext>(const DB& db, const LIS
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentationContext,2>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ContextIdentifier, arg, db ); break; } 
+        try { GenericConvert( in->ContextIdentifier, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationContext to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'ContextType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentationContext,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ContextType, arg, db ); break; } 
+        try { GenericConvert( in->ContextType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationContext to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -3793,27 +3793,27 @@ template <> size_t GenericFill<IfcGeometricRepresentationContext>(const DB& db,
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcGeometricRepresentationContext"); }    do { // convert the 'CoordinateSpaceDimension' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; } 
+        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcGeometricRepresentationContext to be a `IfcDimensionCount`")); }
     } while(0);
     do { // convert the 'Precision' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Precision, arg, db ); break; } 
+        try { GenericConvert( in->Precision, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcGeometricRepresentationContext to be a `IfcReal`")); }
     } while(0);
     do { // convert the 'WorldCoordinateSystem' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->WorldCoordinateSystem, arg, db ); break; } 
+        try { GenericConvert( in->WorldCoordinateSystem, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcGeometricRepresentationContext to be a `IfcAxis2Placement`")); }
     } while(0);
     do { // convert the 'TrueNorth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->TrueNorth, arg, db ); break; } 
+        try { GenericConvert( in->TrueNorth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcGeometricRepresentationContext to be a `IfcDirection`")); }
     } while(0);
 	return base;
@@ -3879,40 +3879,40 @@ template <> size_t GenericFill<IfcIShapeProfileDef>(const DB& db, const LIST& pa
 	size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
 	if (params.GetSize() < 10) { throw STEP::TypeError("expected 10 arguments to IfcIShapeProfileDef"); }    do { // convert the 'OverallWidth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->OverallWidth, arg, db ); break; } 
+        try { GenericConvert( in->OverallWidth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'OverallDepth' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->OverallDepth, arg, db ); break; } 
+        try { GenericConvert( in->OverallDepth, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'WebThickness' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->WebThickness, arg, db ); break; } 
+        try { GenericConvert( in->WebThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'FlangeThickness' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->FlangeThickness, arg, db ); break; } 
+        try { GenericConvert( in->FlangeThickness, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'FilletRadius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->FilletRadius, arg, db ); break; } 
+        try { GenericConvert( in->FilletRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcIShapeProfileDef to be a `IfcNonNegativeLengthMeasure`")); }
     } while(0);
     do { // convert the 'FlangeEdgeRadius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->FlangeEdgeRadius, arg, db ); break; } 
+        try { GenericConvert( in->FlangeEdgeRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcIShapeProfileDef to be a `IfcNonNegativeLengthMeasure`")); }
     } while(0);
     do { // convert the 'FlangeSlope' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->FlangeSlope, arg, db ); break; } 
+        try { GenericConvert( in->FlangeSlope, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcIShapeProfileDef to be a `IfcPlaneAngleMeasure`")); }
     } while(0);
 	return base;
@@ -4091,12 +4091,12 @@ template <> size_t GenericFill<IfcLine>(const DB& db, const LIST& params, IfcLin
 	size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLine"); }    do { // convert the 'Pnt' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Pnt, arg, db ); break; } 
+        try { GenericConvert( in->Pnt, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLine to be a `IfcCartesianPoint`")); }
     } while(0);
     do { // convert the 'Dir' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Dir, arg, db ); break; } 
+        try { GenericConvert( in->Dir, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLine to be a `IfcVector`")); }
     } while(0);
 	return base;
@@ -4108,12 +4108,12 @@ template <> size_t GenericFill<IfcLocalPlacement>(const DB& db, const LIST& para
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLocalPlacement"); }    do { // convert the 'PlacementRelTo' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PlacementRelTo, arg, db ); break; } 
+        try { GenericConvert( in->PlacementRelTo, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLocalPlacement to be a `IfcObjectPlacement`")); }
     } while(0);
     do { // convert the 'RelativePlacement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelativePlacement, arg, db ); break; } 
+        try { GenericConvert( in->RelativePlacement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLocalPlacement to be a `IfcAxis2Placement`")); }
     } while(0);
 	return base;
@@ -4124,12 +4124,12 @@ template <> size_t GenericFill<IfcMappedItem>(const DB& db, const LIST& params,
 	size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMappedItem"); }    do { // convert the 'MappingSource' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingSource, arg, db ); break; } 
+        try { GenericConvert( in->MappingSource, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMappedItem to be a `IfcRepresentationMap`")); }
     } while(0);
     do { // convert the 'MappingTarget' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingTarget, arg, db ); break; } 
+        try { GenericConvert( in->MappingTarget, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMappedItem to be a `IfcCartesianTransformationOperator`")); }
     } while(0);
 	return base;
@@ -4142,20 +4142,20 @@ template <> size_t GenericFill<IfcProductRepresentation>(const DB& db, const LIS
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProductRepresentation,3>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProductRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Description' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProductRepresentation,3>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Description, arg, db ); break; } 
+        try { GenericConvert( in->Description, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProductRepresentation to be a `IfcText`")); }
     } while(0);
     do { // convert the 'Representations' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProductRepresentation,3>::aux_is_derived[2]=true; break; }
-        try { GenericConvert( in->Representations, arg, db ); break; } 
+        try { GenericConvert( in->Representations, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcProductRepresentation to be a `LIST [1:?] OF IfcRepresentation`")); }
     } while(0);
 	return base;
@@ -4173,12 +4173,12 @@ template <> size_t GenericFill<IfcMeasureWithUnit>(const DB& db, const LIST& par
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMeasureWithUnit"); }    do { // convert the 'ValueComponent' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ValueComponent, arg, db ); break; } 
+        try { GenericConvert( in->ValueComponent, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMeasureWithUnit to be a `IfcValue`")); }
     } while(0);
     do { // convert the 'UnitComponent' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->UnitComponent, arg, db ); break; } 
+        try { GenericConvert( in->UnitComponent, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMeasureWithUnit to be a `IfcUnit`")); }
     } while(0);
 	return base;
@@ -4289,7 +4289,7 @@ template <> size_t GenericFill<IfcOpeningElement>(const DB& db, const LIST& para
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcOpeningElement,1>::aux_is_derived[0]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PredefinedType, arg, db ); break; } 
+        try { GenericConvert( in->PredefinedType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcOpeningElement to be a `IfcOpeningElementTypeEnum`")); }
     } while(0);
 	return base;
@@ -4460,7 +4460,7 @@ template <> size_t GenericFill<IfcPolyLoop>(const DB& db, const LIST& params, If
 	size_t base = GenericFill(db,params,static_cast<IfcLoop*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyLoop"); }    do { // convert the 'Polygon' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Polygon, arg, db ); break; } 
+        try { GenericConvert( in->Polygon, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyLoop to be a `LIST [3:?] OF IfcCartesianPoint`")); }
     } while(0);
 	return base;
@@ -4471,12 +4471,12 @@ template <> size_t GenericFill<IfcPolygonalBoundedHalfSpace>(const DB& db, const
 	size_t base = GenericFill(db,params,static_cast<IfcHalfSpaceSolid*>(in));
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPolygonalBoundedHalfSpace"); }    do { // convert the 'Position' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Position, arg, db ); break; } 
+        try { GenericConvert( in->Position, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPolygonalBoundedHalfSpace to be a `IfcAxis2Placement3D`")); }
     } while(0);
     do { // convert the 'PolygonalBoundary' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->PolygonalBoundary, arg, db ); break; } 
+        try { GenericConvert( in->PolygonalBoundary, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPolygonalBoundedHalfSpace to be a `IfcBoundedCurve`")); }
     } while(0);
 	return base;
@@ -4501,7 +4501,7 @@ template <> size_t GenericFill<IfcPolyline>(const DB& db, const LIST& params, If
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyline"); }    do { // convert the 'Points' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Points, arg, db ); break; } 
+        try { GenericConvert( in->Points, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyline to be a `LIST [2:?] OF IfcCartesianPoint`")); }
     } while(0);
 	return base;
@@ -4512,7 +4512,7 @@ template <> size_t GenericFill<IfcPresentationStyleAssignment>(const DB& db, con
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPresentationStyleAssignment"); }    do { // convert the 'Styles' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyleAssignment to be a `SET [1:?] OF IfcPresentationStyleSelect`")); }
     } while(0);
 	return base;
@@ -4592,13 +4592,13 @@ template <> size_t GenericFill<IfcPropertyListValue>(const DB& db, const LIST& p
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertyListValue"); }    do { // convert the 'ListValues' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ListValues, arg, db ); break; } 
+        try { GenericConvert( in->ListValues, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertyListValue to be a `LIST [1:?] OF IfcValue`")); }
     } while(0);
     do { // convert the 'Unit' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Unit, arg, db ); break; } 
+        try { GenericConvert( in->Unit, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertyListValue to be a `IfcUnit`")); }
     } while(0);
 	return base;
@@ -4616,7 +4616,7 @@ template <> size_t GenericFill<IfcPropertySet>(const DB& db, const LIST& params,
 	size_t base = GenericFill(db,params,static_cast<IfcPropertySetDefinition*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcPropertySet"); }    do { // convert the 'HasProperties' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->HasProperties, arg, db ); break; } 
+        try { GenericConvert( in->HasProperties, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcPropertySet to be a `SET [1:?] OF IfcProperty`")); }
     } while(0);
 	return base;
@@ -4628,13 +4628,13 @@ template <> size_t GenericFill<IfcPropertySingleValue>(const DB& db, const LIST&
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertySingleValue"); }    do { // convert the 'NominalValue' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->NominalValue, arg, db ); break; } 
+        try { GenericConvert( in->NominalValue, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertySingleValue to be a `IfcValue`")); }
     } while(0);
     do { // convert the 'Unit' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Unit, arg, db ); break; } 
+        try { GenericConvert( in->Unit, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertySingleValue to be a `IfcUnit`")); }
     } while(0);
 	return base;
@@ -4758,13 +4758,13 @@ template <> size_t GenericFill<IfcRectangleProfileDef>(const DB& db, const LIST&
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcRectangleProfileDef"); }    do { // convert the 'XDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRectangleProfileDef,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->XDim, arg, db ); break; } 
+        try { GenericConvert( in->XDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'YDim' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRectangleProfileDef,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->YDim, arg, db ); break; } 
+        try { GenericConvert( in->YDim, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
 	return base;
@@ -4850,12 +4850,12 @@ template <> size_t GenericFill<IfcRelAggregates>(const DB& db, const LIST& param
 	size_t base = GenericFill(db,params,static_cast<IfcRelDecomposes*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelAggregates"); }    do { // convert the 'RelatingObject' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingObject, arg, db ); break; } 
+        try { GenericConvert( in->RelatingObject, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelAggregates to be a `IfcObjectDefinition`")); }
     } while(0);
     do { // convert the 'RelatedObjects' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedObjects, arg, db ); break; } 
+        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelAggregates to be a `SET [1:?] OF IfcObjectDefinition`")); }
     } while(0);
 	return base;
@@ -4872,12 +4872,12 @@ template <> size_t GenericFill<IfcRelContainedInSpatialStructure>(const DB& db,
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelContainedInSpatialStructure"); }    do { // convert the 'RelatedElements' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedElements, arg, db ); break; } 
+        try { GenericConvert( in->RelatedElements, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelContainedInSpatialStructure to be a `SET [1:?] OF IfcProduct`")); }
     } while(0);
     do { // convert the 'RelatingStructure' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingStructure, arg, db ); break; } 
+        try { GenericConvert( in->RelatingStructure, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelContainedInSpatialStructure to be a `IfcSpatialElement`")); }
     } while(0);
 	return base;
@@ -4894,12 +4894,12 @@ template <> size_t GenericFill<IfcRelDefinesByProperties>(const DB& db, const LI
 	size_t base = GenericFill(db,params,static_cast<IfcRelDefines*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelDefinesByProperties"); }    do { // convert the 'RelatedObjects' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedObjects, arg, db ); break; } 
+        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelDefinesByProperties to be a `SET [1:?] OF IfcObjectDefinition`")); }
     } while(0);
     do { // convert the 'RelatingPropertyDefinition' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingPropertyDefinition, arg, db ); break; } 
+        try { GenericConvert( in->RelatingPropertyDefinition, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelDefinesByProperties to be a `IfcPropertySetDefinitionSelect`")); }
     } while(0);
 	return base;
@@ -4910,12 +4910,12 @@ template <> size_t GenericFill<IfcRelFillsElement>(const DB& db, const LIST& par
 	size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelFillsElement"); }    do { // convert the 'RelatingOpeningElement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingOpeningElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatingOpeningElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelFillsElement to be a `IfcOpeningElement`")); }
     } while(0);
     do { // convert the 'RelatedBuildingElement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedBuildingElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatedBuildingElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelFillsElement to be a `IfcElement`")); }
     } while(0);
 	return base;
@@ -4926,12 +4926,12 @@ template <> size_t GenericFill<IfcRelVoidsElement>(const DB& db, const LIST& par
 	size_t base = GenericFill(db,params,static_cast<IfcRelDecomposes*>(in));
 	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelVoidsElement"); }    do { // convert the 'RelatingBuildingElement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatingBuildingElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatingBuildingElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelVoidsElement to be a `IfcElement`")); }
     } while(0);
     do { // convert the 'RelatedOpeningElement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->RelatedOpeningElement, arg, db ); break; } 
+        try { GenericConvert( in->RelatedOpeningElement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelVoidsElement to be a `IfcFeatureElementSubtraction`")); }
     } while(0);
 	return base;
@@ -4950,27 +4950,27 @@ template <> size_t GenericFill<IfcRepresentation>(const DB& db, const LIST& para
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRepresentation"); }    do { // convert the 'ContextOfItems' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->ContextOfItems, arg, db ); break; } 
+        try { GenericConvert( in->ContextOfItems, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentation to be a `IfcRepresentationContext`")); }
     } while(0);
     do { // convert the 'RepresentationIdentifier' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationIdentifier, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationIdentifier, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'RepresentationType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RepresentationType, arg, db ); break; } 
+        try { GenericConvert( in->RepresentationType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRepresentation to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'Items' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[3]=true; break; }
-        try { GenericConvert( in->Items, arg, db ); break; } 
+        try { GenericConvert( in->Items, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRepresentation to be a `SET [1:?] OF IfcRepresentationItem`")); }
     } while(0);
 	return base;
@@ -4981,12 +4981,12 @@ template <> size_t GenericFill<IfcRepresentationMap>(const DB& db, const LIST& p
 	size_t base = 0;
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcRepresentationMap"); }    do { // convert the 'MappingOrigin' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappingOrigin, arg, db ); break; } 
+        try { GenericConvert( in->MappingOrigin, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationMap to be a `IfcAxis2Placement`")); }
     } while(0);
     do { // convert the 'MappedRepresentation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MappedRepresentation, arg, db ); break; } 
+        try { GenericConvert( in->MappedRepresentation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationMap to be a `IfcRepresentation`")); }
     } while(0);
 	return base;
@@ -4998,13 +4998,13 @@ template <> size_t GenericFill<IfcRevolvedAreaSolid>(const DB& db, const LIST& p
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRevolvedAreaSolid"); }    do { // convert the 'Axis' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRevolvedAreaSolid,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Axis, arg, db ); break; } 
+        try { GenericConvert( in->Axis, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRevolvedAreaSolid to be a `IfcAxis1Placement`")); }
     } while(0);
     do { // convert the 'Angle' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRevolvedAreaSolid,2>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Angle, arg, db ); break; } 
+        try { GenericConvert( in->Angle, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRevolvedAreaSolid to be a `IfcPlaneAngleMeasure`")); }
     } while(0);
 	return base;
@@ -5058,12 +5058,12 @@ template <> size_t GenericFill<IfcSIUnit>(const DB& db, const LIST& params, IfcS
 	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcSIUnit"); }    do { // convert the 'Prefix' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Prefix, arg, db ); break; } 
+        try { GenericConvert( in->Prefix, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSIUnit to be a `IfcSIPrefix`")); }
     } while(0);
     do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSIUnit to be a `IfcSIUnitName`")); }
     } while(0);
 	return base;
@@ -5144,7 +5144,7 @@ template <> size_t GenericFill<IfcShellBasedSurfaceModel>(const DB& db, const LI
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcShellBasedSurfaceModel"); }    do { // convert the 'SbsmBoundary' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SbsmBoundary, arg, db ); break; } 
+        try { GenericConvert( in->SbsmBoundary, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcShellBasedSurfaceModel to be a `SET [1:?] OF IfcShell`")); }
     } while(0);
 	return base;
@@ -5156,31 +5156,31 @@ template <> size_t GenericFill<IfcSite>(const DB& db, const LIST& params, IfcSit
 	if (params.GetSize() < 14) { throw STEP::TypeError("expected 14 arguments to IfcSite"); }    do { // convert the 'RefLatitude' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefLatitude, arg, db ); break; } 
+        try { GenericConvert( in->RefLatitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
     } while(0);
     do { // convert the 'RefLongitude' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefLongitude, arg, db ); break; } 
+        try { GenericConvert( in->RefLongitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
     } while(0);
     do { // convert the 'RefElevation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->RefElevation, arg, db ); break; } 
+        try { GenericConvert( in->RefElevation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcSite to be a `IfcLengthMeasure`")); }
     } while(0);
     do { // convert the 'LandTitleNumber' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->LandTitleNumber, arg, db ); break; } 
+        try { GenericConvert( in->LandTitleNumber, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 12 to IfcSite to be a `IfcLabel`")); }
     } while(0);
     do { // convert the 'SiteAddress' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SiteAddress, arg, db ); break; } 
+        try { GenericConvert( in->SiteAddress, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 13 to IfcSite to be a `IfcPostalAddress`")); }
     } while(0);
 	return base;
@@ -5234,13 +5234,13 @@ template <> size_t GenericFill<IfcSpace>(const DB& db, const LIST& params, IfcSp
 	if (params.GetSize() < 11) { throw STEP::TypeError("expected 11 arguments to IfcSpace"); }    do { // convert the 'PredefinedType' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->PredefinedType, arg, db ); break; } 
+        try { GenericConvert( in->PredefinedType, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSpace to be a `IfcSpaceTypeEnum`")); }
     } while(0);
     do { // convert the 'ElevationWithFlooring' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ElevationWithFlooring, arg, db ); break; } 
+        try { GenericConvert( in->ElevationWithFlooring, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSpace to be a `IfcLengthMeasure`")); }
     } while(0);
 	return base;
@@ -5539,18 +5539,18 @@ template <> size_t GenericFill<IfcStyledItem>(const DB& db, const LIST& params,
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcStyledItem"); }    do { // convert the 'Item' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Item, arg, db ); break; } 
+        try { GenericConvert( in->Item, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcStyledItem to be a `IfcRepresentationItem`")); }
     } while(0);
     do { // convert the 'Styles' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcStyledItem to be a `SET [1:?] OF IfcStyleAssignmentSelect`")); }
     } while(0);
     do { // convert the 'Name' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Name, arg, db ); break; } 
+        try { GenericConvert( in->Name, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcStyledItem to be a `IfcLabel`")); }
     } while(0);
 	return base;
@@ -5624,12 +5624,12 @@ template <> size_t GenericFill<IfcSurfaceStyle>(const DB& db, const LIST& params
 	size_t base = GenericFill(db,params,static_cast<IfcPresentationStyle*>(in));
 	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcSurfaceStyle"); }    do { // convert the 'Side' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Side, arg, db ); break; } 
+        try { GenericConvert( in->Side, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyle to be a `IfcSurfaceSide`")); }
     } while(0);
     do { // convert the 'Styles' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Styles, arg, db ); break; } 
+        try { GenericConvert( in->Styles, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyle to be a `SET [1:5] OF IfcSurfaceStyleElementSelect`")); }
     } while(0);
 	return base;
@@ -5641,14 +5641,14 @@ template <> size_t GenericFill<IfcSurfaceStyleShading>(const DB& db, const LIST&
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcSurfaceStyleShading"); }    do { // convert the 'SurfaceColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSurfaceStyleShading,2>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->SurfaceColour, arg, db ); break; } 
+        try { GenericConvert( in->SurfaceColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleShading to be a `IfcColourRgb`")); }
     } while(0);
     do { // convert the 'Transparency' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSurfaceStyleShading,2>::aux_is_derived[1]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->Transparency, arg, db ); break; } 
+        try { GenericConvert( in->Transparency, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyleShading to be a `IfcNormalisedRatioMeasure`")); }
     } while(0);
 	return base;
@@ -5660,42 +5660,42 @@ template <> size_t GenericFill<IfcSurfaceStyleRendering>(const DB& db, const LIS
 	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcSurfaceStyleRendering"); }    do { // convert the 'DiffuseColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->DiffuseColour, arg, db ); break; } 
+        try { GenericConvert( in->DiffuseColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'TransmissionColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->TransmissionColour, arg, db ); break; } 
+        try { GenericConvert( in->TransmissionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'DiffuseTransmissionColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->DiffuseTransmissionColour, arg, db ); break; } 
+        try { GenericConvert( in->DiffuseTransmissionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'ReflectionColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->ReflectionColour, arg, db ); break; } 
+        try { GenericConvert( in->ReflectionColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'SpecularColour' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SpecularColour, arg, db ); break; } 
+        try { GenericConvert( in->SpecularColour, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
     } while(0);
     do { // convert the 'SpecularHighlight' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->SpecularHighlight, arg, db ); break; } 
+        try { GenericConvert( in->SpecularHighlight, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSurfaceStyleRendering to be a `IfcSpecularHighlightSelect`")); }
     } while(0);
     do { // convert the 'ReflectanceMethod' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->ReflectanceMethod, arg, db ); break; } 
+        try { GenericConvert( in->ReflectanceMethod, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSurfaceStyleRendering to be a `IfcReflectanceMethodEnum`")); }
     } while(0);
 	return base;
@@ -5706,7 +5706,7 @@ template <> size_t GenericFill<IfcSurfaceStyleWithTextures>(const DB& db, const
 	size_t base = GenericFill(db,params,static_cast<IfcPresentationItem*>(in));
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcSurfaceStyleWithTextures"); }    do { // convert the 'Textures' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Textures, arg, db ); break; } 
+        try { GenericConvert( in->Textures, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleWithTextures to be a `LIST [1:?] OF IfcSurfaceTexture`")); }
     } while(0);
 	return base;
@@ -5718,34 +5718,34 @@ template <> size_t GenericFill<IfcSweptDiskSolid>(const DB& db, const LIST& para
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcSweptDiskSolid"); }    do { // convert the 'Directrix' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[0]=true; break; }
-        try { GenericConvert( in->Directrix, arg, db ); break; } 
+        try { GenericConvert( in->Directrix, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptDiskSolid to be a `IfcCurve`")); }
     } while(0);
     do { // convert the 'Radius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[1]=true; break; }
-        try { GenericConvert( in->Radius, arg, db ); break; } 
+        try { GenericConvert( in->Radius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'InnerRadius' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[2]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->InnerRadius, arg, db ); break; } 
+        try { GenericConvert( in->InnerRadius, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
     } while(0);
     do { // convert the 'StartParam' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[3]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->StartParam, arg, db ); break; } 
+        try { GenericConvert( in->StartParam, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
     } while(0);
     do { // convert the 'EndParam' argument
         boost::shared_ptr<const DataType> arg = params[base++];
         if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptDiskSolid,5>::aux_is_derived[4]=true; break; }
         if (dynamic_cast<const UNSET*>(&*arg)) break;
-        try { GenericConvert( in->EndParam, arg, db ); break; } 
+        try { GenericConvert( in->EndParam, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
     } while(0);
 	return base;
@@ -5924,27 +5924,27 @@ template <> size_t GenericFill<IfcTrimmedCurve>(const DB& db, const LIST& params
 	size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
 	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcTrimmedCurve"); }    do { // convert the 'BasisCurve' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->BasisCurve, arg, db ); break; } 
+        try { GenericConvert( in->BasisCurve, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcTrimmedCurve to be a `IfcCurve`")); }
     } while(0);
     do { // convert the 'Trim1' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Trim1, arg, db ); break; } 
+        try { GenericConvert( in->Trim1, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
     } while(0);
     do { // convert the 'Trim2' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Trim2, arg, db ); break; } 
+        try { GenericConvert( in->Trim2, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
     } while(0);
     do { // convert the 'SenseAgreement' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->SenseAgreement, arg, db ); break; } 
+        try { GenericConvert( in->SenseAgreement, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcTrimmedCurve to be a `IfcBoolean`")); }
     } while(0);
     do { // convert the 'MasterRepresentation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->MasterRepresentation, arg, db ); break; } 
+        try { GenericConvert( in->MasterRepresentation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcTrimmedCurve to be a `IfcTrimmingPreference`")); }
     } while(0);
 	return base;
@@ -5976,7 +5976,7 @@ template <> size_t GenericFill<IfcUnitAssignment>(const DB& db, const LIST& para
 	size_t base = 0;
 	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcUnitAssignment"); }    do { // convert the 'Units' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Units, arg, db ); break; } 
+        try { GenericConvert( in->Units, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcUnitAssignment to be a `SET [1:?] OF IfcUnit`")); }
     } while(0);
 	return base;
@@ -6029,12 +6029,12 @@ template <> size_t GenericFill<IfcVector>(const DB& db, const LIST& params, IfcV
 	size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
 	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcVector"); }    do { // convert the 'Orientation' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Orientation, arg, db ); break; } 
+        try { GenericConvert( in->Orientation, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcVector to be a `IfcDirection`")); }
     } while(0);
     do { // convert the 'Magnitude' argument
         boost::shared_ptr<const DataType> arg = params[base++];
-        try { GenericConvert( in->Magnitude, arg, db ); break; } 
+        try { GenericConvert( in->Magnitude, arg, db ); break; }
         catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcVector to be a `IfcLengthMeasure`")); }
     } while(0);
 	return base;
diff --git a/code/AssetLib/IFC/IFCReaderGen_4.h b/code/AssetLib/IFC/IFCReaderGen_4.h
index 0f184cd020..abf0219111 100644
--- a/code/AssetLib/IFC/IFCReaderGen_4.h
+++ b/code/AssetLib/IFC/IFCReaderGen_4.h
@@ -5,8 +5,8 @@ Open Asset Import Library (ASSIMP)
 Copyright (c) 2006-2020, ASSIMP Development Team
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the
 following conditions are met:
 
 * Redistributions of source code must retain the above
@@ -23,16 +23,16 @@ following conditions are met:
   derived from this software without specific prior
   written permission of the ASSIMP Development Team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
@@ -51,12 +51,12 @@ namespace Schema_4 {
 
 	using namespace STEP;
 	using namespace STEP::EXPRESS;
-	
-	
+
+
 	struct NotImplemented : public ObjectHelper<NotImplemented,0> {
-		
+
 	};
-	
+
 
 	// ******************************************************************************
 	// IFC Custom data types
diff --git a/code/AssetLib/Irr/IRRLoader.h b/code/AssetLib/Irr/IRRLoader.h
index 535f6481dc..da90902eda 100644
--- a/code/AssetLib/Irr/IRRLoader.h
+++ b/code/AssetLib/Irr/IRRLoader.h
@@ -273,7 +273,7 @@ class IRRImporter : public BaseImporter, public IrrlichtBase {
         std::vector<aiNodeAnim*>& anims);
 
 private:
-    /// Configuration option: desired output FPS 
+    /// Configuration option: desired output FPS
     double fps;
 
     /// Configuration option: speed flag was set?
diff --git a/code/AssetLib/LWO/LWOAnimation.h b/code/AssetLib/LWO/LWOAnimation.h
index 1ed8caf884..64aa5980ab 100644
--- a/code/AssetLib/LWO/LWOAnimation.h
+++ b/code/AssetLib/LWO/LWOAnimation.h
@@ -114,7 +114,7 @@ enum PrePostBehaviour
 /** \brief Data structure for a LWO animation keyframe
  */
 struct Key {
-    Key() AI_NO_EXCEPT 
+    Key() AI_NO_EXCEPT
     : time()
     , value()
     , inter(IT_LINE)
diff --git a/code/AssetLib/LWS/LWSLoader.cpp b/code/AssetLib/LWS/LWSLoader.cpp
index 01a50b6e49..cb07787faa 100644
--- a/code/AssetLib/LWS/LWSLoader.cpp
+++ b/code/AssetLib/LWS/LWSLoader.cpp
@@ -200,7 +200,7 @@ void LWSImporter::ReadEnvelope(const LWS::Element &dad, LWO::Envelope &fill) {
 
     // reserve enough storage
     std::list<LWS::Element>::const_iterator it = dad.children.begin();
-    
+
     fill.keys.reserve(strtoul10(it->tokens[1].c_str()));
 
     for (++it; it != dad.children.end(); ++it) {
@@ -466,7 +466,7 @@ std::string LWSImporter::FindLWOFile(const std::string &in) {
     std::string tmp(in);
     if (in.length() > 3 && in[1] == ':' && in[2] != '\\' && in[2] != '/') {
         tmp = in[0] + (std::string(":\\") + in.substr(2));
-    } 
+    }
 
     if (io->Exists(tmp)) {
         return in;
diff --git a/code/AssetLib/M3D/M3DWrapper.h b/code/AssetLib/M3D/M3DWrapper.h
index ba838d71dc..dcb82a83a3 100644
--- a/code/AssetLib/M3D/M3DWrapper.h
+++ b/code/AssetLib/M3D/M3DWrapper.h
@@ -84,11 +84,11 @@ class M3DWrapper {
     void reset();
 
 	// The Name access, empty string returned when no m3d instance.
-	std::string Name() const; 
+	std::string Name() const;
 
 	/// Executes a save.
 	unsigned char *Save(int quality, int flags, unsigned int &size);
-    
+
     /// Clearer
 	void ClearSave();
 
@@ -113,16 +113,16 @@ inline std::string M3DWrapper::Name() const {
     return std::string();
 }
 
-inline M3DWrapper::operator bool() const { 
-    return m3d_ != nullptr; 
+inline M3DWrapper::operator bool() const {
+    return m3d_ != nullptr;
 }
 
 inline m3d_t *M3DWrapper::operator->() const {
-    return m3d_; 
+    return m3d_;
 }
 
 inline m3d_t *M3DWrapper::M3D() const {
-    return m3d_; 
+    return m3d_;
 }
 
 } // namespace Assimp
diff --git a/code/AssetLib/M3D/m3d.h b/code/AssetLib/M3D/m3d.h
index 28bf19482d..3adcd5befa 100644
--- a/code/AssetLib/M3D/m3d.h
+++ b/code/AssetLib/M3D/m3d.h
@@ -829,7 +829,7 @@ unsigned char *_m3dstbi_zlib_compress(unsigned char *data, int data_len, int *ou
 #include <sys/time.h>
 #endif
 
-#if !defined(M3D_NOIMPORTER) 
+#if !defined(M3D_NOIMPORTER)
 /* helper functions for the ASCII parser */
 static char *_m3d_findarg(char *s) {
     while (s && *s && *s != ' ' && *s != '\t' && *s != '\r' && *s != '\n')
@@ -4516,7 +4516,7 @@ unsigned char *m3d_save(m3d_t *model, int quality, int flags, unsigned int *size
             }
             if (length) {
                 uint32_t v = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
-                memcpy( length, &v, sizeof(uint32_t));                
+                memcpy( length, &v, sizeof(uint32_t));
                 len += v;
             }
             out = NULL;
@@ -4548,7 +4548,7 @@ unsigned char *m3d_save(m3d_t *model, int quality, int flags, unsigned int *size
                     }
                 }
                 uint32_t v = (uint32_t)((uintptr_t)out - (uintptr_t)((uint8_t *)h + len));
-                memcpy( length, &v, sizeof(uint32_t));                
+                memcpy( length, &v, sizeof(uint32_t));
                 len += v;
                 out = NULL;
             }
diff --git a/code/AssetLib/MD5/MD5Loader.cpp b/code/AssetLib/MD5/MD5Loader.cpp
index 0d9c77b71d..9fba60c61b 100644
--- a/code/AssetLib/MD5/MD5Loader.cpp
+++ b/code/AssetLib/MD5/MD5Loader.cpp
@@ -485,7 +485,7 @@ void MD5Importer::LoadMD5MeshFile() {
                     }
 
                     MD5::WeightDesc &weightDesc = meshSrc.mWeights[w];
-                    if (weightDesc.mWeight < AI_MD5_WEIGHT_EPSILON && weightDesc.mWeight >= -AI_MD5_WEIGHT_EPSILON) { 
+                    if (weightDesc.mWeight < AI_MD5_WEIGHT_EPSILON && weightDesc.mWeight >= -AI_MD5_WEIGHT_EPSILON) {
                         continue;
                     }
 
diff --git a/code/AssetLib/MDC/MDCFileData.h b/code/AssetLib/MDC/MDCFileData.h
index 616556f032..a8f3aea43f 100644
--- a/code/AssetLib/MDC/MDCFileData.h
+++ b/code/AssetLib/MDC/MDCFileData.h
@@ -120,13 +120,13 @@ struct Surface {
     , ulFlags()
     , ulNumCompFrames()
     , ulNumBaseFrames()
-    , ulNumShaders() 
+    , ulNumShaders()
     , ulNumVertices()
     , ulNumTriangles()
     , ulOffsetTriangles()
     , ulOffsetShaders()
     , ulOffsetTexCoords()
-    , ulOffsetBaseVerts() 
+    , ulOffsetBaseVerts()
     , ulOffsetCompVerts()
     , ulOffsetFrameBaseFrames()
     , ulOffsetFrameCompFrames()
diff --git a/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp b/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp
index e6576b344c..1ff86fe273 100644
--- a/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp
+++ b/code/AssetLib/MDL/HalfLife/HL1MDLLoader.cpp
@@ -629,7 +629,7 @@ void HL1MDLLoader::read_meshes() {
             +-- bodypart --+-- model -- [mesh index, mesh index, ...]
             |              |
             |              +-- model -- [mesh index, mesh index, ...]
-            |              |           
+            |              |
             |              ...
             |
             |-- bodypart -- ...
@@ -1298,7 +1298,7 @@ void HL1MDLLoader::read_global_info() {
 *   @note The structure of this method is taken from HL2 source code.
 *   Although this is from HL2, it's implementation is almost identical
 *   to code found in HL1 SDK. See HL1 and HL2 SDKs for more info.
-*   
+*
 *   source:
 *       HL1 source code.
 *           file: studio_render.cpp
diff --git a/code/AssetLib/MMD/MMDPmxParser.cpp b/code/AssetLib/MMD/MMDPmxParser.cpp
index d57dc169a8..82cc75ca29 100644
--- a/code/AssetLib/MMD/MMDPmxParser.cpp
+++ b/code/AssetLib/MMD/MMDPmxParser.cpp
@@ -102,7 +102,7 @@ namespace pmx
 			const unsigned int targetSize = size * 3; // enough to encode
 			char *targetStart = new char[targetSize];
             std::memset(targetStart, 0, targetSize * sizeof(char));
-            
+
             utf8::utf16to8( sourceStart, sourceStart + size/2, targetStart );
 
 			std::string result(targetStart);
diff --git a/code/AssetLib/OFF/OFFLoader.cpp b/code/AssetLib/OFF/OFFLoader.cpp
index 360ffc51bd..fb8f3b424e 100644
--- a/code/AssetLib/OFF/OFFLoader.cpp
+++ b/code/AssetLib/OFF/OFFLoader.cpp
@@ -138,7 +138,7 @@ void OFFImporter::InternReadFile( const std::string& pFile, aiScene* pScene, IOS
     const char* car = buffer;
     const char* end = buffer + mBuffer2.size();
     NextToken(&car, end);
-    
+
     if (car < end - 2 && car[0] == 'S' && car[1] == 'T') {
       hasTexCoord = true; car += 2;
     }
@@ -164,7 +164,7 @@ void OFFImporter::InternReadFile( const std::string& pFile, aiScene* pScene, IOS
       dimensions = 3;
       hasHomogenous = false;
       NextToken(&car, end);
-      
+
       // at this point the next token should be an integer number
       if (car >= end - 1 || *car < '0' || *car > '9') {
 	throw DeadlyImportError("OFF: Header is invalid");
@@ -223,7 +223,7 @@ void OFFImporter::InternReadFile( const std::string& pFile, aiScene* pScene, IOS
             ASSIMP_LOG_ERROR("OFF: The number of verts in the header is incorrect");
             break;
         }
-        aiVector3D& v = mesh->mVertices[i];	
+        aiVector3D& v = mesh->mVertices[i];
         sz = line;
 
 	// helper array to write a for loop over possible dimension values
@@ -255,7 +255,7 @@ void OFFImporter::InternReadFile( const std::string& pFile, aiScene* pScene, IOS
 	    SkipSpaces(&sz);
 	    fast_atoreal_move<ai_real>(sz,(ai_real&)n.z);
 	}
-	
+
 	// reading colors is a pain because the specification says it can be
 	// integers or floats, and any number of them between 1 and 4 included,
 	// until the next comment or end of line
@@ -321,7 +321,7 @@ void OFFImporter::InternReadFile( const std::string& pFile, aiScene* pScene, IOS
         ++i;
         ++faces;
     }
-    
+
     // generate the output node graph
     pScene->mRootNode = new aiNode();
     pScene->mRootNode->mName.Set("<OFFRoot>");
diff --git a/code/AssetLib/Obj/ObjExporter.h b/code/AssetLib/Obj/ObjExporter.h
index 3a46da7804..a64f38f740 100644
--- a/code/AssetLib/Obj/ObjExporter.h
+++ b/code/AssetLib/Obj/ObjExporter.h
@@ -67,7 +67,7 @@ class ObjExporter {
     ~ObjExporter();
     std::string GetMaterialLibName();
     std::string GetMaterialLibFileName();
-    
+
     /// public string-streams to write all output into
     std::ostringstream mOutput, mOutputMat;
 
@@ -137,13 +137,13 @@ class ObjExporter {
         }
     };
 
-    struct aiVectorCompare { 
-        bool operator() (const aiVector3D& a, const aiVector3D& b) const { 
-            if(a.x < b.x) return true; 
-            if(a.x > b.x) return false; 
-            if(a.y < b.y) return true; 
-            if(a.y > b.y) return false; 
-            if(a.z < b.z) return true; 
+    struct aiVectorCompare {
+        bool operator() (const aiVector3D& a, const aiVector3D& b) const {
+            if(a.x < b.x) return true;
+            if(a.x > b.x) return false;
+            if(a.y < b.y) return true;
+            if(a.y > b.y) return false;
+            if(a.z < b.z) return true;
             return false;
         }
     };
@@ -153,7 +153,7 @@ class ObjExporter {
         int mNextIndex;
         typedef std::map<T, int, Compare> dataType;
         dataType vecMap;
-    
+
     public:
         indexMap()
         : mNextIndex(1) {
diff --git a/code/AssetLib/Obj/ObjFileMtlImporter.cpp b/code/AssetLib/Obj/ObjFileMtlImporter.cpp
index bf1b70c906..94e57c26bc 100644
--- a/code/AssetLib/Obj/ObjFileMtlImporter.cpp
+++ b/code/AssetLib/Obj/ObjFileMtlImporter.cpp
@@ -146,7 +146,7 @@ void ObjFileMtlImporter::load() {
                     ++m_DataIt;
                     ai_real d;
                     getFloatValue(d);
-                    m_pModel->m_pCurrentMaterial->alpha = static_cast<ai_real>(1.0) - d;                    
+                    m_pModel->m_pCurrentMaterial->alpha = static_cast<ai_real>(1.0) - d;
                 }
                 m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
             } break;
diff --git a/code/AssetLib/SMD/SMDLoader.cpp b/code/AssetLib/SMD/SMDLoader.cpp
index de9c65c4ac..90f0b76978 100644
--- a/code/AssetLib/SMD/SMDLoader.cpp
+++ b/code/AssetLib/SMD/SMDLoader.cpp
@@ -438,7 +438,7 @@ void SMDImporter::AddBoneChildren(aiNode* pcNode, uint32_t iParent) {
             pc->mTransformation = bone.sAnim.asKeys[0].matrix;
         }
 
-        if (bone.iParent == static_cast<uint32_t>(-1)) { 
+        if (bone.iParent == static_cast<uint32_t>(-1)) {
             bone.mOffsetMatrix = pc->mTransformation;
         } else {
             bone.mOffsetMatrix = asBones[bone.iParent].mOffsetMatrix * pc->mTransformation;
diff --git a/code/AssetLib/STL/STLExporter.cpp b/code/AssetLib/STL/STLExporter.cpp
index bd4d96c71c..59c6148ee8 100644
--- a/code/AssetLib/STL/STLExporter.cpp
+++ b/code/AssetLib/STL/STLExporter.cpp
@@ -69,7 +69,7 @@ void ExportSceneSTL(const char* pFile,IOSystem* pIOSystem, const aiScene* pScene
     if (exporter.mOutput.fail()) {
         throw DeadlyExportError("output data creation failed. Most likely the file became too large: " + std::string(pFile));
     }
-    
+
     // we're still here - export successfully completed. Write the file.
     std::unique_ptr<IOStream> outfile (pIOSystem->Open(pFile,"wt"));
     if (outfile == nullptr) {
@@ -88,7 +88,7 @@ void ExportSceneSTLBinary(const char* pFile,IOSystem* pIOSystem, const aiScene*
     if (exporter.mOutput.fail()) {
         throw DeadlyExportError("output data creation failed. Most likely the file became too large: " + std::string(pFile));
     }
-    
+
     // we're still here - export successfully completed. Write the file.
     std::unique_ptr<IOStream> outfile (pIOSystem->Open(pFile,"wb"));
     if (outfile == nullptr) {
@@ -139,9 +139,9 @@ STLExporter::STLExporter(const char* _filename, const aiScene* pScene, bool expo
         if (exportPointClouds) {
             WritePointCloud("Assimp_Pointcloud", pScene );
             return;
-        } 
+        }
 
-        // Export the assimp mesh 
+        // Export the assimp mesh
         const std::string name = "AssimpScene";
         mOutput << SolidToken << " " << name << endl;
         for(unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
diff --git a/code/AssetLib/STL/STLLoader.cpp b/code/AssetLib/STL/STLLoader.cpp
index 433fb14c70..8cfe63e0d8 100644
--- a/code/AssetLib/STL/STLLoader.cpp
+++ b/code/AssetLib/STL/STLLoader.cpp
@@ -372,7 +372,7 @@ void STLImporter::LoadASCIIFile(aiNode *root) {
             pMesh->mVertices = new aiVector3D[pMesh->mNumVertices];
             for (size_t i=0; i<pMesh->mNumVertices; ++i ) {
                 pMesh->mVertices[i].x = positionBuffer[i].x;
-                pMesh->mVertices[i].y = positionBuffer[i].y;                
+                pMesh->mVertices[i].y = positionBuffer[i].y;
                 pMesh->mVertices[i].z = positionBuffer[i].z;
             }
             positionBuffer.clear();
@@ -382,7 +382,7 @@ void STLImporter::LoadASCIIFile(aiNode *root) {
             pMesh->mNormals = new aiVector3D[pMesh->mNumVertices];
             for (size_t i=0; i<pMesh->mNumVertices; ++i ) {
                 pMesh->mNormals[i].x = normalBuffer[i].x;
-                pMesh->mNormals[i].y = normalBuffer[i].y;                
+                pMesh->mNormals[i].y = normalBuffer[i].y;
                 pMesh->mNormals[i].z = normalBuffer[i].z;
             }
             normalBuffer.clear();
diff --git a/code/AssetLib/X/XFileExporter.cpp b/code/AssetLib/X/XFileExporter.cpp
index bd997a3c53..b95cb7abf3 100644
--- a/code/AssetLib/X/XFileExporter.cpp
+++ b/code/AssetLib/X/XFileExporter.cpp
@@ -86,7 +86,7 @@ void ExportSceneXFile(const char* pFile,IOSystem* pIOSystem, const aiScene* pSce
     if (iDoTheExportThing.mOutput.fail()) {
         throw DeadlyExportError("output data creation failed. Most likely the file became too large: " + std::string(pFile));
     }
-    
+
     // we're still here - export successfully completed. Write result to the given IOSYstem
     std::unique_ptr<IOStream> outfile (pIOSystem->Open(pFile,"wt"));
     if (outfile == nullptr) {
diff --git a/code/AssetLib/X/XFileExporter.h b/code/AssetLib/X/XFileExporter.h
index 32b75b3d19..620d282b69 100644
--- a/code/AssetLib/X/XFileExporter.h
+++ b/code/AssetLib/X/XFileExporter.h
@@ -94,9 +94,9 @@ class XFileExporter
     void PushTag() { startstr.append( "  "); }
 
     /// Leaves an element, decreasing the indentation
-    void PopTag() { 
-        ai_assert( startstr.length() > 1); 
-        startstr.erase( startstr.length() - 2); 
+    void PopTag() {
+        ai_assert( startstr.length() > 1);
+        startstr.erase( startstr.length() - 2);
     }
 
 public:
diff --git a/code/AssetLib/X3D/X3DImporter.cpp b/code/AssetLib/X3D/X3DImporter.cpp
index 121b7490ed..71c35c3699 100644
--- a/code/AssetLib/X3D/X3DImporter.cpp
+++ b/code/AssetLib/X3D/X3DImporter.cpp
@@ -180,6 +180,6 @@ const aiImporterDesc *X3DImporter::GetInfo() const {
     return &Description;
 }
 
-} 
+}
 
 #endif // !ASSIMP_BUILD_NO_X3D_IMPORTER
diff --git a/code/AssetLib/XGL/XGLLoader.cpp b/code/AssetLib/XGL/XGLLoader.cpp
index 3b84d7ba95..20c2c7079c 100644
--- a/code/AssetLib/XGL/XGLLoader.cpp
+++ b/code/AssetLib/XGL/XGLLoader.cpp
@@ -240,7 +240,7 @@ void XGLImporter::InternReadFile(const std::string &pFile, aiScene *pScene, IOSy
 void XGLImporter::ReadWorld(XmlNode &node, TempScope &scope) {
     for (XmlNode &currentNode : node.children()) {
         const std::string &s = ai_stdStrToLower(currentNode.name());
-        
+
 		// XXX right now we'd skip <lighting> if it comes after
 		// <object> or <mesh>
 		if (s == "lighting") {
diff --git a/code/AssetLib/glTF2/glTF2Asset.h b/code/AssetLib/glTF2/glTF2Asset.h
index bb97e37323..cd6c1c89d9 100644
--- a/code/AssetLib/glTF2/glTF2Asset.h
+++ b/code/AssetLib/glTF2/glTF2Asset.h
@@ -388,9 +388,9 @@ struct CustomExtension {
     }
 
     CustomExtension() = default;
-    
+
     ~CustomExtension() = default;
-    
+
     CustomExtension(const CustomExtension &other) :
             name(other.name),
             mStringValue(other.mStringValue),
diff --git a/code/AssetLib/glTF2/glTF2Asset.inl b/code/AssetLib/glTF2/glTF2Asset.inl
index 58095c7bdb..d5f5b5cd0b 100644
--- a/code/AssetLib/glTF2/glTF2Asset.inl
+++ b/code/AssetLib/glTF2/glTF2Asset.inl
@@ -410,14 +410,14 @@ inline void SetDecodedIndexBuffer_Draco(const draco::Mesh &dracoMesh, Mesh::Prim
 
     // Not same size, convert
     switch (componentBytes) {
-        case sizeof(uint32_t): 
-            CopyFaceIndex_Draco<uint32_t>(*decodedIndexBuffer, dracoMesh); 
+        case sizeof(uint32_t):
+            CopyFaceIndex_Draco<uint32_t>(*decodedIndexBuffer, dracoMesh);
             break;
-        case sizeof(uint16_t): 
-            CopyFaceIndex_Draco<uint16_t>(*decodedIndexBuffer, dracoMesh); 
+        case sizeof(uint16_t):
+            CopyFaceIndex_Draco<uint16_t>(*decodedIndexBuffer, dracoMesh);
             break;
-        case sizeof(uint8_t): 
-            CopyFaceIndex_Draco<uint8_t>(*decodedIndexBuffer, dracoMesh); 
+        case sizeof(uint8_t):
+            CopyFaceIndex_Draco<uint8_t>(*decodedIndexBuffer, dracoMesh);
             break;
         default:
             ai_assert(false);
@@ -460,23 +460,23 @@ inline void SetDecodedAttributeBuffer_Draco(const draco::Mesh &dracoMesh, uint32
     decodedAttribBuffer->Grow(dracoMesh.num_points() * pDracoAttribute->num_components() * componentBytes);
 
     switch (accessor.componentType) {
-        case ComponentType_BYTE: 
-            GetAttributeForAllPoints_Draco<int8_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+        case ComponentType_BYTE:
+            GetAttributeForAllPoints_Draco<int8_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
         case ComponentType_UNSIGNED_BYTE:
-            GetAttributeForAllPoints_Draco<uint8_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+            GetAttributeForAllPoints_Draco<uint8_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
         case ComponentType_SHORT:
             GetAttributeForAllPoints_Draco<int16_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
-        case ComponentType_UNSIGNED_SHORT: 
-            GetAttributeForAllPoints_Draco<uint16_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+        case ComponentType_UNSIGNED_SHORT:
+            GetAttributeForAllPoints_Draco<uint16_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
-        case ComponentType_UNSIGNED_INT: 
-            GetAttributeForAllPoints_Draco<uint32_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+        case ComponentType_UNSIGNED_INT:
+            GetAttributeForAllPoints_Draco<uint32_t>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
-        case ComponentType_FLOAT: 
-            GetAttributeForAllPoints_Draco<float>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer); 
+        case ComponentType_FLOAT:
+            GetAttributeForAllPoints_Draco<float>(dracoMesh, *pDracoAttribute, *decodedAttribBuffer);
             break;
         default:
             ai_assert(false);
@@ -840,7 +840,7 @@ inline bool Buffer::ReplaceData_joint(const size_t pBufferData_Offset, const siz
 
 inline size_t Buffer::AppendData(uint8_t *data, size_t length) {
     const size_t offset = this->byteLength;
-    
+
     // Force alignment to 4 bits
     const size_t paddedLength = (length + 3) & ~3;
     Grow(paddedLength);
diff --git a/code/AssetLib/glTF2/glTF2AssetWriter.inl b/code/AssetLib/glTF2/glTF2AssetWriter.inl
index bf7dbbb2eb..115cdf9033 100644
--- a/code/AssetLib/glTF2/glTF2AssetWriter.inl
+++ b/code/AssetLib/glTF2/glTF2AssetWriter.inl
@@ -452,7 +452,7 @@ namespace glTF2 {
             WriteTex(materialClearcoat, clearcoat.clearcoatTexture, "clearcoatTexture", w.mAl);
             WriteTex(materialClearcoat, clearcoat.clearcoatRoughnessTexture, "clearcoatRoughnessTexture", w.mAl);
             WriteTex(materialClearcoat, clearcoat.clearcoatNormalTexture, "clearcoatNormalTexture", w.mAl);
-                        
+
             if (!materialClearcoat.ObjectEmpty()) {
                 exts.AddMember("KHR_materials_clearcoat", materialClearcoat, w.mAl);
             }
@@ -468,7 +468,7 @@ namespace glTF2 {
             }
 
             WriteTex(materialTransmission, transmission.transmissionTexture, "transmissionTexture", w.mAl);
-                                   
+
             if (!materialTransmission.ObjectEmpty()) {
                 exts.AddMember("KHR_materials_transmission", materialTransmission, w.mAl);
             }
@@ -613,7 +613,7 @@ namespace glTF2 {
         if (n.skin) {
             obj.AddMember("skin", n.skin->index, w.mAl);
         }
-        
+
         //gltf2 spec does not support "skeletons" under node
         if(n.skeletons.size()) {
             AddRefsVector(obj, "skeletons", n.skeletons, w.mAl);
@@ -711,7 +711,7 @@ namespace glTF2 {
         if (mAsset.scene) {
             mDoc.AddMember("scene", mAsset.scene->index, mAl);
         }
-        
+
         if(mAsset.extras) {
             mDoc.AddMember("extras", *mAsset.extras, mAl);
         }
@@ -812,7 +812,7 @@ namespace glTF2 {
         uint32_t binaryChunkLength = 0;
         if (bodyBuffer->byteLength > 0) {
             binaryChunkLength = (bodyBuffer->byteLength + 3) & ~3; // Round up to next multiple of 4
-            
+
             auto curPaddingLength = binaryChunkLength - bodyBuffer->byteLength;
             ++GLB_Chunk_count;
 
@@ -881,7 +881,7 @@ namespace glTF2 {
             if (this->mAsset.extensionsUsed.KHR_materials_sheen) {
                 exts.PushBack(StringRef("KHR_materials_sheen"), mAl);
             }
-                        
+
             if (this->mAsset.extensionsUsed.KHR_materials_clearcoat) {
                 exts.PushBack(StringRef("KHR_materials_clearcoat"), mAl);
             }
@@ -893,7 +893,7 @@ namespace glTF2 {
             if (this->mAsset.extensionsUsed.FB_ngon_encoding) {
                 exts.PushBack(StringRef("FB_ngon_encoding"), mAl);
             }
-            
+
             if (this->mAsset.extensionsUsed.KHR_texture_basisu) {
                 exts.PushBack(StringRef("KHR_texture_basisu"), mAl);
             }
@@ -901,7 +901,7 @@ namespace glTF2 {
 
         if (!exts.Empty())
             mDoc.AddMember("extensionsUsed", exts, mAl);
-            
+
         //basisu extensionRequired
         Value extsReq;
         extsReq.SetArray();
diff --git a/code/Common/DefaultIOStream.cpp b/code/Common/DefaultIOStream.cpp
index ba9b9d625c..557fbc78f4 100644
--- a/code/Common/DefaultIOStream.cpp
+++ b/code/Common/DefaultIOStream.cpp
@@ -62,7 +62,7 @@ inline int select_fseek(FILE *file, int64_t offset, int origin) {
 }
 
 
-    
+
 #if defined _WIN32 && (!defined __GNUC__ || __MSVCRT_VERSION__ >= 0x0601)
 template <>
 inline size_t select_ftell<8>(FILE *file) {
@@ -75,7 +75,7 @@ inline int select_fseek<8>(FILE *file, int64_t offset, int origin) {
 }
 
 #endif // #if defined _WIN32 && (!defined __GNUC__ || __MSVCRT_VERSION__ >= 0x0601)
-    
+
 } // namespace
 
 // ----------------------------------------------------------------------------------
@@ -95,7 +95,7 @@ size_t DefaultIOStream::Read(void *pvBuffer,
     }
     ai_assert(nullptr != pvBuffer);
     ai_assert(0 != pSize);
-    
+
     return (mFile ? ::fread(pvBuffer, pSize, pCount, mFile) : 0);
 }
 
diff --git a/code/Common/DefaultIOSystem.cpp b/code/Common/DefaultIOSystem.cpp
index 98d51a17d1..1ed615b84e 100644
--- a/code/Common/DefaultIOSystem.cpp
+++ b/code/Common/DefaultIOSystem.cpp
@@ -71,7 +71,7 @@ static std::wstring Utf8ToWide(const char *in) {
     // size includes terminating null; std::wstring adds null automatically
     std::wstring out(static_cast<size_t>(size) - 1, L'\0');
     MultiByteToWideChar(CP_UTF8, 0, in, -1, &out[0], size);
-    
+
     return out;
 }
 
@@ -85,7 +85,7 @@ static std::string WideToUtf8(const wchar_t *in) {
     // size includes terminating null; std::string adds null automatically
     std::string out(static_cast<size_t>(size) - 1, '\0');
     WideCharToMultiByte(CP_UTF8, 0, in, -1, &out[0], size, nullptr, nullptr);
-    
+
     return out;
 }
 #endif
@@ -121,7 +121,7 @@ IOStream *DefaultIOSystem::Open(const char *strFile, const char *strMode) {
     if (name.empty()) {
         return nullptr;
     }
-    
+
     file = ::_wfopen(name.c_str(), Utf8ToWide(strMode).c_str());
 #else
     file = ::fopen(strFile, strMode);
diff --git a/code/Common/Exporter.cpp b/code/Common/Exporter.cpp
index ebcc955dff..512bbf4472 100644
--- a/code/Common/Exporter.cpp
+++ b/code/Common/Exporter.cpp
@@ -83,7 +83,7 @@ namespace Assimp {
 void GetPostProcessingStepInstanceList(std::vector< BaseProcess* >& out);
 
 // ------------------------------------------------------------------------------------------------
-// Exporter worker function prototypes. Do not use const, because some exporter need to convert 
+// Exporter worker function prototypes. Do not use const, because some exporter need to convert
 // the scene temporary
 #ifndef ASSIMP_BUILD_NO_COLLADA_EXPORTER
 void ExportSceneCollada(const char*,IOSystem*, const aiScene*, const ExportProperties*);
@@ -343,7 +343,7 @@ const aiExportDataBlob* Exporter::ExportToBlob( const aiScene* pScene, const cha
         delete pimpl->blob;
         pimpl->blob = nullptr;
     }
-    
+
     auto baseName = pProperties ? pProperties->GetPropertyString(AI_CONFIG_EXPORT_BLOB_NAME, AI_BLOBIO_MAGIC) : AI_BLOBIO_MAGIC;
 
     std::shared_ptr<IOSystem> old = pimpl->mIOSystem;
diff --git a/code/Common/FileSystemFilter.h b/code/Common/FileSystemFilter.h
index 6585f9df65..6782dd9e5c 100644
--- a/code/Common/FileSystemFilter.h
+++ b/code/Common/FileSystemFilter.h
@@ -101,7 +101,7 @@ class FileSystemFilter : public IOSystem
     /** Tests for the existence of a file at the given path. */
     bool Exists( const char* pFile) const {
         ai_assert( nullptr != mWrapped );
-        
+
         std::string tmp = pFile;
 
         // Currently this IOSystem is also used to open THE ONE FILE.
@@ -126,7 +126,7 @@ class FileSystemFilter : public IOSystem
         if ( nullptr == pFile || nullptr == pMode ) {
             return nullptr;
         }
-        
+
         ai_assert( nullptr != pFile );
         ai_assert( nullptr != pMode );
 
diff --git a/code/Common/Importer.cpp b/code/Common/Importer.cpp
index a2ad041fba..d0ed3c788d 100644
--- a/code/Common/Importer.cpp
+++ b/code/Common/Importer.cpp
@@ -201,7 +201,7 @@ Importer::~Importer() {
 // Register a custom post-processing step
 aiReturn Importer::RegisterPPStep(BaseProcess* pImp) {
     ai_assert( nullptr != pImp );
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
 
         pimpl->mPostProcessingSteps.push_back(pImp);
@@ -215,7 +215,7 @@ aiReturn Importer::RegisterPPStep(BaseProcess* pImp) {
 // Register a custom loader plugin
 aiReturn Importer::RegisterLoader(BaseImporter* pImp) {
     ai_assert(nullptr != pImp);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
 
     // --------------------------------------------------------------------
@@ -242,7 +242,7 @@ aiReturn Importer::RegisterLoader(BaseImporter* pImp) {
     pimpl->mImporter.push_back(pImp);
     ASSIMP_LOG_INFO("Registering custom importer for these file extensions: ", baked);
     ASSIMP_END_EXCEPTION_REGION(aiReturn);
-    
+
     return AI_SUCCESS;
 }
 
@@ -296,7 +296,7 @@ aiReturn Importer::UnregisterPPStep(BaseProcess* pImp) {
 // Supplies a custom IO handler to the importer to open and access files.
 void Importer::SetIOHandler( IOSystem* pIOHandler) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     // If the new handler is zero, allocate a default IO implementation.
     if (!pIOHandler) {
@@ -315,7 +315,7 @@ void Importer::SetIOHandler( IOSystem* pIOHandler) {
 // Get the currently set IO handler
 IOSystem* Importer::GetIOHandler() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mIOHandler;
 }
 
@@ -323,7 +323,7 @@ IOSystem* Importer::GetIOHandler() const {
 // Check whether a custom IO handler is currently set
 bool Importer::IsDefaultIOHandler() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mIsDefaultHandler;
 }
 
@@ -331,9 +331,9 @@ bool Importer::IsDefaultIOHandler() const {
 // Supplies a custom progress handler to get regular callbacks during importing
 void Importer::SetProgressHandler ( ProgressHandler* pHandler ) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
-    
+
     // If the new handler is zero, allocate a default implementation.
     if (!pHandler) {
         // Release pointer in the possession of the caller
@@ -351,7 +351,7 @@ void Importer::SetProgressHandler ( ProgressHandler* pHandler ) {
 // Get the currently set progress handler
 ProgressHandler* Importer::GetProgressHandler() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mProgressHandler;
 }
 
@@ -359,7 +359,7 @@ ProgressHandler* Importer::GetProgressHandler() const {
 // Check whether a custom progress handler is currently set
 bool Importer::IsDefaultProgressHandler() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mIsDefaultProgressHandler;
 }
 
@@ -381,7 +381,7 @@ bool _ValidateFlags(unsigned int pFlags) {
 // Free the current scene
 void Importer::FreeScene( ) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
 
     delete pimpl->mScene;
@@ -396,14 +396,14 @@ void Importer::FreeScene( ) {
 // Get the current error string, if any
 const char* Importer::GetErrorString() const {
     ai_assert(nullptr != pimpl);
-    
+
     // Must remain valid as long as ReadFile() or FreeFile() are not called
     return pimpl->mErrorString.c_str();
 }
 
 const std::exception_ptr& Importer::GetException() const {
     ai_assert(nullptr != pimpl);
-    
+
     // Must remain valid as long as ReadFile() or FreeFile() are not called
     return pimpl->mException;
 }
@@ -412,7 +412,7 @@ const std::exception_ptr& Importer::GetException() const {
 // Enable extra-verbose mode
 void Importer::SetExtraVerbose(bool bDo) {
     ai_assert(nullptr != pimpl);
-    
+
     pimpl->bExtraVerbose = bDo;
 }
 
@@ -420,7 +420,7 @@ void Importer::SetExtraVerbose(bool bDo) {
 // Get the current scene
 const aiScene* Importer::GetScene() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mScene;
 }
 
@@ -428,7 +428,7 @@ const aiScene* Importer::GetScene() const {
 // Orphan the current scene and return it.
 aiScene* Importer::GetOrphanedScene() {
     ai_assert(nullptr != pimpl);
-    
+
     aiScene* s = pimpl->mScene;
 
     ASSIMP_BEGIN_EXCEPTION_REGION();
@@ -437,7 +437,7 @@ aiScene* Importer::GetOrphanedScene() {
     pimpl->mErrorString = std::string();
     pimpl->mException = std::exception_ptr();
     ASSIMP_END_EXCEPTION_REGION(aiScene*);
-    
+
     return s;
 }
 
@@ -487,7 +487,7 @@ const aiScene* Importer::ReadFileFromMemory( const void* pBuffer,
     unsigned int pFlags,
     const char* pHint /*= ""*/) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     if (!pHint) {
         pHint = "";
@@ -518,7 +518,7 @@ const aiScene* Importer::ReadFileFromMemory( const void* pBuffer,
 
 // ------------------------------------------------------------------------------------------------
 void WriteLogOpening(const std::string& file) {
-    
+
     ASSIMP_LOG_INFO("Load ", file);
 
     // print a full version dump. This is nice because we don't
@@ -580,7 +580,7 @@ void WriteLogOpening(const std::string& file) {
 // Reads the given file and returns its contents if successful.
 const aiScene* Importer::ReadFile( const char* _pFile, unsigned int pFlags) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     const std::string pFile(_pFile);
 
@@ -745,7 +745,7 @@ const aiScene* Importer::ReadFile( const char* _pFile, unsigned int pFlags) {
 
     // either successful or failure - the pointer expresses it anyways
     ASSIMP_END_EXCEPTION_REGION_WITH_ERROR_STRING(const aiScene*, pimpl->mErrorString, pimpl->mException);
-    
+
     return pimpl->mScene;
 }
 
@@ -754,7 +754,7 @@ const aiScene* Importer::ReadFile( const char* _pFile, unsigned int pFlags) {
 // Apply post-processing to the currently bound scene
 const aiScene* Importer::ApplyPostProcessing(unsigned int pFlags) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     // Return immediately if no scene is active
     if (!pimpl->mScene) {
@@ -832,7 +832,7 @@ const aiScene* Importer::ApplyPostProcessing(unsigned int pFlags) {
         }
 #endif // ! DEBUG
     }
-    pimpl->mProgressHandler->UpdatePostProcess( static_cast<int>(pimpl->mPostProcessingSteps.size()), 
+    pimpl->mProgressHandler->UpdatePostProcess( static_cast<int>(pimpl->mPostProcessingSteps.size()),
         static_cast<int>(pimpl->mPostProcessingSteps.size()) );
 
     // update private scene flags
@@ -845,14 +845,14 @@ const aiScene* Importer::ApplyPostProcessing(unsigned int pFlags) {
     ASSIMP_LOG_INFO("Leaving post processing pipeline");
 
     ASSIMP_END_EXCEPTION_REGION(const aiScene*);
-    
+
     return pimpl->mScene;
 }
 
 // ------------------------------------------------------------------------------------------------
 const aiScene* Importer::ApplyCustomizedPostProcessing( BaseProcess *rootProcess, bool requestValidation ) {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
 
     // Return immediately if no scene is active
@@ -934,14 +934,14 @@ bool Importer::IsExtensionSupported(const char* szExtension) const {
 // ------------------------------------------------------------------------------------------------
 size_t Importer::GetImporterCount() const {
     ai_assert(nullptr != pimpl);
-    
+
     return pimpl->mImporter.size();
 }
 
 // ------------------------------------------------------------------------------------------------
 const aiImporterDesc* Importer::GetImporterInfo(size_t index) const {
     ai_assert(nullptr != pimpl);
-    
+
     if (index >= pimpl->mImporter.size()) {
         return nullptr;
     }
@@ -952,7 +952,7 @@ const aiImporterDesc* Importer::GetImporterInfo(size_t index) const {
 // ------------------------------------------------------------------------------------------------
 BaseImporter* Importer::GetImporter (size_t index) const {
     ai_assert(nullptr != pimpl);
-    
+
     if (index >= pimpl->mImporter.size()) {
         return nullptr;
     }
@@ -963,7 +963,7 @@ BaseImporter* Importer::GetImporter (size_t index) const {
 // Find a loader plugin for a given file extension
 BaseImporter* Importer::GetImporter (const char* szExtension) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetImporter(GetImporterIndex(szExtension));
 }
 
@@ -1002,7 +1002,7 @@ size_t Importer::GetImporterIndex (const char* szExtension) const {
 // Helper function to build a list of all file extensions supported by ASSIMP
 void Importer::GetExtensionList(aiString& szOut) const {
     ai_assert(nullptr != pimpl);
-    
+
     ASSIMP_BEGIN_EXCEPTION_REGION();
     std::set<std::string> str;
     for (std::vector<BaseImporter*>::const_iterator i =  pimpl->mImporter.begin();i != pimpl->mImporter.end();++i)  {
@@ -1028,7 +1028,7 @@ void Importer::GetExtensionList(aiString& szOut) const {
 // Set a configuration property
 bool Importer::SetPropertyInteger(const char* szName, int iValue) {
     ai_assert(nullptr != pimpl);
-    
+
     bool existing;
     ASSIMP_BEGIN_EXCEPTION_REGION();
         existing = SetGenericProperty<int>(pimpl->mIntProperties, szName,iValue);
@@ -1040,7 +1040,7 @@ bool Importer::SetPropertyInteger(const char* szName, int iValue) {
 // Set a configuration property
 bool Importer::SetPropertyFloat(const char* szName, ai_real iValue) {
     ai_assert(nullptr != pimpl);
-    
+
     bool existing;
     ASSIMP_BEGIN_EXCEPTION_REGION();
         existing = SetGenericProperty<ai_real>(pimpl->mFloatProperties, szName,iValue);
@@ -1052,7 +1052,7 @@ bool Importer::SetPropertyFloat(const char* szName, ai_real iValue) {
 // Set a configuration property
 bool Importer::SetPropertyString(const char* szName, const std::string& value) {
     ai_assert(nullptr != pimpl);
-    
+
     bool existing;
     ASSIMP_BEGIN_EXCEPTION_REGION();
         existing = SetGenericProperty<std::string>(pimpl->mStringProperties, szName,value);
@@ -1064,7 +1064,7 @@ bool Importer::SetPropertyString(const char* szName, const std::string& value) {
 // Set a configuration property
 bool Importer::SetPropertyMatrix(const char* szName, const aiMatrix4x4& value) {
     ai_assert(nullptr != pimpl);
-    
+
     bool existing;
     ASSIMP_BEGIN_EXCEPTION_REGION();
         existing = SetGenericProperty<aiMatrix4x4>(pimpl->mMatrixProperties, szName,value);
@@ -1076,7 +1076,7 @@ bool Importer::SetPropertyMatrix(const char* szName, const aiMatrix4x4& value) {
 // Get a configuration property
 int Importer::GetPropertyInteger(const char* szName, int iErrorReturn /*= 0xffffffff*/) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetGenericProperty<int>(pimpl->mIntProperties,szName,iErrorReturn);
 }
 
@@ -1084,7 +1084,7 @@ int Importer::GetPropertyInteger(const char* szName, int iErrorReturn /*= 0xffff
 // Get a configuration property
 ai_real Importer::GetPropertyFloat(const char* szName, ai_real iErrorReturn /*= 10e10*/) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetGenericProperty<ai_real>(pimpl->mFloatProperties,szName,iErrorReturn);
 }
 
@@ -1092,7 +1092,7 @@ ai_real Importer::GetPropertyFloat(const char* szName, ai_real iErrorReturn /*=
 // Get a configuration property
 std::string Importer::GetPropertyString(const char* szName, const std::string& iErrorReturn /*= ""*/) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetGenericProperty<std::string>(pimpl->mStringProperties,szName,iErrorReturn);
 }
 
@@ -1100,13 +1100,13 @@ std::string Importer::GetPropertyString(const char* szName, const std::string& i
 // Get a configuration property
 aiMatrix4x4 Importer::GetPropertyMatrix(const char* szName, const aiMatrix4x4& iErrorReturn /*= aiMatrix4x4()*/) const {
     ai_assert(nullptr != pimpl);
-    
+
     return GetGenericProperty<aiMatrix4x4>(pimpl->mMatrixProperties,szName,iErrorReturn);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Get the memory requirements of a single node
-inline 
+inline
 void AddNodeWeight(unsigned int& iScene,const aiNode* pcNode) {
     if ( nullptr == pcNode ) {
         return;
@@ -1124,7 +1124,7 @@ void AddNodeWeight(unsigned int& iScene,const aiNode* pcNode) {
 // Get the memory requirements of the scene
 void Importer::GetMemoryRequirements(aiMemoryInfo& in) const {
     ai_assert(nullptr != pimpl);
-    
+
     in = aiMemoryInfo();
     aiScene* mScene = pimpl->mScene;
 
diff --git a/code/Common/Importer.h b/code/Common/Importer.h
index e7da7f439a..0e04f94521 100644
--- a/code/Common/Importer.h
+++ b/code/Common/Importer.h
@@ -183,7 +183,7 @@ class ASSIMP_API BatchLoader {
 
     // -------------------------------------------------------------------
     /** Construct a batch loader from a given IO system to be used
-     *  to access external files 
+     *  to access external files
      */
     explicit BatchLoader(IOSystem* pIO, bool validate = false );
 
@@ -197,13 +197,13 @@ class ASSIMP_API BatchLoader {
      *  @param  enable  True for validation.
      */
     void setValidation( bool enabled );
-    
+
     // -------------------------------------------------------------------
     /** Returns the current validation step.
      *  @return The current validation step.
      */
     bool getValidation() const;
-    
+
     // -------------------------------------------------------------------
     /** Add a new file to the list of files to be loaded.
      *  @param file File to be loaded
diff --git a/code/Common/ImporterRegistry.cpp b/code/Common/ImporterRegistry.cpp
index ddfcf6798e..5df096166a 100644
--- a/code/Common/ImporterRegistry.cpp
+++ b/code/Common/ImporterRegistry.cpp
@@ -205,8 +205,8 @@ corresponding preprocessor flag to selectively disable formats.
 namespace Assimp {
 
 // ------------------------------------------------------------------------------------------------
-void GetImporterInstanceList(std::vector<BaseImporter *> &out) {    
-    
+void GetImporterInstanceList(std::vector<BaseImporter *> &out) {
+
     // Some importers may be unimplemented or otherwise unsuitable for general use
     // in their current state. Devs can set ASSIMP_ENABLE_DEV_IMPORTERS in their
     // local environment to enable them, otherwise they're left out of the registry.
diff --git a/code/Common/Win32DebugLogStream.h b/code/Common/Win32DebugLogStream.h
index 3385aa8ce3..51f1ab1780 100644
--- a/code/Common/Win32DebugLogStream.h
+++ b/code/Common/Win32DebugLogStream.h
@@ -71,19 +71,19 @@ class Win32DebugLogStream : public LogStream {
 };
 
 // ---------------------------------------------------------------------------
-inline 
-Win32DebugLogStream::Win32DebugLogStream(){ 
+inline
+Win32DebugLogStream::Win32DebugLogStream(){
     // empty
 }
 
 // ---------------------------------------------------------------------------
-inline 
+inline
 Win32DebugLogStream::~Win32DebugLogStream(){
     // empty
 }
 
 // ---------------------------------------------------------------------------
-inline 
+inline
 void Win32DebugLogStream::write(const char* message) {
     ::OutputDebugStringA( message);
 }
diff --git a/code/PostProcessing/ArmaturePopulate.h b/code/PostProcessing/ArmaturePopulate.h
index 08a72bd66c..ded8b4886b 100644
--- a/code/PostProcessing/ArmaturePopulate.h
+++ b/code/PostProcessing/ArmaturePopulate.h
@@ -97,7 +97,7 @@ class ASSIMP_API ArmaturePopulate : public BaseProcess {
 
     static void BuildBoneList(aiNode *current_node, const aiNode *root_node,
                                  const aiScene *scene,
-                                 std::vector<aiBone *> &bones);                        
+                                 std::vector<aiBone *> &bones);
 
     static void BuildBoneStack(aiNode *current_node, const aiNode *root_node,
                                   const aiScene *scene,
diff --git a/code/PostProcessing/DropFaceNormalsProcess.cpp b/code/PostProcessing/DropFaceNormalsProcess.cpp
index c01ac35e56..21abf96931 100644
--- a/code/PostProcessing/DropFaceNormalsProcess.cpp
+++ b/code/PostProcessing/DropFaceNormalsProcess.cpp
@@ -104,7 +104,7 @@ bool DropFaceNormalsProcess::DropMeshFaceNormals (aiMesh* mesh) {
     if (nullptr == mesh->mNormals) {
         return false;
     }
-    
+
     delete[] mesh->mNormals;
     mesh->mNormals = nullptr;
     return true;
diff --git a/code/PostProcessing/EmbedTexturesProcess.cpp b/code/PostProcessing/EmbedTexturesProcess.cpp
index 500032c39d..d7720de985 100644
--- a/code/PostProcessing/EmbedTexturesProcess.cpp
+++ b/code/PostProcessing/EmbedTexturesProcess.cpp
@@ -137,7 +137,7 @@ bool EmbedTexturesProcess::addTexture(aiScene *pScene, const std::string &path)
     pScene->mTextures = new aiTexture*[pScene->mNumTextures];
     ::memmove(pScene->mTextures, oldTextures, sizeof(aiTexture*) * (pScene->mNumTextures - 1u));
     delete [] oldTextures;
-    
+
     // Add the new texture
     auto pTexture = new aiTexture;
     pTexture->mHeight = 0; // Means that this is still compressed
diff --git a/code/PostProcessing/FindDegenerates.cpp b/code/PostProcessing/FindDegenerates.cpp
index eae91ff027..3809abf502 100644
--- a/code/PostProcessing/FindDegenerates.cpp
+++ b/code/PostProcessing/FindDegenerates.cpp
@@ -90,7 +90,7 @@ void FindDegeneratesProcess::Execute( aiScene* pScene) {
     if ( nullptr == pScene) {
         return;
     }
-    
+
     std::unordered_map<unsigned int, unsigned int> meshMap;
     meshMap.reserve(pScene->mNumMeshes);
 
diff --git a/code/PostProcessing/FindInstancesProcess.cpp b/code/PostProcessing/FindInstancesProcess.cpp
index ab5f52b789..d46afc2017 100644
--- a/code/PostProcessing/FindInstancesProcess.cpp
+++ b/code/PostProcessing/FindInstancesProcess.cpp
@@ -137,7 +137,7 @@ void FindInstancesProcess::Execute( aiScene* pScene)
             aiMesh* inst = pScene->mMeshes[i];
             hashes[i] = GetMeshHash(inst);
 
-            // Find an appropriate epsilon 
+            // Find an appropriate epsilon
             // to compare position differences against
             float epsilon = ComputePositionEpsilon(inst);
             epsilon *= epsilon;
diff --git a/code/PostProcessing/MakeVerboseFormat.h b/code/PostProcessing/MakeVerboseFormat.h
index c1db76dca9..4304a3afa5 100644
--- a/code/PostProcessing/MakeVerboseFormat.h
+++ b/code/PostProcessing/MakeVerboseFormat.h
@@ -98,7 +98,7 @@ class ASSIMP_API_WINONLY MakeVerboseFormatProcess : public BaseProcess
 
     // -------------------------------------------------------------------
     /** Checks whether the scene is already in verbose format.
-    * @param pScene The data to check. 
+    * @param pScene The data to check.
     * @return true if the scene is already in verbose format. */
     static bool IsVerboseFormat(const aiScene* pScene);
 
diff --git a/code/PostProcessing/RemoveRedundantMaterials.cpp b/code/PostProcessing/RemoveRedundantMaterials.cpp
index c252f37a5a..36745fb1dd 100644
--- a/code/PostProcessing/RemoveRedundantMaterials.cpp
+++ b/code/PostProcessing/RemoveRedundantMaterials.cpp
@@ -215,7 +215,7 @@ void RemoveRedundantMatsProcess::Execute( aiScene* pScene)
     }
     else
     {
-        ASSIMP_LOG_INFO("RemoveRedundantMatsProcess finished. Removed ", redundantRemoved, " redundant and ", 
+        ASSIMP_LOG_INFO("RemoveRedundantMatsProcess finished. Removed ", redundantRemoved, " redundant and ",
             unreferencedRemoved, " unused materials.");
     }
 }
diff --git a/code/PostProcessing/ScaleProcess.cpp b/code/PostProcessing/ScaleProcess.cpp
index 0a3e29c42d..63dd0443dc 100644
--- a/code/PostProcessing/ScaleProcess.cpp
+++ b/code/PostProcessing/ScaleProcess.cpp
@@ -75,7 +75,7 @@ void ScaleProcess::SetupProperties( const Importer* pImp ) {
     // File scaling * Application Scaling
     float importerScale = pImp->GetPropertyFloat( AI_CONFIG_APP_SCALE_KEY, 1.0f );
 
-    // apply scale to the scale 
+    // apply scale to the scale
     // helps prevent bugs with backward compatibility for anyone using normal scaling.
     mScale *= importerScale;
 }
@@ -84,7 +84,7 @@ void ScaleProcess::Execute( aiScene* pScene ) {
     if(mScale == 1.0f)  {
         return; // nothing to scale
     }
-    
+
     ai_assert( mScale != 0 );
     ai_assert( nullptr != pScene );
     ai_assert( nullptr != pScene->mRootNode );
@@ -96,7 +96,7 @@ void ScaleProcess::Execute( aiScene* pScene ) {
     if ( nullptr == pScene->mRootNode ) {
         return;
     }
-    
+
     // Process animations and update position transform to new unit system
     for( unsigned int animationID = 0; animationID < pScene->mNumAnimations; animationID++ )
     {
@@ -105,7 +105,7 @@ void ScaleProcess::Execute( aiScene* pScene ) {
         for( unsigned int animationChannel = 0; animationChannel < animation->mNumChannels; animationChannel++)
         {
             aiNodeAnim* anim = animation->mChannels[animationChannel];
-            
+
             for( unsigned int posKey = 0; posKey < anim->mNumPositionKeys; posKey++)
             {
                 aiVectorKey& vectorKey = anim->mPositionKeys[posKey];
@@ -116,8 +116,8 @@ void ScaleProcess::Execute( aiScene* pScene ) {
 
     for( unsigned int meshID = 0; meshID < pScene->mNumMeshes; meshID++)
     {
-        aiMesh *mesh = pScene->mMeshes[meshID]; 
-        
+        aiMesh *mesh = pScene->mMeshes[meshID];
+
         // Reconstruct mesh vertexes to the new unit system
         for( unsigned int vertexID = 0; vertexID < mesh->mNumVertices; vertexID++)
         {
@@ -129,9 +129,9 @@ void ScaleProcess::Execute( aiScene* pScene ) {
         // bone placement / scaling
         for( unsigned int boneID = 0; boneID < mesh->mNumBones; boneID++)
         {
-            // Reconstruct matrix by transform rather than by scale 
+            // Reconstruct matrix by transform rather than by scale
             // This prevent scale values being changed which can
-            // be meaningful in some cases 
+            // be meaningful in some cases
             // like when you want the modeller to see 1:1 compatibility.
             aiBone* bone = mesh->mBones[boneID];
 
@@ -139,10 +139,10 @@ void ScaleProcess::Execute( aiScene* pScene ) {
             aiQuaternion rotation;
 
             bone->mOffsetMatrix.Decompose( scale, rotation, pos);
-            
+
             aiMatrix4x4 translation;
             aiMatrix4x4::Translation( pos * mScale, translation );
-            
+
             aiMatrix4x4 scaling;
             aiMatrix4x4::Scaling( aiVector3D(scale), scaling );
 
@@ -157,7 +157,7 @@ void ScaleProcess::Execute( aiScene* pScene ) {
         for( unsigned int animMeshID = 0; animMeshID < mesh->mNumAnimMeshes; animMeshID++)
         {
             aiAnimMesh * animMesh = mesh->mAnimMeshes[animMeshID];
-            
+
             for( unsigned int vertexID = 0; vertexID < animMesh->mNumVertices; vertexID++)
             {
                 aiVector3D& vertex = animMesh->mVertices[vertexID];
@@ -169,31 +169,31 @@ void ScaleProcess::Execute( aiScene* pScene ) {
     traverseNodes( pScene->mRootNode );
 }
 
-void ScaleProcess::traverseNodes( aiNode *node, unsigned int nested_node_id ) {    
+void ScaleProcess::traverseNodes( aiNode *node, unsigned int nested_node_id ) {
     applyScaling( node );
 
     for( size_t i = 0; i < node->mNumChildren; i++)
     {
         // recurse into the tree until we are done!
-        traverseNodes( node->mChildren[i], nested_node_id+1 ); 
+        traverseNodes( node->mChildren[i], nested_node_id+1 );
     }
 }
 
 void ScaleProcess::applyScaling( aiNode *currentNode ) {
     if ( nullptr != currentNode ) {
-        // Reconstruct matrix by transform rather than by scale 
+        // Reconstruct matrix by transform rather than by scale
         // This prevent scale values being changed which can
-        // be meaningful in some cases 
-        // like when you want the modeller to 
+        // be meaningful in some cases
+        // like when you want the modeller to
         // see 1:1 compatibility.
-        
+
         aiVector3D pos, scale;
         aiQuaternion rotation;
         currentNode->mTransformation.Decompose( scale, rotation, pos);
-        
+
         aiMatrix4x4 translation;
         aiMatrix4x4::Translation( pos * mScale, translation );
-        
+
         aiMatrix4x4 scaling;
 
         // note: we do not use mScale here, this is on purpose.
diff --git a/code/PostProcessing/ScaleProcess.h b/code/PostProcessing/ScaleProcess.h
index d88490b1cf..4dc7e35598 100644
--- a/code/PostProcessing/ScaleProcess.h
+++ b/code/PostProcessing/ScaleProcess.h
@@ -55,8 +55,8 @@ namespace Assimp {
 // ---------------------------------------------------------------------------
 /** ScaleProcess: Class to rescale the whole model.
  * Now rescales animations, bones, and blend shapes properly.
- * Please note this will not write to 'scale' transform it will rewrite mesh 
- * and matrixes so that your scale values 
+ * Please note this will not write to 'scale' transform it will rewrite mesh
+ * and matrixes so that your scale values
  * from your model package are preserved, so this is completely intentional
  * bugs should be reported as soon as they are found.
 */
diff --git a/code/PostProcessing/SplitByBoneCountProcess.cpp b/code/PostProcessing/SplitByBoneCountProcess.cpp
index 2613d85613..ed5b9411e0 100644
--- a/code/PostProcessing/SplitByBoneCountProcess.cpp
+++ b/code/PostProcessing/SplitByBoneCountProcess.cpp
@@ -209,7 +209,7 @@ void SplitByBoneCountProcess::SplitMesh( const aiMesh* pMesh, std::vector<aiMesh
             // a small local set of new bones for the current face. State of all used bones for that face
             // can only be updated AFTER the face is completely analysed. Thanks to imre for the fix.
             std::set<unsigned int> newBonesAtCurrentFace;
-          
+
             const aiFace& face = pMesh->mFaces[a];
             // check every vertex if its bones would still fit into the current submesh
             for( unsigned int b = 0; b < face.mNumIndices; ++b )
@@ -221,7 +221,7 @@ void SplitByBoneCountProcess::SplitMesh( const aiMesh* pMesh, std::vector<aiMesh
                 if( !isBoneUsed[boneIndex] )
                 {
                   newBonesAtCurrentFace.insert(boneIndex);
-                }   
+                }
               }
             }
 
@@ -412,7 +412,7 @@ void SplitByBoneCountProcess::SplitMesh( const aiMesh* pMesh, std::vector<aiMesh
         if (pMesh->mNumAnimMeshes > 0) {
             newMesh->mNumAnimMeshes = pMesh->mNumAnimMeshes;
             newMesh->mAnimMeshes = new aiAnimMesh*[newMesh->mNumAnimMeshes];
-            
+
             for (unsigned int morphIdx = 0; morphIdx < newMesh->mNumAnimMeshes; ++morphIdx) {
                 aiAnimMesh* origTarget = pMesh->mAnimMeshes[morphIdx];
                 aiAnimMesh* newTarget = new aiAnimMesh;
@@ -421,16 +421,16 @@ void SplitByBoneCountProcess::SplitMesh( const aiMesh* pMesh, std::vector<aiMesh
                 newTarget->mNumVertices = numSubMeshVertices;
                 newTarget->mVertices = new aiVector3D[numSubMeshVertices];
                 newMesh->mAnimMeshes[morphIdx] = newTarget;
-                
+
                 if (origTarget->HasNormals()) {
                     newTarget->mNormals = new aiVector3D[numSubMeshVertices];
                 }
-                
+
                 if (origTarget->HasTangentsAndBitangents()) {
                     newTarget->mTangents = new aiVector3D[numSubMeshVertices];
                     newTarget->mBitangents = new aiVector3D[numSubMeshVertices];
                 }
-                
+
                 for( unsigned int vi = 0; vi < numSubMeshVertices; ++vi) {
                     // find the source vertex for it in the source mesh
                     unsigned int previousIndex = previousVertexIndices[vi];
diff --git a/code/PostProcessing/SplitLargeMeshes.cpp b/code/PostProcessing/SplitLargeMeshes.cpp
index ed680cf7fd..cb614edaa3 100644
--- a/code/PostProcessing/SplitLargeMeshes.cpp
+++ b/code/PostProcessing/SplitLargeMeshes.cpp
@@ -40,7 +40,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ----------------------------------------------------------------------
 */
 
-/** 
+/**
  *  @file Implementation of the SplitLargeMeshes postprocessing step
  */
 
@@ -353,7 +353,7 @@ void SplitLargeMeshesProcess_Vertex::Execute( aiScene* pScene) {
 
     std::vector<std::pair<aiMesh*, unsigned int> > avList;
 
-    //Check for point cloud first, 
+    //Check for point cloud first,
     //Do not process point cloud, splitMesh works only with faces data
     for (unsigned int a = 0; a < pScene->mNumMeshes; a++) {
         if ( pScene->mMeshes[a]->mPrimitiveTypes == aiPrimitiveType_POINT ) {
diff --git a/code/PostProcessing/TextureTransform.cpp b/code/PostProcessing/TextureTransform.cpp
index 681b047c03..74b00d92cc 100644
--- a/code/PostProcessing/TextureTransform.cpp
+++ b/code/PostProcessing/TextureTransform.cpp
@@ -448,7 +448,7 @@ void TextureTransformStep::Execute( aiScene* pScene)
         if (size > AI_MAX_NUMBER_OF_TEXTURECOORDS) {
 
             if (!DefaultLogger::isNullLogger()) {
-                ASSIMP_LOG_ERROR(static_cast<unsigned int>(trafo.size()), " UV channels required but just ", 
+                ASSIMP_LOG_ERROR(static_cast<unsigned int>(trafo.size()), " UV channels required but just ",
                     AI_MAX_NUMBER_OF_TEXTURECOORDS, " available");
             }
             size = AI_MAX_NUMBER_OF_TEXTURECOORDS;
diff --git a/code/PostProcessing/TriangulateProcess.cpp b/code/PostProcessing/TriangulateProcess.cpp
index 0f71320b8a..b7928ee59b 100644
--- a/code/PostProcessing/TriangulateProcess.cpp
+++ b/code/PostProcessing/TriangulateProcess.cpp
@@ -86,11 +86,11 @@ namespace {
 
         /**
          * @brief Encode the current triangle, and make sure it is recognized as a triangle.
-         * 
+         *
          * This method will rotate indices in tri if needed in order to avoid tri to be considered
          * part of the previous ngon. This method is to be used whenever you want to emit a real triangle,
          * and make sure it is seen as a triangle.
-         * 
+         *
          * @param tri Triangle to encode.
          */
         void ngonEncodeTriangle(aiFace * tri) {
@@ -108,10 +108,10 @@ namespace {
 
         /**
          * @brief Encode a quad (2 triangles) in ngon encoding, and make sure they are seen as a single ngon.
-         * 
+         *
          * @param tri1 First quad triangle
          * @param tri2 Second quad triangle
-         * 
+         *
          * @pre Triangles must be properly fanned from the most appropriate vertex.
          */
         void ngonEncodeQuad(aiFace *tri1, aiFace *tri2) {
@@ -140,7 +140,7 @@ namespace {
 
         /**
          * @brief Check whether this triangle would be considered part of the lastly emitted ngon or not.
-         * 
+         *
          * @param tri Current triangle.
          * @return true If used as is, this triangle will be part of last ngon.
          * @return false If used as is, this triangle is not considered part of the last ngon.
@@ -512,7 +512,7 @@ bool TriangulateProcess::TriangulateMesh( aiMesh* pMesh)
                     num = 0;
                     break;
 
-                    /*curOut -= (max-num); // undo all previous work 
+                    /*curOut -= (max-num); // undo all previous work
                     for (tmp = 0; tmp < max-2; ++tmp) {
                         aiFace& nface = *curOut++;
 
diff --git a/doc/dox.h b/doc/dox.h
index a4516dc7ad..409e775d41 100644
--- a/doc/dox.h
+++ b/doc/dox.h
@@ -90,8 +90,8 @@ but not all of them are *open-source*. If there's an accompagning '<file>\source
 @section main_install Installation
 
 assimp can be used in two ways: linking against the pre-built libraries or building the library on your own. The former
-option is the easiest, but the assimp distribution contains pre-built libraries only for Visual C++ 2013, 2015 and 2017. 
-For other compilers you'll have to build assimp for yourself. Which is hopefully as hassle-free as the other way, but 
+option is the easiest, but the assimp distribution contains pre-built libraries only for Visual C++ 2013, 2015 and 2017.
+For other compilers you'll have to build assimp for yourself. Which is hopefully as hassle-free as the other way, but
 needs a bit more work. Both ways are described at the @link install Installation page. @endlink
 If you want to use assimp on Ubuntu you can install it via the following command:
 
@@ -145,7 +145,7 @@ to your include paths (Menu-&gt;Extras-&gt;Options-&gt;Projects and Solutions-&g
 and the assimp/lib/&lt;Compiler&gt; path to your linker paths (Menu-&gt;Extras-&gt;Options-&gt;Projects and Solutions-&gt;VC++ Directories-&gt;Library files).
 This is necessary only once to setup all paths inside you IDE.
 
-To use the library in your C++ project you can simply generate a project file via cmake. One way is to add the assimp-folder 
+To use the library in your C++ project you can simply generate a project file via cmake. One way is to add the assimp-folder
 as a subdirectory via the cmake-command
 
 @code
@@ -158,7 +158,7 @@ Now just add the assimp-dependency to your application:
 TARGET_LINK_LIBRARIES(my_game assimp)
 @endcode
 
-If done correctly you should now be able to compile, link, run and use the application. 
+If done correctly you should now be able to compile, link, run and use the application.
 
 
 @section install_own Building the library from scratch
@@ -170,7 +170,7 @@ to build the library just open a command-prompt / bash, navigate into the repo-f
 cmake CMakeLists.txt
 @endcode
 
-A project-file of your default make-system ( like gnu-make on linux or Visual-Studio on Windows ) will be generated. 
+A project-file of your default make-system ( like gnu-make on linux or Visual-Studio on Windows ) will be generated.
 Run the build and you are done. You can find the libs at assimp/lib and the dll's / so's at bin.
 
 @section assimp_dll Windows DLL Build
@@ -496,10 +496,10 @@ X3  Y3  Z3  T3
 @endcode
 with <tt>(X1, X2, X3)</tt> being the local X base vector, <tt>(Y1, Y2, Y3)</tt> being the local
 Y base vector, <tt>(Z1, Z2, Z3)</tt> being the local Z base vector and <tt>(T1, T2, T3)</tt> being the
-offset of the local origin (the translational part). 
+offset of the local origin (the translational part).
 All matrices in the library use row-major storage order. That means that the matrix elements are
-stored row-by-row, i.e. they end up like this in memory: 
-<tt>[X1, Y1, Z1, T1, X2, Y2, Z2, T2, X3, Y3, Z3, T3, 0, 0, 0, 1]</tt>. 
+stored row-by-row, i.e. they end up like this in memory:
+<tt>[X1, Y1, Z1, T1, X2, Y2, Z2, T2, X3, Y3, Z3, T3, 0, 0, 0, 1]</tt>.
 
 Note that this is neither the OpenGL format nor the DirectX format, because both of them specify the
 matrix layout such that the translational part occupies three consecutive addresses in memory (so those
@@ -1498,7 +1498,7 @@ Just copy'n'paste the template from Appendix A and adapt it for your needs.
 with DefaultLogger::get()->[error, warn, debug, info].
 </li>
 <li>
-Make sure that your loader compiles against all build configurations on all supported platforms. You can use our CI-build to check several platforms 
+Make sure that your loader compiles against all build configurations on all supported platforms. You can use our CI-build to check several platforms
 like Windows and Linux ( 32 bit and 64 bit ).
 </li>
 <li>
diff --git a/doc/dox_cmd.h b/doc/dox_cmd.h
index 78e755d56d..79ea3a861f 100644
--- a/doc/dox_cmd.h
+++ b/doc/dox_cmd.h
@@ -12,7 +12,7 @@
 
 @section intro Introduction
 
-This document describes the usage of assimp's command line tools. 
+This document describes the usage of assimp's command line tools.
 This is *not* the SDK reference and programming-related stuff is not covered here.
 <br><br>
 <b>NOTE</b>: For simplicity, the following sections are written with Windows in mind. However
@@ -29,7 +29,7 @@ assimp [command] [parameters]
 The following commands are available:
 
 <table border="1">
- 
+
   <tr>
     <td><b>@link version version @endlink</b></td>
     <td>Retrieve the current version of assimp</td>
@@ -184,7 +184,7 @@ Generate a text or binary dump of a model. This is the core component of Assimp'
 regression test suite but it could also be useful for other developers to quickly
 examine the contents of a model. Note that text dumps are not intended to be used as
 intermediate format, Assimp is not able to read them again, nor is the file format
-stable or well-defined. It may change with every revision without notice. 
+stable or well-defined. It may change with every revision without notice.
 Binary dumps (*.assbin) are backwards- and forwards-compatible.
 
 <h3>Syntax:</h3>
@@ -199,7 +199,7 @@ assimp dump <model> [<out>] [-b] [-s] [common parameters]
 <p>
 <tt>
 model<br></tt><br>
-Required. Relative or absolute path to the input model. 
+Required. Relative or absolute path to the input model.
 </p>
 <p>
 <tt>
@@ -220,7 +220,7 @@ The long form of this parameter is <tt>--binary</tt>.
 </tt><br>
 Optional. If this switch is specified, the dump is shortened to include only
 min/max values for all vertex components and animation channels. The resulting
-file is much smaller, but the original model can't be reconstructed from it. This is 
+file is much smaller, but the original model can't be reconstructed from it. This is
 used by Assimp's regression test suite, comparing those minidumps provides
 a fast way to verify whether a loader works correctly or not.
 The long form of this parameter is <tt>--short</tt>.
@@ -229,7 +229,7 @@ The long form of this parameter is <tt>--short</tt>.
 <p>
 <tt>
 common parameters<br></tt><br>
-Optional. Import configuration & postprocessing. 
+Optional. Import configuration & postprocessing.
 See the @link common common parameters page @endlink for more information.
 </p>
 
@@ -248,7 +248,7 @@ The log output is included with the dump.
 
 @code
 assimp dump files\*.*
-assimp dump files\*.* 
+assimp dump files\*.*
 @endcode
 
 Dumps all loadable model files in the 'files' subdir. The output dumps are named
@@ -275,14 +275,14 @@ assimp extract <model> [<out>] [-t<n>] [-f<fmt>] [-ba] [-s] [common parameters]
 <p>
 <tt>
 model<br></tt><br>
-Required. Relative or absolute path to the input model. 
+Required. Relative or absolute path to the input model.
 </p>
 <p>
 <tt>
 out<br></tt><br>
 Optional. Relative or absolute path to write the output images to. If the file name is
 omitted the output images are named <tt><model-filename></tt><br>
-The suffix <tt>_img&lt;n&gt;</tt> is appended to the file name if the -s switch is not specified 
+The suffix <tt>_img&lt;n&gt;</tt> is appended to the file name if the -s switch is not specified
 (where <tt>&lt;n&gt;</tt> is the zero-based index of the texture in the model file).<br>
 
 The output file format is determined from the given file extension. Supported
@@ -296,7 +296,7 @@ written in their native file format (e.g. jpg).
 <p>
 <tt>-t&lt;n&gt;<br>
 </tt><br>
-Optional. Specifies the (zero-based) index of the embedded texture to be extracted from 
+Optional. Specifies the (zero-based) index of the embedded texture to be extracted from
 the model. If this option is *not* specified all textures found are exported.
 The long form of this parameter is <tt>--texture=&lt;n&gt;</tt>.
 </p>
@@ -348,8 +348,8 @@ imported data structure and writes it to <tt>test_img0.bmp</tt>.
 
 
 @code
-assimp extract files\*.mdl *.bmp 
-assimp extract files\*.mdl *.bmp 
+assimp extract files\*.mdl *.bmp
+assimp extract files\*.mdl *.bmp
 @endcode
 
 Extracts all embedded textures from all loadable .mdl files in the 'files' subdirectory
@@ -361,10 +361,10 @@ and writes them to bitmaps which are named <tt><model-file>_img<image-index>.bmp
 /**
 @page common Common parameters
 
-The parameters described on this page are commonly used by almost every assimp command. They 
+The parameters described on this page are commonly used by almost every assimp command. They
 specify how the library will postprocess the imported data. This is done by several
 configurable pipeline stages, called 'post processing steps'. Below you can find a list
-of all supported steps along with short descriptions of what they're doing. <br><b>Programmers</b>: 
+of all supported steps along with short descriptions of what they're doing. <br><b>Programmers</b>:
 more information can be found in the <tt>aiPostProcess.h</tt> header.
 
 <table border="1">
@@ -376,7 +376,7 @@ more information can be found in the <tt>aiPostProcess.h</tt> header.
   <tr>
     <td><tt>-ptv</tt></td>
     <td><tt>--pretransform-vertices</tt></td>
-	<td>Move all vertices into worldspace and collapse the scene graph. Animation data is lost. 
+	<td>Move all vertices into worldspace and collapse the scene graph. Animation data is lost.
 	This is intended for applications which don't support scenegraph-oriented rendering.</td>
   </tr>
   <tr>
@@ -428,7 +428,7 @@ more information can be found in the <tt>aiPostProcess.h</tt> header.
    <tr>
     <td><tt>-icl</tt></td>
     <td><tt>--improve-cache-locality</tt></td>
-	<td>Improve the cache locality of the vertex buffer by reordering the index buffer 
+	<td>Improve the cache locality of the vertex buffer by reordering the index buffer
 	to achieve a lower ACMR (average post-transform vertex cache miss ratio)</td>
   </tr>
   <tr>
@@ -515,7 +515,7 @@ For convenience some default postprocessing configurations are provided.
 The corresponding command line parameter is <tt>-c&lt;name&gt;</tt> (or <tt>--config=&lt;name&gt;</tt>).
 
 <table border="1">
- 
+
   <tr>
     <th>Name</th>
     <th>Description</th>
@@ -543,7 +543,7 @@ The corresponding command line parameter is <tt>-c&lt;name&gt;</tt> (or <tt>--co
 There are also some common flags to customize Assimp's logging behaviour:
 
 <table border="1">
- 
+
   <tr>
     <th>Name</th>
     <th>Description</th>
@@ -558,7 +558,7 @@ There are also some common flags to customize Assimp's logging behaviour:
   </tr>
     <tr>
     <td><tt>-v</tt> or <tt>--verbose</tt></td>
-    <td>Enables verbose logging. Debug messages will be produced too. This might 
+    <td>Enables verbose logging. Debug messages will be produced too. This might
 	decrease loading performance and result in *very* long logs ... use with caution if you experience strange issues.</td>
   </tr>
  </table>
diff --git a/fuzz/assimp_fuzzer.cc b/fuzz/assimp_fuzzer.cc
index b65ee02368..33748c10f1 100644
--- a/fuzz/assimp_fuzzer.cc
+++ b/fuzz/assimp_fuzzer.cc
@@ -54,6 +54,6 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t dataSize) {
         aiProcessPreset_TargetRealtime_Quality, nullptr );
 
     aiDetachLogStream(&stream);
-    
+
     return 0;
 }
diff --git a/include/assimp/BaseImporter.h b/include/assimp/BaseImporter.h
index 38bec1afd1..54b5daac12 100644
--- a/include/assimp/BaseImporter.h
+++ b/include/assimp/BaseImporter.h
@@ -154,7 +154,7 @@ class ASSIMP_API BaseImporter {
     /** Returns the exception of the last exception that occurred.
      * Note: Exceptions are not the only source of error details, so GetErrorText
      * should be consulted too.
-     * @return The last exception that occurred. 
+     * @return The last exception that occurred.
      */
     const std::exception_ptr& GetException() const {
         return m_Exception;
diff --git a/include/assimp/Compiler/poppack1.h b/include/assimp/Compiler/poppack1.h
index a8e9a3c7ec..ff501bc0cd 100644
--- a/include/assimp/Compiler/poppack1.h
+++ b/include/assimp/Compiler/poppack1.h
@@ -1,7 +1,7 @@
 
 // ===============================================================================
-// May be included multiple times - resets structure packing to the defaults 
-// for all supported compilers. Reverts the changes made by #include <pushpack1.h> 
+// May be included multiple times - resets structure packing to the defaults
+// for all supported compilers. Reverts the changes made by #include <pushpack1.h>
 //
 // Currently this works on the following compilers:
 // MSVC 7,8,9
diff --git a/include/assimp/Compiler/pushpack1.h b/include/assimp/Compiler/pushpack1.h
index 2a5e2dfe6f..b32ed172cc 100644
--- a/include/assimp/Compiler/pushpack1.h
+++ b/include/assimp/Compiler/pushpack1.h
@@ -1,7 +1,7 @@
 
 
 // ===============================================================================
-// May be included multiple times - sets structure packing to 1 
+// May be included multiple times - sets structure packing to 1
 // for all supported compilers. #include <poppack1.h> reverts the changes.
 //
 // Currently this works on the following compilers:
@@ -37,7 +37,7 @@
 
 #if defined(_MSC_VER)
 // C4103: Packing was changed after the inclusion of the header, probably missing #pragma pop
-#	pragma warning (disable : 4103) 
+#	pragma warning (disable : 4103)
 #endif
 
 #define AI_PUSHPACK_IS_DEFINED
diff --git a/include/assimp/Exceptional.h b/include/assimp/Exceptional.h
index 98e2a33216..1bf399cbcd 100644
--- a/include/assimp/Exceptional.h
+++ b/include/assimp/Exceptional.h
@@ -59,7 +59,7 @@ using std::runtime_error;
 class ASSIMP_API DeadlyErrorBase : public runtime_error {
 protected:
     DeadlyErrorBase(Assimp::Formatter::format f);
-    
+
     template<typename... T, typename U>
     DeadlyErrorBase(Assimp::Formatter::format f, U&& u, T&&... args) :
             DeadlyErrorBase(std::move(f << std::forward<U>(u)), std::forward<T>(args)...) {}
diff --git a/include/assimp/Exporter.hpp b/include/assimp/Exporter.hpp
index 8e78ac9541..6ab35a8f0d 100644
--- a/include/assimp/Exporter.hpp
+++ b/include/assimp/Exporter.hpp
@@ -390,7 +390,7 @@ class ASSIMP_API ExportProperties {
      * @see SetPropertyInteger()
      */
     bool SetPropertyMatrix(const char *szName, const aiMatrix4x4 &sValue);
-    
+
     bool SetPropertyCallback(const char *szName, const std::function<void *(void *)> &f);
 
     // -------------------------------------------------------------------
diff --git a/include/assimp/IOStreamBuffer.h b/include/assimp/IOStreamBuffer.h
index ee4ac0953d..c3b7327ff1 100644
--- a/include/assimp/IOStreamBuffer.h
+++ b/include/assimp/IOStreamBuffer.h
@@ -81,7 +81,7 @@ class IOStreamBuffer {
     /// @brief  Returns the file-size.
     /// @return The file-size.
     size_t size() const;
-    
+
     /// @brief  Returns the cache size.
     /// @return The cache size.
     size_t cacheSize() const;
@@ -278,7 +278,7 @@ bool IOStreamBuffer<T>::getNextDataLine( std::vector<T> &buffer, T continuationT
             }
         }
     }
-    
+
     buffer[ i ] = '\n';
     ++m_cachePos;
 
@@ -334,7 +334,7 @@ template<class T>
 AI_FORCE_INLINE
 bool IOStreamBuffer<T>::getNextBlock( std::vector<T> &buffer) {
     // Return the last block-value if getNextLine was used before
-    if ( 0 != m_cachePos ) {      
+    if ( 0 != m_cachePos ) {
         buffer = std::vector<T>( m_cache.begin() + m_cachePos, m_cache.end() );
         m_cachePos = 0;
     } else {
diff --git a/include/assimp/IOSystem.hpp b/include/assimp/IOSystem.hpp
index 76f8764408..7be373cf1e 100644
--- a/include/assimp/IOSystem.hpp
+++ b/include/assimp/IOSystem.hpp
@@ -62,9 +62,9 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "types.h"
 
 #ifdef _WIN32
-#   include <direct.h>  
-#   include <stdlib.h>  
-#   include <stdio.h>  
+#   include <direct.h>
+#   include <stdlib.h>
+#   include <stdio.h>
 #else
 #   include <sys/stat.h>
 #   include <sys/types.h>
@@ -84,7 +84,7 @@ namespace Assimp    {
  *  to the importer library. If you implement this interface, you also want to
  *  supply a custom implementation for IOStream.
  *
- *  @see Importer::SetIOHandler() 
+ *  @see Importer::SetIOHandler()
  */
 class ASSIMP_API IOSystem
 #ifndef SWIG
diff --git a/include/assimp/Logger.hpp b/include/assimp/Logger.hpp
index 3ca4a6cb2b..85204c88d9 100644
--- a/include/assimp/Logger.hpp
+++ b/include/assimp/Logger.hpp
@@ -112,7 +112,7 @@ class ASSIMP_API Logger
 	/** @brief  Writes a debug message
      *   @param message Debug message*/
     void verboseDebug(const char* message);
-    
+
     template<typename... T>
     void verboseDebug(T&&... args) {
         verboseDebug(formatMessage(std::forward<T>(args)...).c_str());
diff --git a/include/assimp/MemoryIOWrapper.h b/include/assimp/MemoryIOWrapper.h
index 86dc5ea60a..24f6a85d1e 100644
--- a/include/assimp/MemoryIOWrapper.h
+++ b/include/assimp/MemoryIOWrapper.h
@@ -57,7 +57,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <stdint.h>
 
 namespace Assimp    {
-    
+
 #define AI_MEMORYIO_MAGIC_FILENAME "$$$___magic___$$$"
 #define AI_MEMORYIO_MAGIC_FILENAME_LENGTH 17
 
@@ -85,7 +85,7 @@ class MemoryIOStream : public IOStream {
     size_t Read(void* pvBuffer, size_t pSize, size_t pCount)    {
         ai_assert(nullptr != pvBuffer);
         ai_assert(0 != pSize);
-        
+
         const size_t cnt = std::min( pCount, (length-pos) / pSize);
         const size_t ofs = pSize * cnt;
 
@@ -209,7 +209,7 @@ class MemoryIOSystem : public IOSystem {
         return existing_io ? existing_io->ComparePaths(one, second) : false;
     }
 
-    bool PushDirectory( const std::string &path ) override { 
+    bool PushDirectory( const std::string &path ) override {
         return existing_io ? existing_io->PushDirectory(path) : false;
     }
 
diff --git a/include/assimp/SmallVector.h b/include/assimp/SmallVector.h
index bcb8482a96..fb78f5a972 100644
--- a/include/assimp/SmallVector.h
+++ b/include/assimp/SmallVector.h
@@ -53,17 +53,17 @@ Based on CppCon 2016: Chandler Carruth "High Performance Code 201: Hybrid Data S
 namespace Assimp {
 
 // --------------------------------------------------------------------------------------------
-/// @brief Small vector with inplace storage. 
+/// @brief Small vector with inplace storage.
 ///
 /// Reduces heap allocations when list is shorter. It uses a small array for a dedicated size.
-/// When the growing gets bigger than this small cache a dynamic growing algorithm will be 
+/// When the growing gets bigger than this small cache a dynamic growing algorithm will be
 /// used.
 // --------------------------------------------------------------------------------------------
 template<typename T, unsigned int Capacity>
 class SmallVector {
 public:
     /// @brief  The default class constructor.
-    SmallVector() : 
+    SmallVector() :
             mStorage(mInplaceStorage),
             mSize(0),
             mCapacity(Capacity) {
@@ -84,7 +84,7 @@ class SmallVector {
             mStorage[mSize++] = item;
             return;
         }
-        
+
         push_back_and_grow(item);
     }
 
diff --git a/include/assimp/SmoothingGroups.inl b/include/assimp/SmoothingGroups.inl
index a32626e00b..08c2dfa53d 100644
--- a/include/assimp/SmoothingGroups.inl
+++ b/include/assimp/SmoothingGroups.inl
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
@@ -77,7 +77,7 @@ void ComputeNormalsWithSmoothingsGroups(MeshWithSmoothingGroups<T>& sMesh)
             sMesh.mNormals[face.mIndices[c]] = vNor;
     }
 
-    // calculate the position bounds so we have a reliable epsilon to check position differences against 
+    // calculate the position bounds so we have a reliable epsilon to check position differences against
     aiVector3D minVec( 1e10f, 1e10f, 1e10f), maxVec( -1e10f, -1e10f, -1e10f);
     for( unsigned int a = 0; a < sMesh.mPositions.size(); a++)
     {
@@ -91,7 +91,7 @@ void ComputeNormalsWithSmoothingsGroups(MeshWithSmoothingGroups<T>& sMesh)
     const float posEpsilon = (maxVec - minVec).Length() * 1e-5f;
     std::vector<aiVector3D> avNormals;
     avNormals.resize(sMesh.mNormals.size());
-    
+
     // now generate the spatial sort tree
     SGSpatialSort sSort;
     for( typename std::vector<T>::iterator i =  sMesh.mFaces.begin();
diff --git a/include/assimp/XmlParser.h b/include/assimp/XmlParser.h
index 18d48f3376..9c2dc419ee 100644
--- a/include/assimp/XmlParser.h
+++ b/include/assimp/XmlParser.h
@@ -94,7 +94,7 @@ using XmlAttribute = pugi::xml_attribute;
 ///     }
 /// }
 /// @endcode
-/// @tparam TNodeType 
+/// @tparam TNodeType
 template <class TNodeType>
 class TXmlParser {
 public:
@@ -123,7 +123,7 @@ class TXmlParser {
 
     ///	@brief  Will search for a child-node by its name
     /// @param  name     [in] The name of the child-node.
-    /// @return The node instance or nullptr, if nothing was found.   
+    /// @return The node instance or nullptr, if nothing was found.
     TNodeType *findNode(const std::string &name) {
         if (name.empty()) {
             return nullptr;
@@ -162,12 +162,12 @@ class TXmlParser {
         mData.resize(len + 1);
         memset(&mData[0], '\0', len + 1);
         stream->Read(&mData[0], 1, len);
-        
+
         mDoc = new pugi::xml_document();
         pugi::xml_parse_result parse_result = mDoc->load_string(&mData[0], pugi::parse_full);
         if (parse_result.status == pugi::status_ok) {
             return true;
-        } 
+        }
 
         ASSIMP_LOG_DEBUG("Error while parse xml.", std::string(parse_result.description()), " @ ", parse_result.offset);
 
@@ -457,7 +457,7 @@ class XmlNodeIterator {
     }
 
 private:
-    XmlNode &mParent; 
+    XmlNode &mParent;
     std::vector<XmlNode> mNodes;
     size_t mIndex;
 };
diff --git a/include/assimp/ai_assert.h b/include/assimp/ai_assert.h
index 6736b24c9f..b377b6e8b1 100644
--- a/include/assimp/ai_assert.h
+++ b/include/assimp/ai_assert.h
@@ -57,7 +57,7 @@ namespace Assimp
 
 #else
 #   define  ai_assert(expression)
-#   define  ai_assert_entry() 
+#   define  ai_assert_entry()
 #endif // ASSIMP_BUILD_DEBUG
 
 #endif // AI_ASSERT_H_INC
diff --git a/include/assimp/anim.h b/include/assimp/anim.h
index 79841a5372..dcd054d1e3 100644
--- a/include/assimp/anim.h
+++ b/include/assimp/anim.h
@@ -39,7 +39,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
 
-/** 
+/**
   * @file   anim.h
   * @brief  Defines the data structures in which the imported animations
   *         are returned.
@@ -478,11 +478,11 @@ struct aiAnimation {
 namespace Assimp {
 
 // ---------------------------------------------------------------------------
-/** 
+/**
   * @brief CPP-API: Utility class to simplify interpolations of various data types.
   *
   *  The type of interpolation is chosen automatically depending on the
-  *  types of the arguments. 
+  *  types of the arguments.
   */
 template <typename T>
 struct Interpolator {
diff --git a/include/assimp/cimport.h b/include/assimp/cimport.h
index b4a1727425..d660eebb14 100644
--- a/include/assimp/cimport.h
+++ b/include/assimp/cimport.h
@@ -894,7 +894,7 @@ ASSIMP_API float aiMatrix3Determinant(
 
 // --------------------------------------------------------------------------------
 /** Get a 3x3 rotation matrix around the Z axis.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param angle Rotation angle, in radians
  */
 ASSIMP_API void aiMatrix3RotationZ(
@@ -903,7 +903,7 @@ ASSIMP_API void aiMatrix3RotationZ(
 
 // --------------------------------------------------------------------------------
 /** Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param axis Rotation axis, should be a normalized vector
  *  @param angle Rotation angle, in radians
  */
@@ -914,7 +914,7 @@ ASSIMP_API void aiMatrix3FromRotationAroundAxis(
 
 // --------------------------------------------------------------------------------
 /** Get a 3x3 translation matrix.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param translation The translation vector
  */
 ASSIMP_API void aiMatrix3Translation(
@@ -923,7 +923,7 @@ ASSIMP_API void aiMatrix3Translation(
 
 // --------------------------------------------------------------------------------
 /** Create a 3x3 matrix that rotates one vector to another vector.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param from Vector to rotate from
  *  @param to Vector to rotate to
  */
@@ -1059,7 +1059,7 @@ ASSIMP_API void aiMatrix4DecomposeNoScaling(
 
 // --------------------------------------------------------------------------------
 /** Creates a 4x4 matrix from a set of euler angles.
- *  @param mat Receives the output matrix 
+ *  @param mat Receives the output matrix
  *  @param x Rotation angle for the x-axis, in radians
  *  @param y Rotation angle for the y-axis, in radians
  *  @param z Rotation angle for the z-axis, in radians
@@ -1137,7 +1137,7 @@ ASSIMP_API void aiMatrix4FromTo(
 
 // --------------------------------------------------------------------------------
 /** Create a Quaternion from euler angles.
- *  @param q Receives the output quaternion 
+ *  @param q Receives the output quaternion
  *  @param x Rotation angle for the x-axis, in radians
  *  @param y Rotation angle for the y-axis, in radians
  *  @param z Rotation angle for the z-axis, in radians
diff --git a/include/assimp/defs.h b/include/assimp/defs.h
index d61fd79012..8d1011a284 100644
--- a/include/assimp/defs.h
+++ b/include/assimp/defs.h
@@ -161,7 +161,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     #pragma warning(disable : 4251)
   #endif
   /* Force the compiler to inline a function, if possible */
-  #define AI_FORCE_INLINE inline 
+  #define AI_FORCE_INLINE inline
 
   /* Tells the compiler that a function never returns. Used in code analysis
    * to skip dead paths (e.g. after an assertion evaluated to false). */
diff --git a/include/assimp/light.h b/include/assimp/light.h
index bc37de43ad..48efdaebd7 100644
--- a/include/assimp/light.h
+++ b/include/assimp/light.h
@@ -257,7 +257,7 @@ struct aiLight
 
 #ifdef __cplusplus
 }
-#endif 
+#endif
 
 
 #endif // !! AI_LIGHT_H_INC
diff --git a/include/assimp/material.h b/include/assimp/material.h
index f0207c6de1..250ad90d58 100644
--- a/include/assimp/material.h
+++ b/include/assimp/material.h
@@ -194,8 +194,8 @@ enum aiTextureType {
      */
     aiTextureType_NONE = 0,
 
-    /** LEGACY API MATERIALS 
-     * Legacy refers to materials which 
+    /** LEGACY API MATERIALS
+     * Legacy refers to materials which
      * Were originally implemented in the specifications around 2000.
      * These must never be removed, as most engines support them.
      */
@@ -339,9 +339,9 @@ ASSIMP_API const char *TextureTypeToString(enum aiTextureType in);
 
 // ---------------------------------------------------------------------------
 /** @brief Defines all shading models supported by the library
- * 
+ *
  *  Property: #AI_MATKEY_SHADING_MODEL
- * 
+ *
  *  The list of shading modes has been taken from Blender.
  *  See Blender documentation for more information. The API does
  *  not distinguish between "specular" and "diffuse" shaders (thus the
diff --git a/include/assimp/matrix4x4.h b/include/assimp/matrix4x4.h
index c929ef2a9c..6caf7686cd 100644
--- a/include/assimp/matrix4x4.h
+++ b/include/assimp/matrix4x4.h
@@ -230,7 +230,7 @@ class aiMatrix4x4t {
      *  @param out Receives the output matrix
      *  @return Reference to the output matrix
      */
-    static aiMatrix4x4t& Translation( const aiVector3t<TReal>& v, 
+    static aiMatrix4x4t& Translation( const aiVector3t<TReal>& v,
             aiMatrix4x4t& out);
 
     // -------------------------------------------------------------------
diff --git a/include/assimp/matrix4x4.inl b/include/assimp/matrix4x4.inl
index 88315ac281..c1dd87b65f 100644
--- a/include/assimp/matrix4x4.inl
+++ b/include/assimp/matrix4x4.inl
@@ -421,7 +421,7 @@ void aiMatrix4x4t<TReal>::Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TRea
     and post-multiplication of column vectors,
     the rotation matrix for an euler XYZ rotation is M = Rz * Ry * Rx.
     combining gives:
-    
+
         |  CE  BDE-AF  ADE+BF  0  |
     M = |  CF  BDF+AE  ADF-BE  0  |
         |  -D    CB      AC    0  |
diff --git a/include/assimp/mesh.h b/include/assimp/mesh.h
index 989ed3800c..e3aa847ff5 100644
--- a/include/assimp/mesh.h
+++ b/include/assimp/mesh.h
@@ -400,17 +400,17 @@ enum aiPrimitiveType {
 
     /**
      * A flag to determine whether this triangles only mesh is NGON encoded.
-     * 
+     *
      * NGON encoding is a special encoding that tells whether 2 or more consecutive triangles
      * should be considered as a triangle fan. This is identified by looking at the first vertex index.
      * 2 consecutive triangles with the same 1st vertex index are part of the same
      * NGON.
-     * 
-     * At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as 
+     *
+     * At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as
      * triangles, as usual after a triangulation pass.
-     * 
+     *
      * To get an NGON encoded mesh, please use the aiProcess_Triangulate post process.
-     * 
+     *
      * @see aiProcess_Triangulate
      * @link https://github.com/KhronosGroup/glTF/pull/1620
      */
diff --git a/include/assimp/postprocess.h b/include/assimp/postprocess.h
index ca2c2c22d3..5e887b0b1c 100644
--- a/include/assimp/postprocess.h
+++ b/include/assimp/postprocess.h
@@ -211,10 +211,10 @@ enum aiPostProcessSteps
     *
     * If the resulting scene can be reduced to a single mesh, with a single
     * material, no lights, and no cameras, then the output scene will contain
-    * only a root node (with no children) that references the single mesh. 
+    * only a root node (with no children) that references the single mesh.
     * Otherwise, the output scene will be reduced to a root node with a single
-    * level of child nodes, each one referencing one mesh, and each mesh 
-    * referencing one material. 
+    * level of child nodes, each one referencing one mesh, and each mesh
+    * referencing one material.
     *
     * In either case, for rendering, you can
     * simply render all meshes in order - you don't need to pay
@@ -328,12 +328,12 @@ enum aiPostProcessSteps
 
 
     // -------------------------------------------------------------------------
-    /** 
+    /**
      * This step generically populates aiBone->mArmature and aiBone->mNode generically
      * The point of these is it saves you later having to calculate these elements
      * This is useful when handling rest information or skin information
-     * If you have multiple armatures on your models we strongly recommend enabling this 
-     * Instead of writing your own multi-root, multi-armature lookups we have done the 
+     * If you have multiple armatures on your models we strongly recommend enabling this
+     * Instead of writing your own multi-root, multi-armature lookups we have done the
      * hard work for you :)
    */
     aiProcess_PopulateArmatureData = 0x4000,
@@ -579,7 +579,7 @@ enum aiPostProcessSteps
      *  of the imported model. And if so, it uses that.
      */
     aiProcess_EmbedTextures  = 0x10000000,
-        
+
     // aiProcess_GenEntityMeshes = 0x100000,
     // aiProcess_OptimizeAnimations = 0x200000
     // aiProcess_FixTexturePaths = 0x200000
diff --git a/include/assimp/scene.h b/include/assimp/scene.h
index 522ddc6dcb..25858ac386 100644
--- a/include/assimp/scene.h
+++ b/include/assimp/scene.h
@@ -70,7 +70,7 @@ extern "C" {
 #endif
 
 // -------------------------------------------------------------------------------
-/** 
+/**
  * A node in the imported hierarchy.
  *
  * Each node has name, a parent node (except for the root node),
@@ -149,12 +149,12 @@ struct ASSIMP_API aiNode
      *  @param name Name to search for
      *  @return nullptr or a valid Node if the search was successful.
      */
-    inline 
+    inline
     const aiNode* FindNode(const aiString& name) const {
         return FindNode(name.data);
     }
 
-    inline 
+    inline
     aiNode* FindNode(const aiString& name) {
         return FindNode(name.data);
     }
@@ -353,34 +353,34 @@ struct aiScene
 
     //! Check whether the scene contains meshes
     //! Unless no special scene flags are set this will always be true.
-    inline bool HasMeshes() const { 
-        return mMeshes != nullptr && mNumMeshes > 0; 
+    inline bool HasMeshes() const {
+        return mMeshes != nullptr && mNumMeshes > 0;
     }
 
     //! Check whether the scene contains materials
     //! Unless no special scene flags are set this will always be true.
-    inline bool HasMaterials() const { 
-        return mMaterials != nullptr && mNumMaterials > 0; 
+    inline bool HasMaterials() const {
+        return mMaterials != nullptr && mNumMaterials > 0;
     }
 
     //! Check whether the scene contains lights
-    inline bool HasLights() const { 
-        return mLights != nullptr && mNumLights > 0; 
+    inline bool HasLights() const {
+        return mLights != nullptr && mNumLights > 0;
     }
 
     //! Check whether the scene contains textures
     inline bool HasTextures() const {
-        return mTextures != nullptr && mNumTextures > 0; 
+        return mTextures != nullptr && mNumTextures > 0;
     }
 
     //! Check whether the scene contains cameras
     inline bool HasCameras() const {
-        return mCameras != nullptr && mNumCameras > 0; 
+        return mCameras != nullptr && mNumCameras > 0;
     }
 
     //! Check whether the scene contains animations
-    inline bool HasAnimations() const { 
-        return mAnimations != nullptr && mNumAnimations > 0; 
+    inline bool HasAnimations() const {
+        return mAnimations != nullptr && mNumAnimations > 0;
     }
 
     //! Returns a short filename from a full path
diff --git a/include/assimp/vector2.inl b/include/assimp/vector2.inl
index 0ca440e72b..b51dd0ec22 100644
--- a/include/assimp/vector2.inl
+++ b/include/assimp/vector2.inl
@@ -190,7 +190,7 @@ aiVector2t<TReal> operator + (const aiVector2t<TReal>& v1, const aiVector2t<TRea
 // ------------------------------------------------------------------------------------------------
 // symmetric subtraction
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator - (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2) {
     return aiVector2t<TReal>( v1.x - v2.x, v1.y - v2.y);
 }
@@ -198,7 +198,7 @@ aiVector2t<TReal> operator - (const aiVector2t<TReal>& v1, const aiVector2t<TRea
 // ------------------------------------------------------------------------------------------------
 // scalar product
 template <typename TReal>
-inline 
+inline
 TReal operator * (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2) {
     return v1.x*v2.x + v1.y*v2.y;
 }
@@ -206,7 +206,7 @@ TReal operator * (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2) {
 // ------------------------------------------------------------------------------------------------
 // scalar multiplication
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator * ( TReal f, const aiVector2t<TReal>& v) {
     return aiVector2t<TReal>( f*v.x, f*v.y);
 }
@@ -214,7 +214,7 @@ aiVector2t<TReal> operator * ( TReal f, const aiVector2t<TReal>& v) {
 // ------------------------------------------------------------------------------------------------
 // and the other way around
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator * ( const aiVector2t<TReal>& v, TReal f) {
     return aiVector2t<TReal>( f*v.x, f*v.y);
 }
@@ -222,7 +222,7 @@ aiVector2t<TReal> operator * ( const aiVector2t<TReal>& v, TReal f) {
 // ------------------------------------------------------------------------------------------------
 // scalar division
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, TReal f) {
     return v * (1/f);
 }
@@ -230,7 +230,7 @@ aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, TReal f) {
 // ------------------------------------------------------------------------------------------------
 // vector division
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, const aiVector2t<TReal>& v2) {
     return aiVector2t<TReal>(v.x / v2.x,v.y / v2.y);
 }
@@ -238,7 +238,7 @@ aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, const aiVector2t<TRea
 // ------------------------------------------------------------------------------------------------
 // vector negation
 template <typename TReal>
-inline 
+inline
 aiVector2t<TReal> operator - ( const aiVector2t<TReal>& v) {
     return aiVector2t<TReal>( -v.x, -v.y);
 }
diff --git a/packaging/windows-innosetup/readme_installer.txt b/packaging/windows-innosetup/readme_installer.txt
index 6ea969dc12..252c396af4 100644
--- a/packaging/windows-innosetup/readme_installer.txt
+++ b/packaging/windows-innosetup/readme_installer.txt
@@ -10,7 +10,7 @@ http://assimp.sf.net
 Troubleshooting
 ===============
 
-1. Missing d3dx9_(some-number).dll? 
+1. Missing d3dx9_(some-number).dll?
 Install the latest DirectX runtime or grab the file from somewhere (that's evil but mostly fine).
 
 2. Application configuration not correct / missing msvcr***.dll?
diff --git a/packaging/windows-innosetup/readme_installer_vieweronly.txt b/packaging/windows-innosetup/readme_installer_vieweronly.txt
index 1e84c577db..0acd6ef520 100644
--- a/packaging/windows-innosetup/readme_installer_vieweronly.txt
+++ b/packaging/windows-innosetup/readme_installer_vieweronly.txt
@@ -19,7 +19,7 @@ Viewer
 Troubleshooting
 ===============
 
-1. Missing d3dx9_(number).dll? 
+1. Missing d3dx9_(number).dll?
 Install the latest DirectX runtime or grab the file from somewhere (that's evil but mostly fine).
 
 2. Application configuration not correct / missing msvcr***.dll?
diff --git a/packaging/windows-mkzip/bin_readme.txt b/packaging/windows-mkzip/bin_readme.txt
index 5cff1f30e5..f4402d6bfe 100644
--- a/packaging/windows-mkzip/bin_readme.txt
+++ b/packaging/windows-mkzip/bin_readme.txt
@@ -19,7 +19,7 @@ Viewer
 Troubleshooting
 ===============
 
-1. Missing d3dx9_42.dll? 
+1. Missing d3dx9_42.dll?
 Install the latest DirectX runtime or grab the file from somewhere (that's evil but mostly fine).
 
 2. Application configuration not correct / missing msv*** DLLs?
diff --git a/port/AndroidJNI/CMakeLists.txt b/port/AndroidJNI/CMakeLists.txt
index 43e8428484..8c821c72ad 100644
--- a/port/AndroidJNI/CMakeLists.txt
+++ b/port/AndroidJNI/CMakeLists.txt
@@ -3,10 +3,10 @@ cmake_minimum_required(VERSION 3.10)
 include_directories(./)
 include_directories(./../../)
 add_library( # Defines the name of the library.
-             android_jniiosystem 
+             android_jniiosystem
 
              # Implements a static library.
-             STATIC 
+             STATIC
 
              # relative path to source file(s).
              AndroidJNIIOSystem.cpp
diff --git a/port/AssimpDelphi/Readme.txt b/port/AssimpDelphi/Readme.txt
index 07d6935ae1..1ec6d21094 100644
--- a/port/AssimpDelphi/Readme.txt
+++ b/port/AssimpDelphi/Readme.txt
@@ -1,6 +1,6 @@
 This is a set of Delphi units for using the Assimp C DLL.  This was created for use with Delphi 7, but should be usable as-is or with minimal modifications with later Delphi versions.
 
-This set of headers is enough to load and display a model with external textures.  Since I'm not familiar with animated models and some of the other functionality of the assimp library, I did not convert the headers for those features. 
+This set of headers is enough to load and display a model with external textures.  Since I'm not familiar with animated models and some of the other functionality of the assimp library, I did not convert the headers for those features.
 
 See http://sourceforge.net/tracker/?func=detail&aid=3212646&group_id=226462&atid=1067634 for the original patch
 
diff --git a/port/jassimp/jassimp-native/src/jassimp.cpp b/port/jassimp/jassimp-native/src/jassimp.cpp
index 0cf01b1e35..6661ce9c4c 100644
--- a/port/jassimp/jassimp-native/src/jassimp.cpp
+++ b/port/jassimp/jassimp-native/src/jassimp.cpp
@@ -15,7 +15,7 @@
 #define lprintf(...) printf (__VA_ARGS__)
 #endif /* ANDROID */
 #else
-#define lprintf 
+#define lprintf
 #endif
 
 static std::string gLastErrorString;
@@ -63,7 +63,7 @@ static bool createInstance(JNIEnv *env, const char* className, jobject& newInsta
 
 	newInstance = env->NewObject(clazz, ctr_id);
 
-	if (NULL == newInstance) 
+	if (NULL == newInstance)
 	{
 		lprintf("error calling no-arg constructor for class %s\n", className);
 		return false;
@@ -94,7 +94,7 @@ static bool createInstance(JNIEnv *env, const char* className, const char* signa
 
 	newInstance = env->NewObjectA(clazz, ctr_id, params);
 
-	if (NULL == newInstance) 
+	if (NULL == newInstance)
 	{
 		lprintf("error calling  constructor for class %s, signature %s\n", className, signature);
 		return false;
@@ -229,7 +229,7 @@ static bool getStaticField(JNIEnv *env, const char* className, const char* field
 }
 
 
-static bool call(JNIEnv *env, jobject object, const char* typeName, const char* methodName, 
+static bool call(JNIEnv *env, jobject object, const char* typeName, const char* methodName,
 	const char* signature,/* const*/ jvalue* params)
 {
 	jclass clazz = env->FindClass(typeName);
@@ -275,7 +275,7 @@ static bool callv(JNIEnv *env, jobject object, const char* typeName,
 	return true;
 }
 
-static jobject callo(JNIEnv *env, jobject object, const char* typeName, const char* methodName, 
+static jobject callo(JNIEnv *env, jobject object, const char* typeName, const char* methodName,
 	const char* signature,/* const*/ jvalue* params)
 {
 	jclass clazz = env->FindClass(typeName);
@@ -300,7 +300,7 @@ static jobject callo(JNIEnv *env, jobject object, const char* typeName, const ch
 	return jReturnValue;
 }
 
-static int calli(JNIEnv *env, jobject object, const char* typeName, const char* methodName, 
+static int calli(JNIEnv *env, jobject object, const char* typeName, const char* methodName,
 	const char* signature)
 {
 	jclass clazz = env->FindClass(typeName);
@@ -325,7 +325,7 @@ static int calli(JNIEnv *env, jobject object, const char* typeName, const char*
 	return (int) jReturnValue;
 }
 
-static int callc(JNIEnv *env, jobject object, const char* typeName, const char* methodName, 
+static int callc(JNIEnv *env, jobject object, const char* typeName, const char* methodName,
 	const char* signature)
 {
 	jclass clazz = env->FindClass(typeName);
@@ -351,7 +351,7 @@ static int callc(JNIEnv *env, jobject object, const char* typeName, const char*
 }
 
 
-static bool callStaticObject(JNIEnv *env, const char* typeName, const char* methodName, 
+static bool callStaticObject(JNIEnv *env, const char* typeName, const char* methodName,
 	const char* signature,/* const*/ jvalue* params, jobject& returnValue)
 {
 	jclass clazz = env->FindClass(typeName);
@@ -441,13 +441,13 @@ static bool copyBufferArray(JNIEnv *env, jobject jMesh, const char* jBufferName,
 
 class JavaIOStream : public Assimp::IOStream
 {
-private:	
+private:
 	size_t pos;
 	size_t size;
 	char* buffer;
 	jobject jIOStream;
 
-	
+
 public:
 	JavaIOStream(size_t size, char* buffer, jobject jIOStream) :
 	pos(0),
@@ -455,28 +455,28 @@ class JavaIOStream : public Assimp::IOStream
 	buffer(buffer),
 	jIOStream(jIOStream)
 	{};
-	
-	
-    ~JavaIOStream(void) 
+
+
+    ~JavaIOStream(void)
     {
     	free(buffer);
-    }; 
+    };
 
     size_t Read(void* pvBuffer, size_t pSize, size_t pCount)
     {
     	const size_t cnt = std::min(pCount,(size - pos)/pSize);
 		const size_t ofs = pSize*cnt;
-	
+
 	    memcpy(pvBuffer, buffer + pos, ofs);
 	    pos += ofs;
-	
+
 	    return cnt;
     };
-    size_t Write(const void* pvBuffer, size_t pSize, size_t pCount) 
+    size_t Write(const void* pvBuffer, size_t pSize, size_t pCount)
     {
         return 0;
     };
-    
+
     aiReturn Seek(size_t pOffset, aiOrigin pOrigin)
     {
 	    if (aiOrigin_SET == pOrigin) {
@@ -499,40 +499,40 @@ class JavaIOStream : public Assimp::IOStream
 	    }
 	    return AI_SUCCESS;
     };
-    
+
     size_t Tell(void) const
     {
     	return pos;
     };
-    
+
     size_t FileSize() const
     {
     	return size;
     };
-    
+
     void Flush() {};
-    
-    
+
+
     jobject javaObject()
     {
     	return jIOStream;
     };
-    
-    
+
+
 };
- 
+
 
 class JavaIOSystem : public Assimp::IOSystem {
 	private:
     JNIEnv* mJniEnv;
 	jobject& mJavaIOSystem;
-	
+
 	public:
 	JavaIOSystem(JNIEnv* env, jobject& javaIOSystem) :
 		mJniEnv(env),
 		mJavaIOSystem(javaIOSystem)
 	{};
-	
+
     bool Exists( const char* pFile) const
     {
     	jvalue params[1];
@@ -544,27 +544,27 @@ class JavaIOSystem : public Assimp::IOSystem {
     {
 	    return (char) callc(mJniEnv, mJavaIOSystem, "jassimp/AiIOSystem", "getOsSeparator", "()C");
     };
-    
+
     Assimp::IOStream* Open(const char* pFile,const char* pMode = "rb")
     {
         jvalue params[2];
 		params[0].l = mJniEnv->NewStringUTF(pFile);
 		params[1].l = mJniEnv->NewStringUTF(pMode);
-		
-		
+
+
 	    jobject jStream = callo(mJniEnv, mJavaIOSystem, "jassimp/AiIOSystem", "open", "(Ljava/lang/String;Ljava/lang/String;)Ljassimp/AiIOStream;", params);
 	    if(NULL == jStream)
 	    {
 	    	lprintf("NULL object from AiIOSystem.open\n");
 	    	return NULL;
 	    }
-	    
+	
 	    size_t size = calli(mJniEnv, jStream, "jassimp/AiIOStream", "getFileSize", "()I");
 	    lprintf("Model file size is %d\n", size);
-	    
+	
 	    char* buffer = (char*)malloc(size);
 	    jobject javaBuffer = mJniEnv->NewDirectByteBuffer(buffer, size);
-	    
+	
 	    jvalue readParams[1];
 	    readParams[0].l = javaBuffer;
 	    if(call(mJniEnv, jStream, "jassimp/AiIOStream", "read", "(Ljava/nio/ByteBuffer;)Z", readParams))
@@ -581,28 +581,28 @@ class JavaIOSystem : public Assimp::IOSystem {
     };
     void Close( Assimp::IOStream* pFile)
     {
-    	
+
 		jvalue params[1];
 		params[0].l = ((JavaIOStream*) pFile)->javaObject();
 		callv(mJniEnv, mJavaIOSystem, "jassimp/AiIOSystem", "close", "(Ljassimp/AiIOStream;)V", params);
     	delete pFile;
     };
-    
 
-	
+
+
 };
 
 class JavaProgressHandler : public Assimp::ProgressHandler {
 	private:
     JNIEnv* mJniEnv;
 	jobject& mJavaProgressHandler;
-	
+
 	public:
 	JavaProgressHandler(JNIEnv* env, jobject& javaProgressHandler) :
 		mJniEnv(env),
 		mJavaProgressHandler(javaProgressHandler)
 	{};
-	
+
     bool Update(float percentage)
     {
     	jvalue params[1];
@@ -623,12 +623,12 @@ static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 		jobject jMesh = NULL;
 		SmartLocalRef refMesh(env, jMesh);
 
-		if (!createInstance(env, "jassimp/AiMesh", jMesh)) 
+		if (!createInstance(env, "jassimp/AiMesh", jMesh))
 		{
 			return false;
 		}
 
-		
+
 		/* add mesh to m_meshes java.util.List */
 		jobject jMeshes = NULL;
 		SmartLocalRef refMeshes(env, jMeshes);
@@ -671,7 +671,7 @@ static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 		/* determine face buffer size */
 		bool isPureTriangle = cMesh->mPrimitiveTypes == aiPrimitiveType_TRIANGLE;
 		size_t faceBufferSize;
-		if (isPureTriangle) 
+		if (isPureTriangle)
 		{
 			faceBufferSize = cMesh->mNumFaces * 3 * sizeof(unsigned int);
 		}
@@ -715,7 +715,7 @@ static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 		/* push face data to java */
 		if (cMesh->mNumFaces > 0)
 		{
-			if (isPureTriangle) 
+			if (isPureTriangle)
 			{
 				char* faceBuffer = (char*) malloc(faceBufferSize);
 
@@ -729,7 +729,7 @@ static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 
 				free(faceBuffer);
 
-				if (!res) 
+				if (!res)
 				{
 					lprintf("could not copy face data\n");
 					return false;
@@ -750,7 +750,7 @@ static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 					memcpy(faceBuffer + faceBufferPos, cMesh->mFaces[face].mIndices, faceDataSize);
 					faceBufferPos += faceDataSize;
 				}
-		
+
 				if (faceBufferPos != faceBufferSize)
 				{
 					/* this should really not happen */
@@ -766,7 +766,7 @@ static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 				free(faceBuffer);
 				free(offsetBuffer);
 
-				if (!res) 
+				if (!res)
 				{
 					lprintf("could not copy face data\n");
 					return false;
@@ -933,7 +933,7 @@ static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 
 			jobject jBone;
 			SmartLocalRef refBone(env, jBone);
-			if (!createInstance(env, "jassimp/AiBone", jBone)) 
+			if (!createInstance(env, "jassimp/AiBone", jBone))
 			{
 				return false;
 			}
@@ -988,7 +988,7 @@ static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 				wrapParams[0].l = jMatrixArr;
 				jobject jMatrix;
 				SmartLocalRef refMatrix(env, jMatrix);
-				
+
 				if (!callStaticObject(env, "jassimp/Jassimp", "wrapMatrix", "([F)Ljava/lang/Object;", wrapParams, jMatrix))
 				{
 					return false;
@@ -1012,7 +1012,7 @@ static bool loadMeshes(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 				{
 					return false;
 				}
-				
+
 				if (!setFloatField(env, jBoneWeight, "m_weight", cBone->mWeights[w].mWeight))
 				{
 					return false;
@@ -1228,7 +1228,7 @@ static bool loadSceneNode(JNIEnv *env, const aiNode *cNode, jobject parent, jobj
 	wrapNodeParams[3].l = jNodeName;
 	jobject jNode;
 	if (!callStaticObject(env, "jassimp/Jassimp", "wrapSceneNode",
-		"(Ljava/lang/Object;Ljava/lang/Object;[ILjava/lang/String;)Ljava/lang/Object;", wrapNodeParams, jNode)) 
+		"(Ljava/lang/Object;Ljava/lang/Object;[ILjava/lang/String;)Ljava/lang/Object;", wrapNodeParams, jNode))
 	{
 		return false;
 	}
@@ -1287,7 +1287,7 @@ static bool loadSceneGraph(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 }
 
 
-static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene) 
+static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 {
 	for (unsigned int m = 0; m < cScene->mNumMaterials; m++)
 	{
@@ -1320,7 +1320,7 @@ static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 		}
 
 		/* set texture numbers */
-		for (int ttInd = aiTextureType_DIFFUSE; ttInd < aiTextureType_UNKNOWN; ttInd++) 
+		for (int ttInd = aiTextureType_DIFFUSE; ttInd < aiTextureType_UNKNOWN; ttInd++)
 		{
 			aiTextureType tt = static_cast<aiTextureType>(ttInd);
 
@@ -1341,7 +1341,7 @@ static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 
 		for (unsigned int p = 0; p < cMaterial->mNumProperties; p++)
 		{
-			//printf("%s - %u - %u\n", cScene->mMaterials[m]->mProperties[p]->mKey.C_Str(), 
+			//printf("%s - %u - %u\n", cScene->mMaterials[m]->mProperties[p]->mKey.C_Str(),
 			//	cScene->mMaterials[m]->mProperties[p]->mSemantic,
 			//	cScene->mMaterials[m]->mProperties[p]->mDataLength);
 
@@ -1362,9 +1362,9 @@ static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 
 
 			/* special case conversion for color3 */
-			if (NULL != strstr(cProperty->mKey.C_Str(), "clr") && 
+			if (NULL != strstr(cProperty->mKey.C_Str(), "clr") &&
 				cProperty->mType == aiPTI_Float &&
-				cProperty->mDataLength == 3 * sizeof(float)) 
+				cProperty->mDataLength == 3 * sizeof(float))
 			{
 				jobject jData = NULL;
 				SmartLocalRef refData(env, jData);
@@ -1380,16 +1380,16 @@ static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 				}
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
 			/* special case conversion for color4 */
-			else if (NULL != strstr(cProperty->mKey.C_Str(), "clr") && 
+			else if (NULL != strstr(cProperty->mKey.C_Str(), "clr") &&
 				cProperty->mType == aiPTI_Float &&
-				cProperty->mDataLength == 4 * sizeof(float)) 
+				cProperty->mDataLength == 4 * sizeof(float))
 			{
 				jobject jData = NULL;
 				SmartLocalRef refData(env, jData);
@@ -1406,13 +1406,13 @@ static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 				}
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
-			else if (cProperty->mType == aiPTI_Float && cProperty->mDataLength == sizeof(float)) 
+			else if (cProperty->mType == aiPTI_Float && cProperty->mDataLength == sizeof(float))
 			{
 				jobject jData = NULL;
 				SmartLocalRef refData(env, jData);
@@ -1425,13 +1425,13 @@ static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 				}
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
-			else if (cProperty->mType == aiPTI_Integer && cProperty->mDataLength == sizeof(int)) 
+			else if (cProperty->mType == aiPTI_Integer && cProperty->mDataLength == sizeof(int))
 			{
 				jobject jData = NULL;
 				SmartLocalRef refData(env, jData);
@@ -1444,26 +1444,26 @@ static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 				}
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
-			else if (cProperty->mType == aiPTI_String) 
+			else if (cProperty->mType == aiPTI_String)
 			{
 				/* skip length prefix */
 				jobject jData = env->NewStringUTF(cProperty->mData + 4);
 				SmartLocalRef refData(env, jData);
 
 				constructorParams[4].l = jData;
-				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V", 
+				if (!createInstance(env, "jassimp/AiMaterial$Property", "(Ljava/lang/String;IIILjava/lang/Object;)V",
 					constructorParams, jProperty))
 				{
 					return false;
 				}
 			}
-			else 
+			else
 			{
 				constructorParams[4].i = cProperty->mDataLength;
 
@@ -1521,7 +1521,7 @@ static bool loadMaterials(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 }
 
 
-static bool loadAnimations(JNIEnv *env, const aiScene* cScene, jobject& jScene) 
+static bool loadAnimations(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 {
 	lprintf("converting %d animations ...\n", cScene->mNumAnimations);
 
@@ -1603,19 +1603,19 @@ static bool loadAnimations(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 			}
 
 			/* copy keys */
-			if (!copyBuffer(env, jNodeAnim, "m_posKeys", cNodeAnim->mPositionKeys, 
+			if (!copyBuffer(env, jNodeAnim, "m_posKeys", cNodeAnim->mPositionKeys,
 				cNodeAnim->mNumPositionKeys * sizeof(aiVectorKey)))
 			{
 				return false;
 			}
 
-			if (!copyBuffer(env, jNodeAnim, "m_rotKeys", cNodeAnim->mRotationKeys, 
+			if (!copyBuffer(env, jNodeAnim, "m_rotKeys", cNodeAnim->mRotationKeys,
 				cNodeAnim->mNumRotationKeys * sizeof(aiQuatKey)))
 			{
 				return false;
 			}
 
-			if (!copyBuffer(env, jNodeAnim, "m_scaleKeys", cNodeAnim->mScalingKeys, 
+			if (!copyBuffer(env, jNodeAnim, "m_scaleKeys", cNodeAnim->mScalingKeys,
 				cNodeAnim->mNumScalingKeys * sizeof(aiVectorKey)))
 			{
 				return false;
@@ -1629,7 +1629,7 @@ static bool loadAnimations(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 }
 
 
-static bool loadLights(JNIEnv *env, const aiScene* cScene, jobject& jScene) 
+static bool loadLights(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 {
 	lprintf("converting %d lights ...\n", cScene->mNumLights);
 
@@ -1712,7 +1712,7 @@ static bool loadLights(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 		params[9].l = jAmbient;
 		params[10].f = cLight->mAngleInnerCone;
 		params[11].f = cLight->mAngleOuterCone;
-		
+
 		if (!createInstance(env, "jassimp/AiLight", "(Ljava/lang/String;ILjava/lang/Object;Ljava/lang/Object;FFFLjava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;FF)V",
 			params, jLight))
 		{
@@ -1736,13 +1736,13 @@ static bool loadLights(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 		}
 	}
 
-	lprintf("converting lights finished ...\n"); 
+	lprintf("converting lights finished ...\n");
 
 	return true;
 }
 
 
-static bool loadCameras(JNIEnv *env, const aiScene* cScene, jobject& jScene) 
+static bool loadCameras(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 {
 	lprintf("converting %d cameras ...\n", cScene->mNumCameras);
 
@@ -1799,7 +1799,7 @@ static bool loadCameras(JNIEnv *env, const aiScene* cScene, jobject& jScene)
 		params[5].f = cCamera->mClipPlaneNear;
 		params[6].f = cCamera->mClipPlaneFar;
 		params[7].f = cCamera->mAspect;
-		
+
 		if (!createInstance(env, "jassimp/AiCamera", "(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;FFFF)V",
 			params, jCamera))
 		{
@@ -1901,25 +1901,25 @@ JNIEXPORT jstring JNICALL Java_jassimp_Jassimp_getErrorString
 JNIEXPORT jobject JNICALL Java_jassimp_Jassimp_aiImportFile
   (JNIEnv *env, jclass jClazz, jstring jFilename, jlong postProcess, jobject ioSystem, jobject progressHandler)
 {
-	jobject jScene = NULL; 
+	jobject jScene = NULL;
 
 	/* convert params */
 	const char* cFilename = env->GetStringUTFChars(jFilename, NULL);
-	
+
     Assimp::Importer imp;
 
-	
+
 	if(ioSystem != NULL)
 	{
-		imp.SetIOHandler(new JavaIOSystem(env, ioSystem));		
+		imp.SetIOHandler(new JavaIOSystem(env, ioSystem));
 		lprintf("Created aiFileIO\n");
 	}
-	
+
 	if(progressHandler != NULL)
 	{
 		imp.SetProgressHandler(new JavaProgressHandler(env, progressHandler));
 	}
-	
+
 	lprintf("opening file: %s\n", cFilename);
 
 	/* do import */
@@ -1931,7 +1931,7 @@ JNIEXPORT jobject JNICALL Java_jassimp_Jassimp_aiImportFile
 		goto error;
 	}
 
-	if (!createInstance(env, "jassimp/AiScene", jScene)) 
+	if (!createInstance(env, "jassimp/AiScene", jScene))
 	{
 		goto error;
 	}
diff --git a/samples/SimpleAssimpViewX/ModelLoaderHelperClasses.h b/samples/SimpleAssimpViewX/ModelLoaderHelperClasses.h
index 0e6dfab3cc..1803ad1227 100644
--- a/samples/SimpleAssimpViewX/ModelLoaderHelperClasses.h
+++ b/samples/SimpleAssimpViewX/ModelLoaderHelperClasses.h
@@ -15,7 +15,7 @@
 
 /* workflow:
 
- 1) create a new scene wrapper 
+ 1) create a new scene wrapper
  2) populate an array of of meshHelpers for each mesh in the original scene
  3) (eventually) create an animator instance
  4) scale the asset (needed?)
@@ -24,16 +24,16 @@
     5b) create a static vertex buffer
     5c) create index buffer
     5d) populate the index buffer
-    5e) (eventually) gather weights    
+    5e) (eventually) gather weights
 */
 
 #define BUFFER_OFFSET(i) ((char *)NULL + (i))
 
-struct Vertex 
+struct Vertex
 {
     aiVector3D vPosition;
     aiVector3D vNormal;
-    
+
     aiColor4D  dColorDiffuse;
     aiVector3D vTangent;
     aiVector3D vBitangent;
@@ -46,33 +46,33 @@ struct Vertex
 
 // Helper Class to store GPU related resources from a given aiMesh
 // Modeled after AssimpView asset helper
-@interface MeshHelper : NSObject 
-{        
+@interface MeshHelper : NSObject
+{
     // Display list ID, this one shots *all drawing* of the mesh. Only ever use this to draw. Booya.
     GLuint displayList;
-    
+
     // VAO that encapsulates all VBO drawing state
     GLuint vao;
-    
+
     // VBOs
     GLuint vertexBuffer;
     GLuint indexBuffer;
     GLuint normalBuffer;
     GLuint numIndices;
-        
+
     // texture
     GLuint textureID;
-    
-    // Material 
+
+    // Material
     aiColor4D diffuseColor;
     aiColor4D specularColor;
     aiColor4D ambientColor;
     aiColor4D emissiveColor;
-    
+
     GLfloat opacity;
     GLfloat shininess;
     GLfloat specularStrength;
-    
+
     BOOL twoSided;
 }
 
diff --git a/samples/SimpleAssimpViewX/MyDocument.h b/samples/SimpleAssimpViewX/MyDocument.h
index 16745dc3c3..67675e306e 100644
--- a/samples/SimpleAssimpViewX/MyDocument.h
+++ b/samples/SimpleAssimpViewX/MyDocument.h
@@ -20,27 +20,27 @@
 #import <Quartz/Quartz.h>
 
 
-@interface MyDocument : NSPersistentDocument 
+@interface MyDocument : NSPersistentDocument
 {
     CVDisplayLinkRef _displayLink;
     NSOpenGLContext* _glContext;
     NSOpenGLPixelFormat* _glPixelFormat;
-    
+
     NSView* _view;
-    
+
     // Assimp Stuff
     aiScene* _scene;
     aiVector3D scene_min, scene_max, scene_center;
-    double normalizedScale;    
-    
+    double normalizedScale;
+
     // Our array of textures.
     GLuint *textureIds;
-    
+
     // only used if we use
-    NSMutableArray* modelMeshes;   
+    NSMutableArray* modelMeshes;
     BOOL builtBuffers;
-    
-    NSMutableDictionary* textureDictionary;	// Array of Dicionaries that map image filenames to textureIds      
+
+    NSMutableDictionary* textureDictionary;	// Array of Dicionaries that map image filenames to textureIds
 }
 
 @property (retain) IBOutlet NSView* _view;
diff --git a/samples/SimpleOpenGL/Sample_SimpleOpenGL.c b/samples/SimpleOpenGL/Sample_SimpleOpenGL.c
index bcb1095640..7aa306ed4f 100644
--- a/samples/SimpleOpenGL/Sample_SimpleOpenGL.c
+++ b/samples/SimpleOpenGL/Sample_SimpleOpenGL.c
@@ -29,7 +29,7 @@
 
 /* ---------------------------------------------------------------------------- */
 inline static void print_run_command(const char* command_name) {
-	printf("Run '%s %s' for more information.\n", 
+	printf("Run '%s %s' for more information.\n",
 		PROJECT_NAME, command_name);
 }
 
@@ -43,7 +43,7 @@ inline static void print_error(const char* msg) {
 
 /* ---------------------------------------------------------------------------- */
 inline static void print_usage() {
-	static const char* usage_format = 
+	static const char* usage_format =
 		"Usage: "
 		PROJECT_NAME
 		" <file>"	 DOUBLE_NEW_LINE
diff --git a/samples/SimpleTexturedDirectx11/CMakeLists.txt b/samples/SimpleTexturedDirectx11/CMakeLists.txt
index 82144caa90..007ada3af2 100644
--- a/samples/SimpleTexturedDirectx11/CMakeLists.txt
+++ b/samples/SimpleTexturedDirectx11/CMakeLists.txt
@@ -24,13 +24,13 @@ LINK_DIRECTORIES(
 )
 
 ADD_EXECUTABLE( assimp_simpletextureddirectx11 WIN32
-  SimpleTexturedDirectx11/Mesh.h 
+  SimpleTexturedDirectx11/Mesh.h
   SimpleTexturedDirectx11/ModelLoader.cpp
   SimpleTexturedDirectx11/ModelLoader.h
   #SimpleTexturedDirectx11/PixelShader.hlsl
   SimpleTexturedDirectx11/TextureLoader.cpp
-  SimpleTexturedDirectx11/TextureLoader.h 
-  #SimpleTexturedDirectx11/VertexShader.hlsl  
+  SimpleTexturedDirectx11/TextureLoader.h
+  #SimpleTexturedDirectx11/VertexShader.hlsl
   SimpleTexturedDirectx11/main.cpp
   SimpleTexturedDirectx11/SafeRelease.hpp
   ${SAMPLES_SHARED_CODE_DIR}/UTFConverter.cpp
diff --git a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/ModelLoader.cpp b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/ModelLoader.cpp
index 92760d691c..18bb10f1eb 100644
--- a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/ModelLoader.cpp
+++ b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/ModelLoader.cpp
@@ -1,6 +1,6 @@
 #include "ModelLoader.h"
 
-ModelLoader::ModelLoader() : 
+ModelLoader::ModelLoader() :
         dev_(nullptr),
         devcon_(nullptr),
         meshes_(),
diff --git a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/TextureLoader.cpp b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/TextureLoader.cpp
index 01ba343e82..a02c53ca60 100644
--- a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/TextureLoader.cpp
+++ b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/TextureLoader.cpp
@@ -140,16 +140,16 @@ static WICConvert g_WICConvert[] =
 
 	{ GUID_WICPixelFormatBlackWhite,            GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM
 
-	{ GUID_WICPixelFormat1bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat2bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat4bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat8bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
+	{ GUID_WICPixelFormat1bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat2bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat4bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat8bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 
-	{ GUID_WICPixelFormat2bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM 
-	{ GUID_WICPixelFormat4bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM 
+	{ GUID_WICPixelFormat2bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM
+	{ GUID_WICPixelFormat4bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM
 
-	{ GUID_WICPixelFormat16bppGrayFixedPoint,   GUID_WICPixelFormat16bppGrayHalf }, // DXGI_FORMAT_R16_FLOAT 
-	{ GUID_WICPixelFormat32bppGrayFixedPoint,   GUID_WICPixelFormat32bppGrayFloat }, // DXGI_FORMAT_R32_FLOAT 
+	{ GUID_WICPixelFormat16bppGrayFixedPoint,   GUID_WICPixelFormat16bppGrayHalf }, // DXGI_FORMAT_R16_FLOAT
+	{ GUID_WICPixelFormat32bppGrayFixedPoint,   GUID_WICPixelFormat32bppGrayFloat }, // DXGI_FORMAT_R32_FLOAT
 
 #ifdef DXGI_1_2_FORMATS
 
@@ -165,10 +165,10 @@ static WICConvert g_WICConvert[] =
 
 	{ GUID_WICPixelFormat32bppBGR101010,        GUID_WICPixelFormat32bppRGBA1010102 }, // DXGI_FORMAT_R10G10B10A2_UNORM
 
-	{ GUID_WICPixelFormat24bppBGR,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat24bppRGB,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat32bppPBGRA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
-	{ GUID_WICPixelFormat32bppPRGBA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
+	{ GUID_WICPixelFormat24bppBGR,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat24bppRGB,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat32bppPBGRA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
+	{ GUID_WICPixelFormat32bppPRGBA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 
 	{ GUID_WICPixelFormat48bppRGB,              GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat48bppBGR,              GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
@@ -176,21 +176,21 @@ static WICConvert g_WICConvert[] =
 	{ GUID_WICPixelFormat64bppPRGBA,            GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat64bppPBGRA,            GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 
-	{ GUID_WICPixelFormat48bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat48bppBGRFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat64bppRGBAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat64bppBGRAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat64bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat64bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-	{ GUID_WICPixelFormat48bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
-
-	{ GUID_WICPixelFormat96bppRGBFixedPoint,    GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-	{ GUID_WICPixelFormat128bppPRGBAFloat,      GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-	{ GUID_WICPixelFormat128bppRGBFloat,        GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-	{ GUID_WICPixelFormat128bppRGBAFixedPoint,  GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-	{ GUID_WICPixelFormat128bppRGBFixedPoint,   GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
-
-	{ GUID_WICPixelFormat32bppCMYK,             GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
+	{ GUID_WICPixelFormat48bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat48bppBGRFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat64bppRGBAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat64bppBGRAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat64bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat64bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+	{ GUID_WICPixelFormat48bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
+
+	{ GUID_WICPixelFormat96bppRGBFixedPoint,    GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+	{ GUID_WICPixelFormat128bppPRGBAFloat,      GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+	{ GUID_WICPixelFormat128bppRGBFloat,        GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+	{ GUID_WICPixelFormat128bppRGBAFixedPoint,  GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+	{ GUID_WICPixelFormat128bppRGBFixedPoint,   GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT
+
+	{ GUID_WICPixelFormat32bppCMYK,             GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 	{ GUID_WICPixelFormat64bppCMYK,             GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat40bppCMYKAlpha,        GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
 	{ GUID_WICPixelFormat80bppCMYKAlpha,        GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
@@ -198,7 +198,7 @@ static WICConvert g_WICConvert[] =
 #if (_WIN32_WINNT >= 0x0602 /*_WIN32_WINNT_WIN8*/)
 	{ GUID_WICPixelFormat32bppRGB,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
 	{ GUID_WICPixelFormat64bppRGB,              GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
-	{ GUID_WICPixelFormat64bppPRGBAHalf,        GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
+	{ GUID_WICPixelFormat64bppPRGBAHalf,        GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT
 #endif
 
 																					// We don't support n-channel formats
diff --git a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/main.cpp b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/main.cpp
index 02e2b6088e..3f8d153201 100644
--- a/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/main.cpp
+++ b/samples/SimpleTexturedDirectx11/SimpleTexturedDirectx11/main.cpp
@@ -128,7 +128,7 @@ int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/,
 	int argc;
 	LPWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &argc);
 	if (!argv) {
-		MessageBox(nullptr, 
+		MessageBox(nullptr,
 			TEXT("An error occured while reading command line arguments."),
 			TEXT("Error!"),
 			MB_ICONERROR | MB_OK);
@@ -145,8 +145,8 @@ int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/,
 
 	// Ensure that a model file has been specified.
 	if (argc < 2) {
-		MessageBox(nullptr, 
-			TEXT("No model file specified. The program will now close."), 
+		MessageBox(nullptr,
+			TEXT("No model file specified. The program will now close."),
 			TEXT("Error!"),
 			MB_ICONERROR | MB_OK);
 		free_command_line_allocated_memory();
@@ -157,7 +157,7 @@ int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/,
 	g_ModelPath = UTFConverter(argv[1]).str();
 
 	free_command_line_allocated_memory();
-	
+
 	WNDCLASSEX wc;
 	MSG msg;
 
@@ -573,7 +573,7 @@ void InitGraphics()
 HRESULT	CompileShaderFromFile(LPCWSTR pFileName, const D3D_SHADER_MACRO* pDefines, LPCSTR pEntryPoint, LPCSTR pShaderModel, ID3DBlob** ppBytecodeBlob)
 {
 	UINT compileFlags = D3DCOMPILE_ENABLE_STRICTNESS | D3DCOMPILE_PACK_MATRIX_COLUMN_MAJOR;
-	
+
 #ifdef _DEBUG
 	compileFlags |= D3DCOMPILE_DEBUG;
 #endif
diff --git a/samples/SimpleTexturedOpenGL/SimpleTexturedOpenGL/src/model_loading.cpp b/samples/SimpleTexturedOpenGL/SimpleTexturedOpenGL/src/model_loading.cpp
index aa23441186..9ceeec62e6 100644
--- a/samples/SimpleTexturedOpenGL/SimpleTexturedOpenGL/src/model_loading.cpp
+++ b/samples/SimpleTexturedOpenGL/SimpleTexturedOpenGL/src/model_loading.cpp
@@ -579,7 +579,7 @@ void KillGLWindow()			// Properly Kill The Window
 		if (!DestroyWindow(g_hWnd)) // Are We Able To Destroy The Window
 			MessageBox(nullptr, TEXT("Could Not Release hWnd."), TEXT("SHUTDOWN ERROR"), MB_OK | MB_ICONINFORMATION);
 		g_hWnd = nullptr;
-	} 
+	}
 
 	if (g_hInstance)
 	{
@@ -727,7 +727,7 @@ BOOL CreateGLWindow(const char* title, int width, int height, int bits, bool ful
 		return FALSE;
 	}
 
-	if (nullptr == (hRC=wglCreateContext(hDC))) 
+	if (nullptr == (hRC=wglCreateContext(hDC)))
 	{
 		abortGLInit("Can't Create A GL Rendering Context.");
 		return FALSE;
diff --git a/test/models-nonbsd/3D/mar_rifle.source.txt b/test/models-nonbsd/3D/mar_rifle.source.txt
index c0cd5fe6db..d7183b7b6f 100644
--- a/test/models-nonbsd/3D/mar_rifle.source.txt
+++ b/test/models-nonbsd/3D/mar_rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/3DS/cart_wheel.source.txt b/test/models-nonbsd/3DS/cart_wheel.source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/3DS/cart_wheel.source.txt
+++ b/test/models-nonbsd/3DS/cart_wheel.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/3DS/mar_rifle.source.txt b/test/models-nonbsd/3DS/mar_rifle.source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/3DS/mar_rifle.source.txt
+++ b/test/models-nonbsd/3DS/mar_rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/3DS/mp5_sil.source.txt b/test/models-nonbsd/3DS/mp5_sil.source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/3DS/mp5_sil.source.txt
+++ b/test/models-nonbsd/3DS/mp5_sil.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/ASE/Rifle.source.txt b/test/models-nonbsd/ASE/Rifle.source.txt
index 1b96f8564a..802c57045a 100644
--- a/test/models-nonbsd/ASE/Rifle.source.txt
+++ b/test/models-nonbsd/ASE/Rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/ASE/Rifle2.source.txt b/test/models-nonbsd/ASE/Rifle2.source.txt
index 3fa628db49..7b50d16459 100644
--- a/test/models-nonbsd/ASE/Rifle2.source.txt
+++ b/test/models-nonbsd/ASE/Rifle2.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/BLEND/fleurOptonl.source.txt b/test/models-nonbsd/BLEND/fleurOptonl.source.txt
index b9c58b5d99..d4c5836201 100644
--- a/test/models-nonbsd/BLEND/fleurOptonl.source.txt
+++ b/test/models-nonbsd/BLEND/fleurOptonl.source.txt
@@ -10,7 +10,7 @@ Puoi utilizzarlo liberamente, modificarlo e migliorarlo.
 ************* Ma attenzione!! *********************
 
 Nel modificare e utilizzare i modelli, ricorda comunque sempre che :
-"il diritto morale all'integrità dell'opera (diritto dell'autore originale) non ti consente di apportare all'opera deformazioni o modificazioni, od ogni altro atto a danno dell'opera stessa, che possano essere di pregiudizio all'onore o alla reputazione dell'autore (la valutazione della lesione dell'onore o della reputazione avviene sulla base di elementi psicologici soggettivi)" 
+"il diritto morale all'integrità dell'opera (diritto dell'autore originale) non ti consente di apportare all'opera deformazioni o modificazioni, od ogni altro atto a danno dell'opera stessa, che possano essere di pregiudizio all'onore o alla reputazione dell'autore (la valutazione della lesione dell'onore o della reputazione avviene sulla base di elementi psicologici soggettivi)"
 (dalle faq di Creative Commons Italia)
 http://www.creativecommons.it/node/165#27
 
@@ -26,7 +26,7 @@ In particolare, sara' da me considerata lesione d'onore l'uso e/o l'adattamento
 
 Se lo fate rischiate la denuncia e il risarcimento danni.
 Per qualsiasi chiarimento in proposito potete comunque scrivermi.
-Questo e' un diritto garantito per legge a me come ad ogni altro artista. 
+Questo e' un diritto garantito per legge a me come ad ogni altro artista.
 L'utilizzo della Creative Commons non influisce su questo diritto.
 
 ************************************************
@@ -45,7 +45,7 @@ work, so you are not allowed to do exactely what you want with my models.
 The author (that is me) has the right to prevent distortion, mutilation, or other modification of his work which would be prejudicial to his or her honor or reputation.
 
 Me, i consider to be prejudicial to my honor, the modification and/or the use of my models in projects that are related to:
- 
+
 	Racism and hatred instigation.
 	War promotion.
 	Cruelty toward animals.
@@ -69,15 +69,15 @@ Note
 
 Questo e' stato il mio secondo modello completo.
 Per questo motivo potrebbe contenere errori e imprecisioni.
- 
+
 Al momento, questi sono i difetti che ho notato:
-	
+
 	- Non e' nell'origine degli assi.
 	- lo scheletro ha il centro spostato di lato
 	- Nel texture sheet c'e' spazio sprecato.
-	
 
-	
+
+
 ###################
 
 Notes
@@ -86,7 +86,7 @@ This was my first complete model, so it probably contains something
 wrong.
 
 At the moment, this is what i noticed:
-	
+
 	- She's not in the origin of axis
 	- Armature's center is not in armature's center.
 	- Texture sheet contains wasted space.
diff --git a/test/models-nonbsd/DXF/rifle.source.txt b/test/models-nonbsd/DXF/rifle.source.txt
index a2585afadc..fa25f10db7 100644
--- a/test/models-nonbsd/DXF/rifle.source.txt
+++ b/test/models-nonbsd/DXF/rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/FBX/2013_ASCII/cart_wheel.source.txt b/test/models-nonbsd/FBX/2013_ASCII/cart_wheel.source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/FBX/2013_ASCII/cart_wheel.source.txt
+++ b/test/models-nonbsd/FBX/2013_ASCII/cart_wheel.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_ASCII/kwxport_test_vcolors.fbx.source.txt b/test/models-nonbsd/FBX/2013_ASCII/kwxport_test_vcolors.fbx.source.txt
index 94ee48e4aa..7c81e612f8 100644
--- a/test/models-nonbsd/FBX/2013_ASCII/kwxport_test_vcolors.fbx.source.txt
+++ b/test/models-nonbsd/FBX/2013_ASCII/kwxport_test_vcolors.fbx.source.txt
@@ -1,9 +1,9 @@
 From kwxport
 http://www.kwxport.org/
 
->> 
-The kW Xport plug-in source is released under the MIT license. 
-Basically, it means "feel free to use it; credit the source; don't sue me 
+>>
+The kW Xport plug-in source is released under the MIT license.
+Basically, it means "feel free to use it; credit the source; don't sue me
 if something goes wrong."
 >>
 
diff --git a/test/models-nonbsd/FBX/2013_ASCII/mar_rifle.source.txt b/test/models-nonbsd/FBX/2013_ASCII/mar_rifle.source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/FBX/2013_ASCII/mar_rifle.source.txt
+++ b/test/models-nonbsd/FBX/2013_ASCII/mar_rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_ASCII/mp5_sil.source.txt b/test/models-nonbsd/FBX/2013_ASCII/mp5_sil.source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/FBX/2013_ASCII/mp5_sil.source.txt
+++ b/test/models-nonbsd/FBX/2013_ASCII/mp5_sil.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_BINARY/cart_wheel.source.txt b/test/models-nonbsd/FBX/2013_BINARY/cart_wheel.source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/FBX/2013_BINARY/cart_wheel.source.txt
+++ b/test/models-nonbsd/FBX/2013_BINARY/cart_wheel.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_BINARY/kwxport_test_vcolors.fbx.source.txt b/test/models-nonbsd/FBX/2013_BINARY/kwxport_test_vcolors.fbx.source.txt
index 94ee48e4aa..7c81e612f8 100644
--- a/test/models-nonbsd/FBX/2013_BINARY/kwxport_test_vcolors.fbx.source.txt
+++ b/test/models-nonbsd/FBX/2013_BINARY/kwxport_test_vcolors.fbx.source.txt
@@ -1,9 +1,9 @@
 From kwxport
 http://www.kwxport.org/
 
->> 
-The kW Xport plug-in source is released under the MIT license. 
-Basically, it means "feel free to use it; credit the source; don't sue me 
+>>
+The kW Xport plug-in source is released under the MIT license.
+Basically, it means "feel free to use it; credit the source; don't sue me
 if something goes wrong."
 >>
 
diff --git a/test/models-nonbsd/FBX/2013_BINARY/mar_rifle.source.txt b/test/models-nonbsd/FBX/2013_BINARY/mar_rifle.source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/FBX/2013_BINARY/mar_rifle.source.txt
+++ b/test/models-nonbsd/FBX/2013_BINARY/mar_rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/FBX/2013_BINARY/mp5_sil.source.txt b/test/models-nonbsd/FBX/2013_BINARY/mp5_sil.source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/FBX/2013_BINARY/mp5_sil.source.txt
+++ b/test/models-nonbsd/FBX/2013_BINARY/mp5_sil.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/LWO/LWO2/LWSReferences/QuickDraw.source.txt b/test/models-nonbsd/LWO/LWO2/LWSReferences/QuickDraw.source.txt
index aaa2442171..80afd30a74 100644
--- a/test/models-nonbsd/LWO/LWO2/LWSReferences/QuickDraw.source.txt
+++ b/test/models-nonbsd/LWO/LWO2/LWSReferences/QuickDraw.source.txt
@@ -1,10 +1,10 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
-"These 3d models are contributed by John Hoffman and are based on 
-characters from a cartoon show called "Jayce and the wheel warriors" 
+"These 3d models are contributed by John Hoffman and are based on
+characters from a cartoon show called "Jayce and the wheel warriors"
 (except the marauder) John's site: http://www3.sympatico.ca/john.hoffman"
 
 =====================================================================
@@ -15,9 +15,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/LWO/LWO2/rifle.source.txt b/test/models-nonbsd/LWO/LWO2/rifle.source.txt
index 5523bbc0c2..5774ecc0e9 100644
--- a/test/models-nonbsd/LWO/LWO2/rifle.source.txt
+++ b/test/models-nonbsd/LWO/LWO2/rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models-nonbsd/MD2/source.txt b/test/models-nonbsd/MD2/source.txt
index 6f43a3a228..bf74fa0574 100644
--- a/test/models-nonbsd/MD2/source.txt
+++ b/test/models-nonbsd/MD2/source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,8 +11,8 @@ Notice found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
diff --git a/test/models-nonbsd/MD5/BoarMan.source.txt b/test/models-nonbsd/MD5/BoarMan.source.txt
index 50b2dfb539..69f0c79a26 100644
--- a/test/models-nonbsd/MD5/BoarMan.source.txt
+++ b/test/models-nonbsd/MD5/BoarMan.source.txt
@@ -1,8 +1,8 @@
 
-License: Creative Commons 
+License: Creative Commons
 			- Remix
 			- Share alike
 			- Attribution Author: zphr (Christian Lenke)
-			
+
 
 
diff --git a/test/models-nonbsd/MDL/IDPO (Quake1)/gijoe-readme.txt b/test/models-nonbsd/MDL/IDPO (Quake1)/gijoe-readme.txt
index 2febb05836..84ce9fd95f 100644
--- a/test/models-nonbsd/MDL/IDPO (Quake1)/gijoe-readme.txt	
+++ b/test/models-nonbsd/MDL/IDPO (Quake1)/gijoe-readme.txt	
@@ -4,9 +4,9 @@ Version  : 1
 Date     : 11/05/97
 Author   : Kenneth Whelan
 Email    : JWHELAN@pop.prodigy.net
-Credits  : id software, Larry Hama, Steven Polge, and Rene Post for making Quake ME 
-					
-	
+Credits  : id software, Larry Hama, Steven Polge, and Rene Post for making Quake ME
+
+
 
 Build time: ??? Time???
 
@@ -14,7 +14,7 @@ Type of Mod
 -----------
 Quake C  : no
 Sound    : no
-MDL      : Yes  
+MDL      : Yes
 
 
 Format of QuakeC (if a Quake C Mod)
@@ -29,8 +29,8 @@ Description of the Modification
 -------------------------------
 
 This is a new player.mdl for quake. It's main use is for bots. The Skins are Snake Eyes v4, Duke v3, Low-Light,
-Storm Shadow v2, Shockwave, Repeater, Gung-Ho, Shipwreck, Dusty v3, and 
-Tunnel Rat v2. 
+Storm Shadow v2, Shockwave, Repeater, Gung-Ho, Shipwreck, Dusty v3, and
+Tunnel Rat v2.
 
 
 
@@ -40,7 +40,7 @@ None that I know of.
 How to Install the Modification
 -------------------------------
 
-First back up the current player.mdl(copy player.mdl player.bak). Just put 
+First back up the current player.mdl(copy player.mdl player.bak). Just put
 it in the progs dir in the hack your using, if any.
 
 Technical Details
diff --git a/test/models-nonbsd/MDL/IDPO (Quake1)/steg.txt b/test/models-nonbsd/MDL/IDPO (Quake1)/steg.txt
index c07c2f126d..cbddccb7ec 100644
--- a/test/models-nonbsd/MDL/IDPO (Quake1)/steg.txt	
+++ b/test/models-nonbsd/MDL/IDPO (Quake1)/steg.txt	
@@ -16,17 +16,17 @@ E-mail:  sgalbrai@linknet.kitsap.lib.wa.us
 WWW:     www.oz.net/~simitar
 
 
-This model can be used or modified for any purpose 
+This model can be used or modified for any purpose
 as long as this text document is included with it
-and all modellers listed in this document are 
+and all modellers listed in this document are
 listed wherever credits are appropriate for that
 purpose.
 
 
-Help Wanted:  
+Help Wanted:
 
 The Free Models Project can use help with
-models and in other areas, such as legal boilerplate 
+models and in other areas, such as legal boilerplate
 for models.
 
 WWW:     www.oz.net/~simitar/model.html
diff --git a/test/models-nonbsd/MDL/IDPO (Quake1)/tekmechbot.txt b/test/models-nonbsd/MDL/IDPO (Quake1)/tekmechbot.txt
index dc0149b01c..3b3dd90423 100644
--- a/test/models-nonbsd/MDL/IDPO (Quake1)/tekmechbot.txt	
+++ b/test/models-nonbsd/MDL/IDPO (Quake1)/tekmechbot.txt	
@@ -8,7 +8,7 @@ that the FMP is a great concept !!
 
 There is some movement in the model.
 The legs can be animated for walking, stomping, or running
-around ! 
+around !
 Ok, it's my first model, so I will work on less polygony
 in the future ;-)
 
@@ -18,9 +18,9 @@ Contact:       ebuy@optelnow.net  (E-MAIL)
 Date Created:  7/07/2000
 ======================================================
 
-This model can be used or modified for any purpose 
+This model can be used or modified for any purpose
 as long as this text document is included with it
-and all modelers listed in this document are 
+and all modelers listed in this document are
 listed wherever credits are appropriate for that
 purpose.
 
diff --git a/test/models-nonbsd/NFF/NFFSense8/credits.txt b/test/models-nonbsd/NFF/NFFSense8/credits.txt
index f3cef4d09d..bad7fbf157 100644
--- a/test/models-nonbsd/NFF/NFFSense8/credits.txt
+++ b/test/models-nonbsd/NFF/NFFSense8/credits.txt
@@ -1,4 +1,4 @@
 teapot.nff, home4.nff - http://www.martinreddy.net/ukvrsig/wtk.html
 
-cokecan.nff -www.vrupl.evl.uic.edu/Eng591_Pages/cokecan.nff 
+cokecan.nff -www.vrupl.evl.uic.edu/Eng591_Pages/cokecan.nff
 TODO: License status to be confirmed
diff --git a/test/models-nonbsd/OBJ/rifle.source.txt b/test/models-nonbsd/OBJ/rifle.source.txt
index 1d2cec5cfa..f7b93fd0f9 100644
--- a/test/models-nonbsd/OBJ/rifle.source.txt
+++ b/test/models-nonbsd/OBJ/rifle.source.txt
@@ -1,7 +1,7 @@
 =====================================================================
 
 From http://telias.free.fr
-Model copyright: Elias Tsiantas 
+Model copyright: Elias Tsiantas
 
 =====================================================================
 
@@ -11,9 +11,9 @@ Notices found on the page:
 "
 Free the models is a site that offers free 3d models in 3ds, bryce, poser,
 lightwave and md2 format. Also a great collection of textures to use in
-your favorite modelling and rendering program. All the content is free 
+your favorite modelling and rendering program. All the content is free
 for any use. In the future more 3d formats will be added and some other
-sections such as wallpapers, 3d screensavers, 3d coding source code and 
+sections such as wallpapers, 3d screensavers, 3d coding source code and
 tutorials.
 "
 
diff --git a/test/models/3DS/UVTransformTest/note.txt b/test/models/3DS/UVTransformTest/note.txt
index 4c8bfedd2e..9a6bab0309 100644
--- a/test/models/3DS/UVTransformTest/note.txt
+++ b/test/models/3DS/UVTransformTest/note.txt
@@ -1,5 +1,5 @@
-All 'mirror' files are not absolutely correct. That's mainly 
-because it's difficult convert Max' handling of mirroring to 
+All 'mirror' files are not absolutely correct. That's mainly
+because it's difficult convert Max' handling of mirroring to
 our's.
 
 In other words: TO DO, but only if someone REALLY needs it.
diff --git a/test/models/ASE/MotionCaptureROM.source.txt b/test/models/ASE/MotionCaptureROM.source.txt
index 2b961906a7..f34e056ef9 100644
--- a/test/models/ASE/MotionCaptureROM.source.txt
+++ b/test/models/ASE/MotionCaptureROM.source.txt
@@ -1,3 +1,3 @@
-"MotionCaptureROM.ase" - Free for any purpose. 
+"MotionCaptureROM.ase" - Free for any purpose.
 
 NOTE: The errors in the middle of the animation are caused by problems during recording, it's not an importer issue.
diff --git a/test/models/Collada/kwxport_test_vcolors.dae.source.txt b/test/models/Collada/kwxport_test_vcolors.dae.source.txt
index 94ee48e4aa..7c81e612f8 100644
--- a/test/models/Collada/kwxport_test_vcolors.dae.source.txt
+++ b/test/models/Collada/kwxport_test_vcolors.dae.source.txt
@@ -1,9 +1,9 @@
 From kwxport
 http://www.kwxport.org/
 
->> 
-The kW Xport plug-in source is released under the MIT license. 
-Basically, it means "feel free to use it; credit the source; don't sue me 
+>>
+The kW Xport plug-in source is released under the MIT license.
+Basically, it means "feel free to use it; credit the source; don't sue me
 if something goes wrong."
 >>
 
diff --git a/test/models/IRR/warn_dwarf_scaling_is_intended.txt b/test/models/IRR/warn_dwarf_scaling_is_intended.txt
index f651a8643b..d0e4ea3616 100644
--- a/test/models/IRR/warn_dwarf_scaling_is_intended.txt
+++ b/test/models/IRR/warn_dwarf_scaling_is_intended.txt
@@ -1,3 +1,3 @@
 for dawfInCellar_ChildOfCellar & dawfInCellar_SameHierarchy:
 
-the strange scalings of cellar and dwarf are intended. 
+the strange scalings of cellar and dwarf are intended.
diff --git a/test/models/MD2/faerie-source.txt b/test/models/MD2/faerie-source.txt
index 4906ff4d10..afb00a1704 100644
--- a/test/models/MD2/faerie-source.txt
+++ b/test/models/MD2/faerie-source.txt
@@ -1,5 +1,5 @@
 
-From IRRLICHT/media 
+From IRRLICHT/media
 
 
 The Irrlicht Engine License
diff --git a/test/models/MD2/sidney-source.txt b/test/models/MD2/sidney-source.txt
index 4906ff4d10..afb00a1704 100644
--- a/test/models/MD2/sidney-source.txt
+++ b/test/models/MD2/sidney-source.txt
@@ -1,5 +1,5 @@
 
-From IRRLICHT/media 
+From IRRLICHT/media
 
 
 The Irrlicht Engine License
diff --git a/test/models/Q3D/E-AT-AT.source.txt b/test/models/Q3D/E-AT-AT.source.txt
index 2df8826f19..900ee552c4 100644
--- a/test/models/Q3D/E-AT-AT.source.txt
+++ b/test/models/Q3D/E-AT-AT.source.txt
@@ -5,4 +5,4 @@ Downloaded 4th November 08 (Obama ftw!)
 Copyright notice found on the page:
 
 Where do the models in the archive come from?
-All 3D files available from the3darchive.com are from the public domain. 
+All 3D files available from the3darchive.com are from the public domain.
diff --git a/test/models/Q3D/earth.source.txt b/test/models/Q3D/earth.source.txt
index 2df8826f19..900ee552c4 100644
--- a/test/models/Q3D/earth.source.txt
+++ b/test/models/Q3D/earth.source.txt
@@ -5,4 +5,4 @@ Downloaded 4th November 08 (Obama ftw!)
 Copyright notice found on the page:
 
 Where do the models in the archive come from?
-All 3D files available from the3darchive.com are from the public domain. 
+All 3D files available from the3darchive.com are from the public domain.
diff --git a/test/models/WRL/credits.txt b/test/models/WRL/credits.txt
index 055f73734e..7be7fa1927 100644
--- a/test/models/WRL/credits.txt
+++ b/test/models/WRL/credits.txt
@@ -1,2 +1,2 @@
 "MotionCaptureROM.ase" Recorded using ViconIQ.
-Converted to VRML with 3DS Max 2008. 
+Converted to VRML with 3DS Max 2008.
diff --git a/test/models/X/anim_test.txt b/test/models/X/anim_test.txt
index 3d270dc7df..f2ef6c0560 100644
--- a/test/models/X/anim_test.txt
+++ b/test/models/X/anim_test.txt
@@ -4,6 +4,6 @@ Frame 1 - 10: Zylinder knickt ein, so dass der Knick in Richtung z+ zeigt.
 Frame 10 - 18: Zylinder-Spitze streckt sich in Richtung z-.
 Frame 18 - 24: Zylinder-Spitze bewegt sich zu Position in Richtung x+
 
-Remarks: The exporter failed here for some reasons... although the mesh referres to four bones, only two of them are stored in the corresponding node hierarchy. So you have a mesh with 4 bones, a hirarchy with 2 nodes and a animation that affects only those two nodes. 
+Remarks: The exporter failed here for some reasons... although the mesh referres to four bones, only two of them are stored in the corresponding node hierarchy. So you have a mesh with 4 bones, a hirarchy with 2 nodes and a animation that affects only those two nodes.
 
 There is no timing given for the animation. You have to scale the animation manually. For this file, the timing seems to be 24 ticks per second.
diff --git a/test/models/X/kwxport_test_cubewithvcolors.source.txt b/test/models/X/kwxport_test_cubewithvcolors.source.txt
index 94ee48e4aa..7c81e612f8 100644
--- a/test/models/X/kwxport_test_cubewithvcolors.source.txt
+++ b/test/models/X/kwxport_test_cubewithvcolors.source.txt
@@ -1,9 +1,9 @@
 From kwxport
 http://www.kwxport.org/
 
->> 
-The kW Xport plug-in source is released under the MIT license. 
-Basically, it means "feel free to use it; credit the source; don't sue me 
+>>
+The kW Xport plug-in source is released under the MIT license.
+Basically, it means "feel free to use it; credit the source; don't sue me
 if something goes wrong."
 >>
 
diff --git a/test/models/X/test.txt b/test/models/X/test.txt
index eaf9d9c3cb..9452855b36 100644
--- a/test/models/X/test.txt
+++ b/test/models/X/test.txt
@@ -1,3 +1,3 @@
 Simple textured test cube exported from Maya. Has a texture that does label each cube side uniquely, but the sides do not match DirectX coordinate space.
 
-Is not readable using D3DXLoadFrameHierarchy, needs custom text parsing. 
+Is not readable using D3DXLoadFrameHierarchy, needs custom text parsing.
diff --git a/test/models/invalid/readme.txt b/test/models/invalid/readme.txt
index cab740a844..6ad8b4380d 100644
--- a/test/models/invalid/readme.txt
+++ b/test/models/invalid/readme.txt
@@ -4,9 +4,9 @@ GENERAL
 *********************************************************
 
 
-The files in this directory are invalid ... some of them are empty, 
+The files in this directory are invalid ... some of them are empty,
 others have invalid vertices or faces, others are prepared to make
- assimp allocate a few hundreds gigs of memory ... most are 
+ assimp allocate a few hundreds gigs of memory ... most are
 actually regression tests, i.e. there was once a bugfix that
 fixed the respective loaders.
 
@@ -18,8 +18,8 @@ crash.
 FILES
 *********************************************************
 
-OutOfMemory.off - the number of faces is invalid. There won't be 
-  enough memory so std::vector::reserve() will most likely fail. 
+OutOfMemory.off - the number of faces is invalid. There won't be
+  enough memory so std::vector::reserve() will most likely fail.
   The exception should be caught in Importer.cpp.
 
 empty.<x> - These files are completely empty. The corresponding
diff --git a/test/regression/README.txt b/test/regression/README.txt
index 3e90a143b2..a37da9255c 100644
--- a/test/regression/README.txt
+++ b/test/regression/README.txt
@@ -8,7 +8,7 @@ against a regression database provided with assimp (db.zip). A few failures
 are totally fine (see sections 7+). You need to worry if a huge
 majority of all files in a particular format (or post-processing configuration)
 fails as this might be a sign of a recent regression in assimp's codebase or
-gross incompatibility with your system or compiler. 
+gross incompatibility with your system or compiler.
 
 2) What do I need?
 ---------------------------------------------------------------------------------
@@ -53,8 +53,8 @@ Edit the reg_settings.py file and add the path to your repository to
 The regression database includes mini dumps of the aiScene data structure, i.e.
 the scene hierarchy plus the sizes of all data arrays MUST match. Floating-point
 data buffers, such as vertex positions are handled less strictly: min, max and
-average values are stored with low precision. This takes hardware- or 
-compiler-specific differences in floating-point computations into account. 
+average values are stored with low precision. This takes hardware- or
+compiler-specific differences in floating-point computations into account.
 Generally, almost all significant regressions will be detected while the
 number of false positives is relatively low.
 
diff --git a/test/unit/AbstractImportExportBase.h b/test/unit/AbstractImportExportBase.h
index 72530aedcd..7651d2e52a 100644
--- a/test/unit/AbstractImportExportBase.h
+++ b/test/unit/AbstractImportExportBase.h
@@ -67,7 +67,7 @@ bool AbstractImportExportBase::importerTest() {
     return true;
 }
 
-inline 
+inline
 bool AbstractImportExportBase::exporterTest() {
     return true;
 }
diff --git a/test/unit/Common/utStandardShapes.cpp b/test/unit/Common/utStandardShapes.cpp
index a5df5d8988..e1bb6eef95 100644
--- a/test/unit/Common/utStandardShapes.cpp
+++ b/test/unit/Common/utStandardShapes.cpp
@@ -51,7 +51,7 @@ TEST_F( utStandardShapes, testMakeMesh ) {
 
     // The mNumIndices member of the second face is now incorrect
     const auto& face = aiMeshPtr->mFaces[0];
-    EXPECT_EQ(face.mNumIndices, numIndicesPerPrimitive); 
+    EXPECT_EQ(face.mNumIndices, numIndicesPerPrimitive);
     delete aiMeshPtr;
 }
 
diff --git a/test/unit/ImportExport/MDL/utMDLImporter_HL1_Nodes.cpp b/test/unit/ImportExport/MDL/utMDLImporter_HL1_Nodes.cpp
index ff3b4930c8..6fa92f950d 100644
--- a/test/unit/ImportExport/MDL/utMDLImporter_HL1_Nodes.cpp
+++ b/test/unit/ImportExport/MDL/utMDLImporter_HL1_Nodes.cpp
@@ -73,7 +73,7 @@ class utMDLImporter_HL1_Nodes : public ::testing::Test {
         "Bone_3"       |
         ""        <----+
         "Bone_2"       |
-        "Bone_5"       | 
+        "Bone_5"       |
         ""        <----+
         ""        <----+
     */
@@ -139,7 +139,7 @@ class utMDLImporter_HL1_Nodes : public ::testing::Test {
         $body "Bodypart_1" <--+  |
         $body "Bodypart_2"    |  |
         $body "Bodypart1"     |  |
-        $body "Bodypart"   ---|--+ 
+        $body "Bodypart"   ---|--+
         $body "Bodypart_1" ---+  |
         $body "Bodypart2"        |
         $body "Bodypart"   ------+
diff --git a/test/unit/RandomNumberGeneration.h b/test/unit/RandomNumberGeneration.h
index 81fcfb59c8..892e78c061 100644
--- a/test/unit/RandomNumberGeneration.h
+++ b/test/unit/RandomNumberGeneration.h
@@ -53,11 +53,11 @@ class RandomUniformRealGenerator {
 public:
     RandomUniformRealGenerator() :
             dist_(),
-            rd_(), 
+            rd_(),
             re_(rd_())  {
         // empty
     }
-    
+
     RandomUniformRealGenerator(T min, T max) :
             dist_(min, max),
             rd_(),
diff --git a/test/unit/SceneDiffer.cpp b/test/unit/SceneDiffer.cpp
index 6ea28671a5..368589bf36 100644
--- a/test/unit/SceneDiffer.cpp
+++ b/test/unit/SceneDiffer.cpp
@@ -48,7 +48,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 namespace Assimp {
 
-SceneDiffer::SceneDiffer() 
+SceneDiffer::SceneDiffer()
 : m_diffs() {
     // empty
 }
diff --git a/test/unit/SceneDiffer.h b/test/unit/SceneDiffer.h
index 9e04c7210e..e0dc6005ac 100644
--- a/test/unit/SceneDiffer.h
+++ b/test/unit/SceneDiffer.h
@@ -72,4 +72,4 @@ class SceneDiffer {
     std::vector<std::string> m_diffs;
 };
 
-} 
+}
diff --git a/test/unit/TestIOSystem.h b/test/unit/TestIOSystem.h
index fdc3cc49b1..4a42b23f05 100644
--- a/test/unit/TestIOSystem.h
+++ b/test/unit/TestIOSystem.h
@@ -61,7 +61,7 @@ class TestIOSystem : public IOSystem {
     virtual ~TestIOSystem() {
         // empty
     }
-    
+
     virtual bool Exists( const char* ) const {
         return true;
     }
diff --git a/test/unit/utDefaultIOStream.cpp b/test/unit/utDefaultIOStream.cpp
index 800fddbc9d..d3e2c8a7eb 100644
--- a/test/unit/utDefaultIOStream.cpp
+++ b/test/unit/utDefaultIOStream.cpp
@@ -66,7 +66,7 @@ TEST_F( utDefaultIOStream, FileSizeTest ) {
     {
         auto written = std::fwrite(data, sizeof(*data), dataCount, fs );
         EXPECT_NE( 0U, written );
-    
+
         auto vflush = std::fflush( fs );
         ASSERT_EQ(vflush, 0);
 
diff --git a/test/unit/utFBXImporterExporter.cpp b/test/unit/utFBXImporterExporter.cpp
index c78d56b970..4cfc9b1523 100644
--- a/test/unit/utFBXImporterExporter.cpp
+++ b/test/unit/utFBXImporterExporter.cpp
@@ -365,7 +365,7 @@ TEST_F(utFBXImporterExporter, importMaxPbrMaterialsMetalRoughness) {
     float bumpMapAmt; // Presumably amount.
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|bump_map_amt", aiTextureType_NONE, 0, bumpMapAmt), aiReturn_SUCCESS);
     EXPECT_EQ(bumpMapAmt, 0.75f);
-    
+
     aiColor4D emitColor;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|emit_color", aiTextureType_NONE, 0, emitColor), aiReturn_SUCCESS);
     EXPECT_EQ(emitColor, aiColor4D(1, 1, 0, 1));
@@ -418,7 +418,7 @@ TEST_F(utFBXImporterExporter, importMaxPbrMaterialsSpecularGloss) {
     float bumpMapAmt; // Presumably amount.
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|bump_map_amt", aiTextureType_NONE, 0, bumpMapAmt), aiReturn_SUCCESS);
     EXPECT_EQ(bumpMapAmt, 0.66f);
-    
+
     aiColor4D emitColor;
     ASSERT_EQ(mat->Get("$raw.3dsMax|main|emit_color", aiTextureType_NONE, 0, emitColor), aiReturn_SUCCESS);
     EXPECT_EQ(emitColor, aiColor4D(1, 0, 1, 1));
diff --git a/test/unit/utFindDegenerates.cpp b/test/unit/utFindDegenerates.cpp
index 1f8e8e93fd..6f2abebfb7 100644
--- a/test/unit/utFindDegenerates.cpp
+++ b/test/unit/utFindDegenerates.cpp
@@ -199,10 +199,10 @@ TEST_F(FindDegeneratesProcessTest, meshRemoval) {
     scene->mRootNode->mMeshes[3] = 3;
     scene->mRootNode->mMeshes[4] = 4;
 
-    mProcess->Execute(scene.get());    
+    mProcess->Execute(scene.get());
 
     EXPECT_EQ(scene->mNumMeshes, 1u);
     EXPECT_EQ(scene->mMeshes[0], meshWhichSurvives);
     EXPECT_EQ(scene->mRootNode->mNumMeshes, 1u);
-    EXPECT_EQ(scene->mRootNode->mMeshes[0], 0u);    
+    EXPECT_EQ(scene->mRootNode->mMeshes[0], 0u);
 }
diff --git a/test/unit/utIOStreamBuffer.cpp b/test/unit/utIOStreamBuffer.cpp
index 6d0d6a7d74..a0e4660dfe 100644
--- a/test/unit/utIOStreamBuffer.cpp
+++ b/test/unit/utIOStreamBuffer.cpp
@@ -81,14 +81,14 @@ TEST_F( IOStreamBufferTest, open_close_Test ) {
 
     EXPECT_FALSE( myBuffer.open( nullptr ) );
     EXPECT_FALSE( myBuffer.close() );
-    
+
     const auto dataSize = sizeof(data);
     const auto dataCount = dataSize / sizeof(*data);
 
     char fname[]={ "octest.XXXXXX" };
     auto* fs = MakeTmpFile(fname);
     ASSERT_NE(nullptr, fs);
-    
+
     auto written = std::fwrite( data, sizeof(*data), dataCount, fs );
     EXPECT_NE( 0U, written );
     auto flushResult = std::fflush( fs );
@@ -107,7 +107,7 @@ TEST_F( IOStreamBufferTest, open_close_Test ) {
 }
 
 TEST_F( IOStreamBufferTest, readlineTest ) {
-    
+
     const auto dataSize = sizeof(data);
     const auto dataCount = dataSize / sizeof(*data);
 
diff --git a/test/unit/utIOSystem.cpp b/test/unit/utIOSystem.cpp
index 767984debc..1e866515e2 100644
--- a/test/unit/utIOSystem.cpp
+++ b/test/unit/utIOSystem.cpp
@@ -50,12 +50,12 @@ using namespace Assimp;
 
 class IOSystemTest : public ::testing::Test {
 public:
-    virtual void SetUp() { 
-        pImp = new TestIOSystem(); 
+    virtual void SetUp() {
+        pImp = new TestIOSystem();
     }
-    
-    virtual void TearDown() { 
-        delete pImp; 
+
+    virtual void TearDown() {
+        delete pImp;
     }
 
 protected:
diff --git a/test/unit/utIssues.cpp b/test/unit/utIssues.cpp
index cb1adb22cb..5eeed6ad8f 100644
--- a/test/unit/utIssues.cpp
+++ b/test/unit/utIssues.cpp
@@ -62,7 +62,7 @@ TEST_F( utIssues, OpacityBugWhenExporting_727 ) {
     aiScene *scene( TestModelFacttory::createDefaultTestModel( opacity ) );
     Assimp::Importer importer;
     Assimp::Exporter exporter;
-                
+
     std::string path = "dae";
     const aiExportFormatDesc *desc = exporter.GetExportFormatDescription( 0 );
     EXPECT_NE( desc, nullptr );
diff --git a/test/unit/utVersion.cpp b/test/unit/utVersion.cpp
index 0189cd2a91..0de6ef39ce 100644
--- a/test/unit/utVersion.cpp
+++ b/test/unit/utVersion.cpp
@@ -55,7 +55,7 @@ TEST_F( utVersion, aiGetLegalStringTest ) {
 TEST_F( utVersion, aiGetVersionMinorTest ) {
     EXPECT_EQ( aiGetVersionMinor(), 0U );
 }
-    
+
 TEST_F( utVersion, aiGetVersionMajorTest ) {
     EXPECT_EQ( aiGetVersionMajor(), 5U );
 }
diff --git a/test/unit/utglTF2ImportExport.cpp b/test/unit/utglTF2ImportExport.cpp
index 2c000bb372..90070d63e4 100644
--- a/test/unit/utglTF2ImportExport.cpp
+++ b/test/unit/utglTF2ImportExport.cpp
@@ -692,7 +692,7 @@ TEST_F(utglTF2ImportExport, indexOutOfRange) {
         }
     };
     LogObserver logObserver;
-    
+
     DefaultLogger::get()->attachStream(&logObserver);
     const aiScene *scene = importer.ReadFile(ASSIMP_TEST_MODELS_DIR "/glTF2/IndexOutOfRange/IndexOutOfRange.gltf", aiProcess_ValidateDataStructure);
     ASSERT_NE(scene, nullptr);
diff --git a/tools/assimp_cmd/CMakeLists.txt b/tools/assimp_cmd/CMakeLists.txt
index 3a39fa7489..5aeac0f7b8 100644
--- a/tools/assimp_cmd/CMakeLists.txt
+++ b/tools/assimp_cmd/CMakeLists.txt
@@ -1,6 +1,6 @@
 # Open Asset Import Library (assimp)
 # ----------------------------------------------------------------------
-# 
+#
 # Copyright (c) 2006-2021, assimp team
 
 
diff --git a/tools/assimp_cmd/Export.cpp b/tools/assimp_cmd/Export.cpp
index 1e2f10541a..6c3c41de96 100644
--- a/tools/assimp_cmd/Export.cpp
+++ b/tools/assimp_cmd/Export.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
diff --git a/tools/assimp_cmd/ImageExtractor.cpp b/tools/assimp_cmd/ImageExtractor.cpp
index 105c4fe371..23aa9c2492 100644
--- a/tools/assimp_cmd/ImageExtractor.cpp
+++ b/tools/assimp_cmd/ImageExtractor.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
@@ -356,6 +356,6 @@ int Assimp_Extract(const char *const *params, unsigned int num) {
             return m;
         }
     }
-    
+
     return AssimpCmdError::Success;
 }
diff --git a/tools/assimp_cmd/Info.cpp b/tools/assimp_cmd/Info.cpp
index e0d511a73d..2c35ba227c 100644
--- a/tools/assimp_cmd/Info.cpp
+++ b/tools/assimp_cmd/Info.cpp
@@ -316,7 +316,7 @@ int Assimp_Info (const char* const* params, unsigned int num) {
 		printf("assimp info: Invalid arguments, verbose and silent at the same time are forbitten. ");
 		return AssimpCmdInfoError::InvalidCombinaisonOfArguments;
 	}
-	
+
 	// Parse post-processing flags unless -r was specified
 	ImportData import;
 	if (!raw) {
diff --git a/tools/assimp_cmd/Main.cpp b/tools/assimp_cmd/Main.cpp
index 2fb7559bb2..8d76e1f5e4 100644
--- a/tools/assimp_cmd/Main.cpp
+++ b/tools/assimp_cmd/Main.cpp
@@ -9,8 +9,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -27,16 +27,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
@@ -47,7 +47,7 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "Main.h"
 
-const char* AICMD_MSG_ABOUT = 
+const char* AICMD_MSG_ABOUT =
 "------------------------------------------------------ \n"
 "Open Asset Import Library (\"Assimp\", https://github.com/assimp/assimp) \n"
 " -- Commandline toolchain --\n"
@@ -55,7 +55,7 @@ const char* AICMD_MSG_ABOUT =
 
 "Version %i.%i %s%s%s%s%s(GIT commit %x)\n\n";
 
-const char* AICMD_MSG_HELP = 
+const char* AICMD_MSG_HELP =
 "assimp <verb> <parameters>\n\n"
 " verbs:\n"
 " \tinfo       - Quick file stats\n"
@@ -106,7 +106,7 @@ int main (int argc, char* argv[])
 	}
 
 	// assimp help
-	// Display some basic help (--help and -h work as well 
+	// Display some basic help (--help and -h work as well
 	// because people could try them intuitively)
 	if (!strcmp(argv[1], "help") || !strcmp(argv[1], "--help") || !strcmp(argv[1], "-h")) {
 		printf("%s",AICMD_MSG_HELP);
@@ -114,7 +114,7 @@ int main (int argc, char* argv[])
 	}
 
 	// assimp cmpdump
-	// Compare two mini model dumps (regression suite) 
+	// Compare two mini model dumps (regression suite)
 	if (! strcmp(argv[1], "cmpdump")) {
 		return Assimp_CompareDump (&argv[2],argc-2);
 	}
@@ -125,7 +125,7 @@ int main (int argc, char* argv[])
 	globalImporter = &imp;
 
 #ifndef ASSIMP_BUILD_NO_EXPORT
-	// 
+	//
 	Assimp::Exporter exp;
 	globalExporter = &exp;
 #endif
@@ -145,7 +145,7 @@ int main (int argc, char* argv[])
 	// List all export file formats supported by Assimp (not the file extensions, just the format identifiers!)
 	if (! strcmp(argv[1], "listexport")) {
 		aiString s;
-		
+
 		for(size_t i = 0, end = exp.GetExportFormatCount(); i < end; ++i) {
 			const aiExportFormatDesc* const e = exp.GetExportFormatDescription(i);
 			s.Append( e->id );
@@ -176,7 +176,7 @@ int main (int argc, char* argv[])
 				return AssimpCmdError::Success;
 			}
 		}
-		
+
 		printf("Unknown file format id: \'%s\'\n",argv[2]);
 		return AssimpCmdError::UnknownFileFormat;
 	}
@@ -207,13 +207,13 @@ int main (int argc, char* argv[])
 		return Assimp_Info ((const char**)&argv[2],argc-2);
 	}
 
-	// assimp dump 
-	// Dump a model to a file 
+	// assimp dump
+	// Dump a model to a file
 	if (! strcmp(argv[1], "dump")) {
 		return Assimp_Dump (&argv[2],argc-2);
 	}
 
-	// assimp extract 
+	// assimp extract
 	// Extract an embedded texture from a file
 	if (! strcmp(argv[1], "extract")) {
 		return Assimp_Extract (&argv[2],argc-2);
@@ -236,7 +236,7 @@ int main (int argc, char* argv[])
 void SetLogStreams(const ImportData& imp)
 {
 	printf("\nAttaching log stream   ...           OK\n");
-		
+
 	unsigned int flags = 0;
 	if (imp.logFile.length()) {
 		flags |= aiDefaultLogStream_FILE;
@@ -264,7 +264,7 @@ void PrintHorBar()
 // ------------------------------------------------------------------------------
 // Import a specific file
 const aiScene* ImportModel(
-	const ImportData& imp, 
+	const ImportData& imp,
 	const std::string& path)
 {
 	// Attach log streams
@@ -282,7 +282,7 @@ const aiScene* ImportModel(
 	if (imp.showLog) {
 		PrintHorBar();
 	}
-		
+
 
 	// do the actual import, measure time
 	const clock_t first = clock();
@@ -302,7 +302,7 @@ const aiScene* ImportModel(
 	printf("Importing file ...                   OK \n   import took approx. %.5f seconds\n"
 		"\n",seconds);
 
-	if (imp.log) { 
+	if (imp.log) {
 		FreeLogStreams();
 	}
 	return scene;
@@ -310,8 +310,8 @@ const aiScene* ImportModel(
 
 #ifndef ASSIMP_BUILD_NO_EXPORT
 // ------------------------------------------------------------------------------
-bool ExportModel(const aiScene* pOut,  
-	const ImportData& imp, 
+bool ExportModel(const aiScene* pOut,
+	const ImportData& imp,
 	const std::string& path,
 	const char* pID)
 {
@@ -352,7 +352,7 @@ bool ExportModel(const aiScene* pOut,
 	printf("Exporting file ...                   OK \n   export took approx. %.5f seconds\n"
 		"\n",seconds);
 
-	if (imp.log) { 
+	if (imp.log) {
 		FreeLogStreams();
 	}
 
@@ -363,7 +363,7 @@ bool ExportModel(const aiScene* pOut,
 // ------------------------------------------------------------------------------
 // Process standard arguments
 int ProcessStandardArguments(
-	ImportData& fill, 
+	ImportData& fill,
 	const char* const * params,
 	unsigned int num)
 {
@@ -396,7 +396,7 @@ int ProcessStandardArguments(
 	//
 	// -c<file> --config-file=<file>
 
-	for (unsigned int i = 0; i < num;++i) 
+	for (unsigned int i = 0; i < num;++i)
 	{
         const char *param = params[ i ];
         printf( "param = %s\n", param );
@@ -504,11 +504,11 @@ int ProcessStandardArguments(
 		else if (!strncmp(params[i], "-rx=", 4) || !strncmp(params[i], "--rotation-x=", 13)) {
             std::string value = std::string(params[i] + (params[i][1] == '-' ? 13 : 4));
             fill.rot.x = std::stof(value);
-		} 
+		}
 		else if (!strncmp(params[i], "-ry=", 4) || !strncmp(params[i], "--rotation-y=", 13)) {
             std::string value = std::string(params[i] + (params[i][1] == '-' ? 13 : 4));
             fill.rot.y = std::stof(value);
-        } 
+        }
 		else if (!strncmp(params[i], "-rz=", 4) || !strncmp(params[i], "--rotation-z=", 13)) {
             std::string value = std::string(params[i] + (params[i][1] == '-' ? 13 : 4));
             fill.rot.z = std::stof(value);
@@ -530,7 +530,7 @@ int ProcessStandardArguments(
 
 // ------------------------------------------------------------------------------
 int Assimp_TestBatchLoad (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num)
 {
 	for(unsigned int i = 0; i < num; ++i) {
diff --git a/tools/assimp_cmd/Main.h b/tools/assimp_cmd/Main.h
index e7fbb6c75c..5ac306abd3 100644
--- a/tools/assimp_cmd/Main.h
+++ b/tools/assimp_cmd/Main.h
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
@@ -144,7 +144,7 @@ enum AssimpCmdError {
  *  @param params Command line parameters to be processed
  *  @param num NUmber of params
  *  @return An #AssimpCmdError value. */
-int ProcessStandardArguments(ImportData& fill, 
+int ProcessStandardArguments(ImportData& fill,
 	const char* const* params,
 	unsigned int num);
 
@@ -153,7 +153,7 @@ int ProcessStandardArguments(ImportData& fill,
  *  @param imp Import configuration to be used
  *  @param path Path to the file to be read */
 const aiScene* ImportModel(
-	const ImportData& imp, 
+	const ImportData& imp,
 	const std::string& path);
 
 #ifndef ASSIMP_BUILD_NO_EXPORT
@@ -163,8 +163,8 @@ const aiScene* ImportModel(
  *  @param imp Import configuration to be used
  *  @param path Path to the file to be written
  *  @param format Format id*/
-bool ExportModel(const aiScene* pOut, 
-	const ImportData& imp, 
+bool ExportModel(const aiScene* pOut,
+	const ImportData& imp,
 	const std::string& path,
 	const char* pID);
 
@@ -176,7 +176,7 @@ bool ExportModel(const aiScene* pOut,
  *  @param Number of params
  *  @return An #AssimpCmdError value.*/
 int Assimp_Dump (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 /// \enum AssimpCmdExportError
@@ -186,7 +186,7 @@ enum AssimpCmdExportError {
 	FailedToExportModel,
 
 	// Add new error codes here...
-	
+
 	LastAssimpCmdExportError, // Must be last.
 };
 
@@ -196,7 +196,7 @@ enum AssimpCmdExportError {
  *  @param Number of params
  *  @return Either an #AssimpCmdError or #AssimpCmdExportError value. */
 int Assimp_Export (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 /// \enum AssimpCmdExtractError
@@ -217,7 +217,7 @@ enum AssimpCmdExtractError {
  *  @param Number of params
  *  @return Either an #AssimpCmdError or #AssimpCmdExtractError value. */
 int Assimp_Extract (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 /// \enum AssimpCmdCompareDumpError
@@ -238,7 +238,7 @@ enum AssimpCmdCompareDumpError {
  *  @param Number of params
  *  @return Either an #AssimpCmdError or #AssimpCmdCompareDumpError. */
 int Assimp_CompareDump (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 /// \enum AssimpCmdInfoError
@@ -257,7 +257,7 @@ enum AssimpCmdInfoError {
  *  @param Number of params
  *  @return Either an #AssimpCmdError or #AssimpCmdInfoError value. */
 int Assimp_Info (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 // ------------------------------------------------------------------------------
@@ -266,7 +266,7 @@ int Assimp_Info (
  *  @param Number of params
  *  @return An #AssimpCmdError value. */
 int Assimp_TestBatchLoad (
-	const char* const* params, 
+	const char* const* params,
 	unsigned int num);
 
 
diff --git a/tools/assimp_cmd/WriteDump.cpp b/tools/assimp_cmd/WriteDump.cpp
index 5809d4ce69..fd8839a174 100644
--- a/tools/assimp_cmd/WriteDump.cpp
+++ b/tools/assimp_cmd/WriteDump.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
diff --git a/tools/assimp_cmd/resource.h b/tools/assimp_cmd/resource.h
index c516b5e5ce..caf3a0a69b 100644
--- a/tools/assimp_cmd/resource.h
+++ b/tools/assimp_cmd/resource.h
@@ -9,7 +9,7 @@
 
 
 // Next default values for new objects
-// 
+//
 #ifdef APSTUDIO_INVOKED
 #ifndef APSTUDIO_READONLY_SYMBOLS
 #define _APS_NO_MFC                     1
diff --git a/tools/assimp_view/AnimEvaluator.h b/tools/assimp_view/AnimEvaluator.h
index 5662476046..394ebef4aa 100644
--- a/tools/assimp_view/AnimEvaluator.h
+++ b/tools/assimp_view/AnimEvaluator.h
@@ -53,7 +53,7 @@ struct aiAnimation;
 
 namespace AssimpView {
 
-/** 
+/**
  *  @brief  Calculates transformations for a given timestamp from a set of animation tracks. Not directly useful,
  *          better use the AnimPlayer class.
  */
@@ -68,15 +68,15 @@ class AnimEvaluator {
     /// @brief  The class destructor.
     ~AnimEvaluator();
 
-    /// @brief Evaluates the animation tracks for a given time stamp. 
-    /// The calculated pose can be retrieved as an array of transformation 
+    /// @brief Evaluates the animation tracks for a given time stamp.
+    /// The calculated pose can be retrieved as an array of transformation
     /// matrices afterwards by calling GetTransformations().
-    /// @param pTime    The time for which you want to evaluate the animation, in seconds. 
-    ///                 Will be mapped into the animation cycle, so it can get an arbitrary 
+    /// @param pTime    The time for which you want to evaluate the animation, in seconds.
+    ///                 Will be mapped into the animation cycle, so it can get an arbitrary
     ///                 value. Best use with ever-increasing time stamps.
     void Evaluate(double pTime);
 
-    /// @brief  Returns the transform matrices calculated at the last Evaluate() call. 
+    /// @brief  Returns the transform matrices calculated at the last Evaluate() call.
     ///         The array matches the mChannels array of the aiAnimation.
     const std::vector<aiMatrix4x4> &GetTransformations() const { return mTransforms; }
 
diff --git a/tools/assimp_view/CMakeLists.txt b/tools/assimp_view/CMakeLists.txt
index 8ff556f05c..0199392fe0 100644
--- a/tools/assimp_view/CMakeLists.txt
+++ b/tools/assimp_view/CMakeLists.txt
@@ -1,6 +1,6 @@
 # Open Asset Import Library (assimp)
 # ----------------------------------------------------------------------
-# 
+#
 # Copyright (c) 2006-2021, assimp team
 
 
diff --git a/tools/assimp_view/Display.cpp b/tools/assimp_view/Display.cpp
index 4178ab955b..ac9aa5329f 100644
--- a/tools/assimp_view/Display.cpp
+++ b/tools/assimp_view/Display.cpp
@@ -105,7 +105,7 @@ void GetNodeCount(aiNode* pcNode, unsigned int* piCnt)
 int CDisplay::EnableAnimTools(BOOL hm) {
     EnableWindow(GetDlgItem(g_hDlg,IDC_PLAY),hm);
     EnableWindow(GetDlgItem(g_hDlg,IDC_SLIDERANIM),hm);
-    
+
     return 1;
 }
 
@@ -171,7 +171,7 @@ int CDisplay::AddNodeToDisplayList(
         {
             iIndex += iDepth  * 100;
         }
-        else 
+        else
 			iIndex += iDepth  * 10;
         ai_snprintf(chTemp, MAXLEN,"Node %u",iIndex);
     }
@@ -1053,7 +1053,7 @@ int CDisplay::OnSetupTextureView(TextureInfo* pcNew)
         case aiTextureOp_SmoothAdd:
             szOp = "addsmooth";
             break;
-        default: 
+        default:
             szOp = "mul";
             break;
         };
diff --git a/tools/assimp_view/MessageProc.cpp b/tools/assimp_view/MessageProc.cpp
index 580d35bf1a..56831eb2a9 100644
--- a/tools/assimp_view/MessageProc.cpp
+++ b/tools/assimp_view/MessageProc.cpp
@@ -2206,7 +2206,7 @@ int APIENTRY _tWinMain(HINSTANCE hInstance,
             "ASSIMP ModelViewer",MB_OK);
         return -4;
     }
-    
+
     CLogDisplay::Instance().AddEntry("[OK] Here we go!");
 
     // create the log window
diff --git a/tools/assimp_view/Shaders.cpp b/tools/assimp_view/Shaders.cpp
index a3404d5bf9..b8ee8dbf8c 100644
--- a/tools/assimp_view/Shaders.cpp
+++ b/tools/assimp_view/Shaders.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ conditions are met:
   derived from this software without specific prior
   written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
diff --git a/tools/assimp_view/assimp_view.cpp b/tools/assimp_view/assimp_view.cpp
index 5ab7c53ad0..e780e2aaf8 100644
--- a/tools/assimp_view/assimp_view.cpp
+++ b/tools/assimp_view/assimp_view.cpp
@@ -7,8 +7,8 @@ Copyright (c) 2006-2021, assimp team
 
 All rights reserved.
 
-Redistribution and use of this software in source and binary forms, 
-with or without modification, are permitted provided that the following 
+Redistribution and use of this software in source and binary forms,
+with or without modification, are permitted provided that the following
 conditions are met:
 
 * Redistributions of source code must retain the above
@@ -25,16 +25,16 @@ contributors may be used to endorse or promote products
 derived from this software without specific prior
 written permission of the assimp team.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ---------------------------------------------------------------------------
 */
diff --git a/tools/assimp_view/resource.h b/tools/assimp_view/resource.h
index 5077f6ccf9..754eb69bd6 100644
--- a/tools/assimp_view/resource.h
+++ b/tools/assimp_view/resource.h
@@ -223,7 +223,7 @@
 #define IDC_STATIC                      -1
 
 // Next default values for new objects
-// 
+//
 #ifdef APSTUDIO_INVOKED
 #ifndef APSTUDIO_READONLY_SYMBOLS
 #define _APS_NO_MFC                     1

From 4991f728c897a303b9cb0b307e164017fe8b4eca Mon Sep 17 00:00:00 2001
From: Krishty <krishty@krishty.com>
Date: Thu, 29 Jul 2021 14:23:52 +0200
Subject: [PATCH 4/7] =?UTF-8?q?style=20fix=C2=A0=E2=80=93=20initializing?=
 =?UTF-8?q?=20and=20assigning=20empty=20std::string=20properly?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

for details, see #3764
---
 code/AssetLib/STEPParser/STEPFileReader.cpp | 4 ++--
 code/AssetLib/glTF/glTFCommon.h             | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/code/AssetLib/STEPParser/STEPFileReader.cpp b/code/AssetLib/STEPParser/STEPFileReader.cpp
index ac6d836726..360277912c 100644
--- a/code/AssetLib/STEPParser/STEPFileReader.cpp
+++ b/code/AssetLib/STEPParser/STEPFileReader.cpp
@@ -58,13 +58,13 @@ using namespace Assimp;
 namespace EXPRESS = STEP::EXPRESS;
 
 // ------------------------------------------------------------------------------------------------
-std::string AddLineNumber(const std::string& s,uint64_t line /*= LINE_NOT_SPECIFIED*/, const std::string& prefix = "")
+std::string AddLineNumber(const std::string& s,uint64_t line /*= LINE_NOT_SPECIFIED*/, const std::string& prefix = std::string())
 {
     return line == STEP::SyntaxError::LINE_NOT_SPECIFIED ? prefix+s : static_cast<std::string>( (Formatter::format(),prefix,"(line ",line,") ",s) );
 }
 
 // ------------------------------------------------------------------------------------------------
-std::string AddEntityID(const std::string& s,uint64_t entity /*= ENTITY_NOT_SPECIFIED*/, const std::string& prefix = "")
+std::string AddEntityID(const std::string& s,uint64_t entity /*= ENTITY_NOT_SPECIFIED*/, const std::string& prefix = std::string())
 {
     return entity == STEP::TypeError::ENTITY_NOT_SPECIFIED ? prefix+s : static_cast<std::string>( (Formatter::format(),prefix,"(entity #",entity,") ",s));
 }
diff --git a/code/AssetLib/glTF/glTFCommon.h b/code/AssetLib/glTF/glTFCommon.h
index 0506ad056d..6f35e78818 100644
--- a/code/AssetLib/glTF/glTFCommon.h
+++ b/code/AssetLib/glTF/glTFCommon.h
@@ -196,7 +196,7 @@ inline std::string getCurrentAssetDir(const std::string &pFile) {
     std::string path = pFile;
     int pos = std::max(int(pFile.rfind('/')), int(pFile.rfind('\\')));
     if (pos == int(std::string::npos)) {
-        return "";
+        return std::string();
     }
 
     return pFile.substr(0, pos + 1);

From 42a7611f8511e5af0e357a56b658b381b14c8454 Mon Sep 17 00:00:00 2001
From: Krishty <krishty@krishty.com>
Date: Thu, 29 Jul 2021 14:39:22 +0200
Subject: [PATCH 5/7] style fix: indentation

---
 code/AssetLib/3MF/3MFXmlTags.h     | 2 +-
 code/AssetLib/MMD/MMDPmxParser.cpp | 6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/code/AssetLib/3MF/3MFXmlTags.h b/code/AssetLib/3MF/3MFXmlTags.h
index d447556d68..9fa2affd43 100644
--- a/code/AssetLib/3MF/3MFXmlTags.h
+++ b/code/AssetLib/3MF/3MFXmlTags.h
@@ -103,7 +103,7 @@ namespace XmlTag {
     const char* const PACKAGE_TEXTURE_RELATIONSHIP_TYPE = "http://schemas.microsoft.com/3dmanufacturing/2013/01/3dtexture";
     const char* const PACKAGE_CORE_PROPERTIES_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties";
     const char* const PACKAGE_THUMBNAIL_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail";
-    }
+}
 
 } // Namespace D3MF
 } // Namespace Assimp
diff --git a/code/AssetLib/MMD/MMDPmxParser.cpp b/code/AssetLib/MMD/MMDPmxParser.cpp
index d57dc169a8..ba8efa8e98 100644
--- a/code/AssetLib/MMD/MMDPmxParser.cpp
+++ b/code/AssetLib/MMD/MMDPmxParser.cpp
@@ -516,13 +516,13 @@ namespace pmx
 		stream->read((char*) magic, sizeof(char) * 4);
 		if (magic[0] != 0x50 || magic[1] != 0x4d || magic[2] != 0x58 || magic[3] != 0x20)
         {
-      throw DeadlyImportError("MMD: Invalid magic number.");
-    }
+            throw DeadlyImportError("MMD: Invalid magic number.");
+        }
 		stream->read((char*) &version, sizeof(float));
 		if (version != 2.0f && version != 2.1f)
 		{
             throw DeadlyImportError("MMD: Unsupported version (must be 2.0 or 2.1): ", ai_to_string(version));
-    }
+        }
 		this->setting.Read(stream);
 
 		this->model_name = ReadString(stream, setting.encoding);

From a1eaaaa0e398ce860c0ecfe42d61f98222f57208 Mon Sep 17 00:00:00 2001
From: Krishty <krishty@krishty.com>
Date: Thu, 29 Jul 2021 14:45:39 +0200
Subject: [PATCH 6/7] fix comments

fixes some copy-paste errors in logger comments introduced with 89584c167aaf341a6d717083bb9a52a4c1b0ace1
---
 include/assimp/Logger.hpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/include/assimp/Logger.hpp b/include/assimp/Logger.hpp
index 3ca4a6cb2b..18e9139539 100644
--- a/include/assimp/Logger.hpp
+++ b/include/assimp/Logger.hpp
@@ -99,8 +99,8 @@ class ASSIMP_API Logger
     virtual ~Logger();
 
     // ----------------------------------------------------------------------
-    /** @brief  Writes a info message
-     *  @param  message Info message*/
+    /** @brief  Writes a debug message
+     *  @param  message Debug message*/
     void debug(const char* message);
 
     template<typename... T>
@@ -109,7 +109,7 @@ class ASSIMP_API Logger
     }
 
     // ----------------------------------------------------------------------
-	/** @brief  Writes a debug message
+    /** @brief  Writes a debug message
      *   @param message Debug message*/
     void verboseDebug(const char* message);
     
@@ -140,7 +140,7 @@ class ASSIMP_API Logger
 
     // ----------------------------------------------------------------------
     /** @brief  Writes an error message
-     *  @param  message Info message*/
+     *  @param  message Error message*/
     void error(const char* message);
 
     template<typename... T>

From 538cb3125c6d83a0a4d76ec589e21a787093a2f0 Mon Sep 17 00:00:00 2001
From: Hill Ma <hillma@google.com>
Date: Mon, 2 Aug 2021 11:47:35 -0700
Subject: [PATCH 7/7] Use strlen() rather than fixed length in fast_atof.h

This avoids reading past the length of the input string.
---
 include/assimp/fast_atof.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/assimp/fast_atof.h b/include/assimp/fast_atof.h
index aea793f35d..43bbbff648 100644
--- a/include/assimp/fast_atof.h
+++ b/include/assimp/fast_atof.h
@@ -194,7 +194,7 @@ uint64_t strtoul10_64( const char* in, const char** out=0, unsigned int* max_ino
 
     if ( *in < '0' || *in > '9' ) {
         // The string is known to be bad, so don't risk printing the whole thing.
-        throw ExceptionType("The string \"", ai_str_toprintable(in, 30), "\" cannot be converted into a value." );
+        throw ExceptionType("The string \"", ai_str_toprintable(in, (int)strlen(in)), "\" cannot be converted into a value." );
     }
 
     for ( ;; ) {
@@ -294,7 +294,7 @@ const char* fast_atoreal_move(const char* c, Real& out, bool check_comma = true)
     if (!(c[0] >= '0' && c[0] <= '9') &&
             !((c[0] == '.' || (check_comma && c[0] == ',')) && c[1] >= '0' && c[1] <= '9')) {
         // The string is known to be bad, so don't risk printing the whole thing.
-        throw ExceptionType("Cannot parse string \"", ai_str_toprintable(c, 30),
+        throw ExceptionType("Cannot parse string \"", ai_str_toprintable(c, (int)strlen(c)),
                                     "\" as a real number: does not start with digit "
                                     "or decimal point followed by digit.");
     }
