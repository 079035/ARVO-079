From 2a9a4de21ea7f5d15314da8ee5f27feebf239655 Mon Sep 17 00:00:00 2001
From: Alex Tutubalin <lexa@lexa.ru>
Date: Fri, 22 Oct 2021 08:33:28 +0300
Subject: [PATCH] Snapshot 202110

---
 Changelog.txt                            |  164 +-
 Makefile.devel                           |    4 -
 Makefile.devel.nopp                      |    2 -
 Makefile.devel.noppr2i                   |    2 -
 Makefile.dist                            |    4 -
 Makefile.mingw                           |    2 -
 Makefile.msvc                            |    8 -
 README.RawSpeed.txt                      |    3 +
 README.md                                |  130 +-
 RawSpeed/rawspeed.samsung-decoder.patch  |   39 +
 doc/API-CXX.html                         |  105 +-
 doc/API-datastruct.html                  | 2584 +++++++++++-----------
 doc/Samples-LibRaw.html                  |    4 +-
 internal/libraw_cameraids.h              |   10 +
 internal/libraw_internal_funcs.h         |   14 +-
 internal/var_defines.h                   |    2 +-
 libraw/libraw.h                          |    1 +
 libraw/libraw_const.h                    |   61 +-
 libraw/libraw_internal.h                 |    2 +
 libraw/libraw_types.h                    |   61 +-
 libraw/libraw_version.h                  |    2 +-
 samples/4channels.cpp                    |    7 +-
 samples/dcraw_emu.cpp                    |    2 +-
 samples/postprocessing_benchmark.cpp     |    5 +-
 samples/raw-identify.cpp                 |   13 +-
 samples/unprocessed_raw.cpp              |    7 +-
 src/decoders/canon_600.cpp               |    7 +-
 src/decoders/decoders_dcraw.cpp          |   10 +-
 src/decoders/decoders_libraw.cpp         |  101 +-
 src/decoders/decoders_libraw_dcrdefs.cpp |   42 +
 src/decoders/dng.cpp                     |    8 +-
 src/decoders/fp_dng.cpp                  |   13 +-
 src/decoders/load_mfbacks.cpp            |  236 +-
 src/decoders/unpack.cpp                  |   10 +-
 src/decoders/unpack_thumb.cpp            |   15 +-
 src/demosaic/xtrans_demosaic.cpp         |    2 +-
 src/integration/dngsdk_glue.cpp          |    4 +
 src/metadata/canon.cpp                   |  511 +++--
 src/metadata/ciff.cpp                    |   48 +-
 src/metadata/cr3_parser.cpp              |   78 +-
 src/metadata/epson.cpp                   |    2 +-
 src/metadata/exif_gps.cpp                |   21 +-
 src/metadata/fuji.cpp                    |  168 +-
 src/metadata/hasselblad_model.cpp        |    7 +-
 src/metadata/identify.cpp                |  186 +-
 src/metadata/kodak.cpp                   |   16 +-
 src/metadata/makernotes.cpp              |   10 +-
 src/metadata/mediumformat.cpp            |   28 +-
 src/metadata/misc_parsers.cpp            |   16 +-
 src/metadata/nikon.cpp                   |  225 +-
 src/metadata/normalize_model.cpp         |   41 +-
 src/metadata/olympus.cpp                 |   55 +-
 src/metadata/pentax.cpp                  |   39 +-
 src/metadata/sony.cpp                    |  577 +++--
 src/metadata/tiff.cpp                    |  160 +-
 src/tables/cameralist.cpp                |   33 +-
 src/tables/colordata.cpp                 |   73 +-
 src/tables/wblists.cpp                   |    2 +-
 src/utils/decoder_info.cpp               |    4 +
 src/utils/init_close_utils.cpp           |   16 +-
 src/utils/open.cpp                       |  254 ++-
 src/utils/thumb_utils.cpp                |    9 +-
 src/utils/utils_libraw.cpp               |   31 +
 src/x3f/x3f_parse_process.cpp            |   24 +-
 src/x3f/x3f_utils_patched.cpp            |   60 +-
 65 files changed, 3944 insertions(+), 2436 deletions(-)
 create mode 100644 RawSpeed/rawspeed.samsung-decoder.patch

diff --git a/Changelog.txt b/Changelog.txt
index 721ed030..ab247dea 100644
--- a/Changelog.txt
+++ b/Changelog.txt
@@ -1,3 +1,159 @@
+2021-10-22  Alex Tutubalin <lexa@lexa.ru>
+  
+   == LibRaw snapshot 202110 ==
+   * Camera Format support:
+    - Sony Lossless compressed support
+    - Panasonic v6/12 bit
+ 
+   * Camera support:
+    DJI Mavic Air 2S
+    Fujifilm GFX 50S II;  GFX 100S, X-E4
+    GoPro HERO9, HERO10 (if compiled w/ USE_GPR_SDK)
+    Nikon Z fc
+    Panasonic GH5 Mark II
+    Pentax K3 Mark III
+    Olympus E-P7
+    Ricoh GR IIIx
+    Sony A1, A7R-IIIA (ILCE-7RM3A), A7R-IVA (ILCE-7RM4A), ZV-E10
+    Canon EOS M50 Mark II was supported but not listed in camera list
+
+    Multiple phones tested and added to cameralist.cpp
+
+   * Support for RaspberryPi HQ camera (if compiled w/  USE_6BY9RPI)
+
+   * Improved support for RPi V1/V2 cameras:
+     - white balance data extraction
+     - color matrix extracted to imgdata.color.cmatrix to use with
+       use_camera_matrix.
+     - full-size thumbnail/preview support for JPEG+RAW files (raspistill -r)
+
+  == API-ABI changes ==
+
+  * (INCOMPATIBILITY WITH OLDER VERSIONS!!!) 
+    imgdata.params.shot_select moved to imgdata.rawparams.shot_select
+     (because this is decode-time option, not postprocessing option)
+
+  * libraw_open_bayer(...) added to C-API
+
+  * imgdata.makernotes.canon: separate SensorLeftBorder,SensorTopBorder....
+    (and many other datafields) are united in libraw_area_t (rectangle)
+    groups for crop areas and optical black areas.
+
+  * Additional fields in libraw_internal_data.unpacker_data:
+    - INT64: exif_offset: base offset of 1st EXIF IFD in file
+    - INT64: ifd0_offset: base offset of 1st TIFF IFD (IFD0) in file
+    - unsigned cr3_exif_length, cr3_ifd0_lenght : CR3-specific length of
+     exif and ifd0 sections.
+
+  *  imgdata.sizes.raw_inset_crop rearranged:
+     now it is imgdata.sizes.raw_inset_crops[2]:
+     - item at [0] is the same as imgdatra.sizes.raw_inset_crop in previous 
+      versions
+     - item at [1] is 'user crop', in particular:
+       -- set by DNG  DefaultUserCrop tag
+       -- or set via raw aspect ratio tags (e.g. 16:9 aspect on Fujifilm cameras)
+          raw_inset_crops[1] is filled only if aspect ratio tags provides different
+          aspect ratio compared to raw_inset_crops[0].
+
+   There are no flags to check if raw_inset_crops[Nth] is filled; to see if it is filled check 
+   the values of:
+     ctop/cleft < 0xffff (0xffff => standard values if not initialized)
+     ctop+cheight <= sizes.raw_height
+     cleft+cwidth <= sizes.raw_width
+
+   Note: raw_inset_crops may be fooled by metadata (makernotes), use some correctness check before use.
+
+  * LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP processing flag removed,
+    DNG DefaultCrop* tags are parsed into raw_inset_crops[0]
+
+  * new LibRaw call LibRaw::adjust_to_raw_inset_crop(unsigned mask, float maxcrop = 0.55f)
+    Promotes imgdata.sizes.raw_inset_crops[] values to
+    imgdata.sizes.*margin and imgdata.sizes.width/height fields
+
+   mask: if bit 1 is set: prefer raw_inset_crops[1] 
+         if bit 0 is set: prefer raw_inset_crops[0] 
+
+   maxcrop: limits crop to not less than (original width/height)*maxcrop; if raw_inset_crops[i]
+   data results in tighter crop, than this item is ignored.
+
+   return value: index in raw_inset_crops[] used increased by one, so
+    0: no changes made
+    1: [0]th data used
+    2: [1]th data used
+   
+  Note: this call SHOULD be used after LibRaw::unpack(), otherwise black level
+  calculation from masked area may be fooled resulting in wrong black levels.
+
+ * Shared library version incremented to disallow automated upgrades (will not work because of ABI change)
+
+== Metadata parsing improvements ==
+
+  * Olympus makernotes parsing: LiveND mode, Panorama mode tags.
+
+  * Fuji GFX100/GFX100S: PixelShift metadata extraction.
+
+  * Fuji RAF files: XMP block extraction
+
+== Misc improvements, limits implemented, etc ==
+
+  * Canon/12-bit files: adjust color.linear_max and makernotes.canon values
+    to match data range.
+
+  * DNG/Floating point: additional metadata check to refuse ambiguous/corrupted files.
+
+  * DNG/Floating point: correct handling of striped files (never seen in wild)
+
+  * Rawspeed support: disallow Nikon D6/Compressed processing
+ 
+  * Compile-time raw size limits implemented:
+     LIBRAW_MAX_NONDNG_RAW_FILE_SIZE - max file size for non-DNG files (default: 2GB - 1 byte)
+     LIBRAW_MAX_DNG_RAW_FILE_SIZE - max DNG file size limit (4GB-1 if compiled w/ DNG SDK, 2GB-1 overwise)
+
+  * samples/raw-identify.cpp:  -v flag documented in usage print.
+
+  * src/libraw_cxx.cpp completely removed from source tree to not confuse users.
+    (also all mentions are removed from Makefiles)
+
+  * clang-cl compatibility:
+    - defines _MSC_VER, but _forceinline is not supported
+    - warnings eliminated in Windows buffered datastream
+
+  * XMP block size in CR3 files limited to 1MB
+  
+  * Preview block size in CR3 files limited to 100MB
+
+  * Improved Phase One Compressed defects masking, thanks to Alexey Danilchenko
+
+  * CRX (CR3) decoder: fixed typo in constant; this does not affect any
+    known still photo (CR3) sample(s), but allows to use the decoder with 
+    some video (CRM) files.
+
+  * Imported user-contributed improvements to OpenMP postprocessing
+    (AHD and X-Trans demosaic)
+
+  * Bugfix: overwrite (wrong) TIFF/Orientation tag value with Metadata/Camera Orientation
+    value for EOS 40D only.
+
+  * ACES output: color conversion changed to provide D65 white point
+
+  * Fix for Canon 5D Mark II/sRAW1 incorrect camera provided crop   
+
+  * RawSpeed (master): fixed bug in old Samsung/compressed decoder,
+    apply this patch to RawSpeed: RawSpeed/rawspeed.samsung-decoder.patch
+  
+  * DCI-P3 and Rec 2020 output colorspaces
+  
+  * Eliminated multiple signed/unsigned mismatch warnings (reported by gcc11)
+
+  * Fixed a typo in LIBRAW_OPTIONS_* flag names
+    (was LIBRAW_OPIONS, old flags names not removed due to compatibility)
+
+== Bugfixes ==
+  * fixed possible 1-byte stack underrun while handling text tags with zero lengh
+
+  * Fixed wrong handling of linear DNG files created from Pentax out-of-camera DNGs
+ 
+
 2021-01-21  Alex Tutubalin <lexa@lexa.ru>
 
  == LibRaw snapshot 202101 ==
@@ -37,12 +193,6 @@
    under Windows).
    Cinema DNG files are not affected by this.
 
- = Compile/build changes =
- * Old (0.19-compatibility) files (internal/dcraw_*.cpp  
-   internal/demosaic_packs.cpp src/libraw_cxx.cpp) are removed from LibRaw 
-   repository.
-   Please switch to 'modern' multiple source files build.
-
  = API/ABI changes =
 
   * Decoding parameters
@@ -120,8 +270,6 @@
       LIBRAW_CAPS_ZLIB if compiled with USE_ZLIB
       LIBRAW_CAPS_JPEG if compiled with USE_JPEG
 
- * samples/raw-identify.cpp sample: removed lot of extra output
-   used only by development team
 
  * Windows datastreams: CreateFile2 is used if compiled for UWP.
 
diff --git a/Makefile.devel b/Makefile.devel
index 0458d2b9..ec5800a5 100644
--- a/Makefile.devel
+++ b/Makefile.devel
@@ -192,10 +192,6 @@ object/libraw_c_api.o: src/libraw_c_api.cpp $(HEADERS)
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
 object/libraw_c_api.mt.o: src/libraw_c_api.cpp $(HEADERS)
 	${CXX} -c ${CFLAGS} -o object/libraw_c_api.mt.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
-object/libraw_cxx.mt.o: src/libraw_cxx.cpp $(HEADERS)
-	${CXX} -c ${CFLAGS} -o object/libraw_cxx.mt.o src/libraw_cxx.cpp
 
 object/libraw_datastream.o: src/libraw_datastream.cpp $(HEADERS)
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
diff --git a/Makefile.devel.nopp b/Makefile.devel.nopp
index 5364e77a..6ece7e9e 100644
--- a/Makefile.devel.nopp
+++ b/Makefile.devel.nopp
@@ -102,8 +102,6 @@ clean:
 ## script-created rules
 object/libraw_c_api.o: src/libraw_c_api.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
 object/libraw_datastream.o: src/libraw_datastream.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
 object/canon_600.o: src/decoders/canon_600.cpp
diff --git a/Makefile.devel.noppr2i b/Makefile.devel.noppr2i
index aa35b5c3..69372877 100644
--- a/Makefile.devel.noppr2i
+++ b/Makefile.devel.noppr2i
@@ -94,8 +94,6 @@ clean:
 ## script-created rules
 object/libraw_c_api.o: src/libraw_c_api.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
 object/libraw_datastream.o: src/libraw_datastream.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
 object/canon_600.o: src/decoders/canon_600.cpp
diff --git a/Makefile.dist b/Makefile.dist
index 001b745a..61194a07 100644
--- a/Makefile.dist
+++ b/Makefile.dist
@@ -199,10 +199,6 @@ object/libraw_c_api.o: src/libraw_c_api.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
 object/libraw_c_api.mt.o: src/libraw_c_api.cpp
 	${CXX} -c ${CFLAGS} -o object/libraw_c_api.mt.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
-object/libraw_cxx.mt.o: src/libraw_cxx.cpp
-	${CXX} -c ${CFLAGS} -o object/libraw_cxx.mt.o src/libraw_cxx.cpp
 object/libraw_datastream.o: src/libraw_datastream.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
 object/libraw_datastream.mt.o: src/libraw_datastream.cpp
diff --git a/Makefile.mingw b/Makefile.mingw
index 434d6470..f2c291e2 100644
--- a/Makefile.mingw
+++ b/Makefile.mingw
@@ -147,8 +147,6 @@ clean:
 ### generated
 object/libraw_c_api.o: src/libraw_c_api.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_c_api.o src/libraw_c_api.cpp
-object/libraw_cxx.o: src/libraw_cxx.cpp
-	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_cxx.o src/libraw_cxx.cpp
 object/libraw_datastream.o: src/libraw_datastream.cpp
 	${CXX} -c -DLIBRAW_NOTHREADS  ${CFLAGS} -o object/libraw_datastream.o src/libraw_datastream.cpp
 object/canon_600.o: src/decoders/canon_600.cpp
diff --git a/Makefile.msvc b/Makefile.msvc
index 5594ca05..c06b35f0 100644
--- a/Makefile.msvc
+++ b/Makefile.msvc
@@ -71,8 +71,6 @@ LIB_OBJECTS= object\libraw_datastream_st.obj object\libraw_c_api_st.obj \
   object\file_write_st.obj \
   object\ext_preprocess_st.obj   object\apply_profile_st.obj
 
-#LIB_OBJECTS=object\dcraw_common_st.obj object\dcraw_fileio_st.obj  object\libraw_cxx_st.obj object\libraw_datastream_st.obj object\libraw_c_api_st.obj object\demosaic_packs_st.obj
-#DLL_OBJECTS=object\dcraw_common.obj object\dcraw_fileio.obj  object\libraw_cxx.obj object\libraw_datastream.obj object\libraw_c_api.obj  object\demosaic_packs.obj
 
 DLL_OBJECTS= object\libraw_datastream.obj object\libraw_c_api.obj \
   object\cameralist.obj object\fuji_compressed.obj \
@@ -622,12 +620,6 @@ object\libraw_c_api_st.obj: src\libraw_c_api.cpp
 object\libraw_c_api.obj: src\libraw_c_api.cpp
 	$(CC) $(COPT) /DLIBRAW_BUILDLIB /Fo"object\\libraw_c_api.obj" /c src\libraw_c_api.cpp
 
-object\libraw_cxx_st.obj: src\libraw_cxx.cpp
-	$(CC) $(COPT) /DLIBRAW_NODLL /DLIBRAW_BUILDLIB /Fo"object\\libraw_cxx_st.obj" /c src\libraw_cxx.cpp
-
-object\libraw_cxx.obj: src\libraw_cxx.cpp
-	$(CC) $(COPT) /DLIBRAW_BUILDLIB /Fo"object\\libraw_cxx.obj" /c src\libraw_cxx.cpp
-
 object\libraw_datastream_st.obj: src\libraw_datastream.cpp
 	$(CC) $(COPT) /DLIBRAW_NODLL /DLIBRAW_BUILDLIB /Fo"object\\libraw_datastream_st.obj" /c src\libraw_datastream.cpp
 
diff --git a/README.RawSpeed.txt b/README.RawSpeed.txt
index 336d04a2..fb4b94c9 100644
--- a/README.RawSpeed.txt
+++ b/README.RawSpeed.txt
@@ -18,6 +18,9 @@ system.
   -- Win32: you need POSIX Threads for Win32 installed on your system
      (http://sources.redhat.com/pthreads-win32/)
 
+  -- use provided RawSpeed/rawspeed.samsung-decoder.patch  to fix
+     old Samsung decoder bug
+
   -- you may use qmake .pro files supplied in LibRaw distribution
      (RawSpeed/rawspeed.qmake-pro-files.patch)
      Adjust path to libraries/includes according to your setup.
diff --git a/README.md b/README.md
index b6157292..d7cedbe5 100644
--- a/README.md
+++ b/README.md
@@ -1,28 +1,106 @@
 # LibRaw
-### Library for reading and processing of RAW digicam images
-
-LibRaw is a library for reading RAW files from digital photo cameras 
-(CRW/CR2, NEF, RAF, DNG, MOS, KDC, DCR, etc, virtually all RAW formats are 
-supported). 
-
-It pays special attention to correct retrieval of data required for subsequent 
-RAW conversion.
-    
-The library is intended for embedding in RAW converters, data analyzers, and 
-other programs using RAW files as the initial data.
-
-LibRaw library, Copyright &copy; 2008-2021 LibRaw LLC (info@libraw.org)
-The library includes source code from
-      
-     dcraw.c, Dave Coffin's raw photo decoder
-     Copyright 1997-2018 by Dave Coffin, dcoffin a cybercom o net
-      
-LibRaw is distributed for free under two different licenses:
- *  GNU Lesser General Public License, version 2.1
- *  COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
-    
-You may use one of these licensing modes and switch between them.
-
-If you modify LibRaw source and made your changes public, you should accept
-both two licensing modes for your changes/additions.
+## Library for reading and processing of RAW digicam images
 
+ The LibRaw library provides a simple and unified interface for extracting out of RAW files generated by digital photo cameras the following:
+
+* RAW data (_pixel values)_
+* Metadata necessary for processing RAW (_geometry, CFA / Bayer pattern, black level, white balance, etc.)_
+* Embedded preview / thumbnail.
+
+The library is intended for use with programs that work with RAW files, such as:
+
+* RAW viewers
+* RAW converters
+* RAW data analyzers
+* Software for stitching and compositing multi-frame aggregates like panoramas and image stacks.
+
+Using the LibRaw library allows one to focus on the substantive part of processing the data contained in RAW files, without getting distracted by the wide variety of RAW file and metadata formats, compression algorithms, etc.
+
+The library’s development is focused on:
+
+* Support for new cameras and formats
+* Improving extraction of metadata necessary for RAW processing
+* Providing an interface for reading other types of metadata.
+
+Additionally, the LibRaw library offers some basic RAW conversion, intended for cases when such conversion is not the main function of the LibRaw-using application _(for example: a viewer for 500+ graphic file formats, including RAW)._ These methods are inherited from the Dave Coffin’s dcraw.c utility _(see below the “Project history” section);_ their further development is not currently planned, because we do not consider production-quality rendering to be in the scope of LibRaw’s functionality _(the methods are retained for compatibility with prior versions and for rapid-fire testing of RAW support and other aspects)._
+
+## Licensing
+
+
+The LibRaw library is distributed free of charge and with open-source code subject to two licenses:
+
+1\. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+
+2\. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+
+To use the LibRaw library in an application, you can choose the license that better suits your needs.
+
+If you modify/add/improve the LibRaw source code, then your patches can only be included into the library’s official source code if you agree to it being distributed under both of the above licenses.
+
+We do not guarantee that the licensing will not change in future versions of LibRaw.
+
+## Update policy
+
+
+### Major/minor releases
+
+* Major releases _(for example, 0.20)_ are published once every year and a half to two years.
+* When the first public beta version of a major release is published, the list of supported cameras and formats is frozen; we try (but do not guarantee) to freeze the API/ABI as well.
+* The public major release contains only that code which has been sufficiently tested on a wide user base (including in our commercial products). Something very new may not be included in it (but it will probably be included in a public snapshot, see below).
+* Minor updates _(0.20.1, 0.20.2…)_ do not change the API/ABI and new cameras are not added; generally they are just bugfixes.
+* Bugfixes are published as soon as possible in the [public GitHub repository](https://github.com/LibRaw/LibRaw).
+* Minor version increments: these are generally published if a serious error has been fixed, one that potentially affects many library users (for example, a possible stack overflow).
+
+### Public snapshots
+
+* Public snapshots are published every 7-9 months in the [public GitHub repository](https://github.com/LibRaw/LibRaw).
+* These versions contain support for new cameras that was added after the previous major release. The API/ABI of public snapshots is not frozen, and may change.
+* Public snapshots are always tested on a fairly large user base, and may be considered suitable for use in programs that work with files with known origins (that is, recorded directly by users’ digital cameras). However, public snapshots should not be considered sufficiently reliable for processing files that are specially constructed for vulnerability testing; that is, they should not be used in public services that allow for anonymous processing of files of unknown provenance
+
+## Support and feedback
+
+* You can submit a bug report in one of the following ways:
+    * [Issues](https://github.com/LibRaw/LibRaw/issues) on GitHub
+    * The libraw.org [forum](https://www.libraw.org/forum)
+    * [Feedback form](https://www.libraw.org/contact) on libraw.org
+    * E-mail us at [info@libraw.org](mailto:info@libraw.org)
+* Questions can be asked on the forum, through the feedback form, and via the email indicated above.  
+    Please do not use Issues on GitHub for questions; it is intended specifically for problem reports.
+* We prefer to process additions to the source code via the [Pull Requests](https://github.com/LibRaw/LibRaw/pulls) on GitHub.
+
+We cannot guarantee any response to requests submitted via the above methods. If you need a guaranteed response for a bug report and/or for extending technical support, please use the Extended Support option.
+
+## Project history
+
+
+The LibRaw project was launched in 2008, based on the [dcraw.c](https://www.dechifro.org/dcraw/) (Dave Coffin) utility, with its goals being to:
+
+* Convert dcraw.c into a library that could be used by other programs, while also somewhat improving the structure of dcraw.c (removing global variables, making it thread-safe, etc.)
+* Import changes made to dcraw.c
+* Improve/expand the extraction of metadata.
+
+Unfortunately, support for dcraw.c was reduced to a minimum in 2015, and completely ceased in 2018. Since then, support for new cameras (including support for new formats) has been done entirely by the LibRaw team.
+
+The code that implements rendering of RAW to RGB is inherited from dcraw.c, without major changes (though a set of changes was implemented to speed up and parallelize this code).
+
+In the early-to-mid 2010s, we gladly expanded post-processing implemented in LibRaw, and readily accepted the input of outside developers (new/improved methods for debayerization/demosaicing, systematic noise reduction etc.).
+
+Experience has shown that the LibRaw team cannot support this added code on their own, while contributors do not provide support and development of the code they suggest and it ends up abandoned. As such, the majority of the modifications that are implemented by people outside the LibRaw team was moved to the [LibRaw-demosaic-pack-….](https://github.com/LibRaw?tab=repositories), where they remain in their original form (but these projects are still present in our GitHub).
+
+Thus, we arrive at our current status, described in the first part of this text.
+
+## Copyrights and Acknowledgements
+
+Copyright (C) 2008-2021 LibRaw LLC
+
+LibRaw uses code from Dave Coffin’s dcraw.c utility (without RESTRICTED/GPL2 code):
+
+Copyright 1997-2018 by Dave Coffin, dcoffin a cybercom o net
+
+LibRaw uses DCB demosaic code by Jaceck Gozdz distributed under BSD license:
+
+Copyright (C) 2010, Jacek Gozdz (mailto:cuniek@kft.umcs.lublin.pl)
+
+LibRaw uses Roland Karlsson’s X3F tools source code, licensed under BSD license:
+
+Copyright (c) 2010, Roland Karlsson (roland@proxel.se)
\ No newline at end of file
diff --git a/RawSpeed/rawspeed.samsung-decoder.patch b/RawSpeed/rawspeed.samsung-decoder.patch
new file mode 100644
index 00000000..f62754a8
--- /dev/null
+++ b/RawSpeed/rawspeed.samsung-decoder.patch
@@ -0,0 +1,39 @@
+diff --git a/RawSpeed/SrwDecoder.cpp b/RawSpeed/SrwDecoder.cpp
+index fa46499..1aff689 100644
+--- a/RawSpeed/SrwDecoder.cpp
++++ b/RawSpeed/SrwDecoder.cpp
+@@ -141,7 +141,7 @@ void SrwDecoder::decodeCompressed( TiffIFD* raw )
+         // First we decode even pixels
+         for (int c = 0; c < 16; c += 2) {
+           int b = len[(c >> 3)];
+-          int32 adj = ((int32) bits.getBits(b) << (32-b) >> (32-b));
++          int32 adj = b > 0 ? ((int32) bits.getBits(b) << (32-b) >> (32-b)) :0;
+           img[c] = adj + img_up[c];
+         }
+         // Now we decode odd pixels
+@@ -149,7 +149,7 @@ void SrwDecoder::decodeCompressed( TiffIFD* raw )
+         // is beyond me, it will hurt compression a deal.
+         for (int c = 1; c < 16; c += 2) {
+           int b = len[2 | (c >> 3)];
+-          int32 adj = ((int32) bits.getBits(b) << (32-b) >> (32-b));
++          int32 adj = b > 0 ? ((int32) bits.getBits(b) << (32-b) >> (32-b)) :0;
+           img[c] = adj + img_up2[c];
+         }
+       } else {
+@@ -158,14 +158,14 @@ void SrwDecoder::decodeCompressed( TiffIFD* raw )
+         int pred_left = x ? img[-2] : 128;
+         for (int c = 0; c < 16; c += 2) {
+           int b = len[(c >> 3)];
+-          int32 adj = ((int32) bits.getBits(b) << (32-b) >> (32-b));
++          int32 adj = b > 0 ? ((int32) bits.getBits(b) << (32-b) >> (32-b)) :0;
+           img[c] = adj + pred_left;
+         }
+         // Now we decode odd pixels
+         pred_left = x ? img[-1] : 128;
+         for (int c = 1; c < 16; c += 2) {
+           int b = len[2 | (c >> 3)];
+-          int32 adj = ((int32) bits.getBits(b) << (32-b) >> (32-b));
++          int32 adj = b > 0 ? ((int32) bits.getBits(b) << (32-b) >> (32-b)) :0;
+           img[c] = adj + pred_left;
+         }
+       }
diff --git a/doc/API-CXX.html b/doc/API-CXX.html
index b32c614f..4dc73bd1 100644
--- a/doc/API-CXX.html
+++ b/doc/API-CXX.html
@@ -17,8 +17,7 @@ <h1>LibRaw C++ API</h1>
               *rawfile[,INT64 bigfile_size])</a></li>
           <li><a href="#open_buffer">int LibRaw::open_buffer(void *buffer,
               size_t bufsize)</a></li>
-          <li><a href="#open_bayer">int
-              LibRaw::open_bayer(...)</a></li>
+          <li><a href="#open_bayer">int LibRaw::open_bayer(...)</a></li>
           <li><a href="#unpack">int LibRaw::unpack(void)</a></li>
           <li><a href="#unpack_thumb">int LibRaw::unpack_thumb(void)</a></li>
         </ul>
@@ -50,6 +49,8 @@ <h1>LibRaw C++ API</h1>
           <li><a href="#setCancelFlag">void LibRaw::setCancelFlag()</a></li>
           <li><a href="#clearCancelFlag">void LibRaw::clearCancelFlag()</a></li>
           <li><a href="#subtract_black">int LibRaw::subtract_black()</a></li>
+          <li><a href="#adjust_to_raw_inset_crop">int
+              LibRaw::adjust_to_raw_inset_crop()</a></li>
           <li><a href="#floatingpoint">Support for Floating Point data</a></li>
           <li><a href="#ycc">Support for YCC formats</a></li>
           <li><a href="#recycle">void LibRaw::recycle_datastream(void)</a></li>
@@ -218,41 +219,47 @@ <h3>int LibRaw::open_buffer(void *buffer, size_t bufsize)</h3>
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
     <p><a name="open_bayer"></a></p>
-
-    <h3>int LibRaw::open_bayer(unsigned char *data, unsigned datalen,
-	  ushort _raw_width, ushort _raw_height, ushort _left_margin, ushort _top_margin,
-	  ushort _right_margin, ushort _bottom_margin,
-	  unsigned char procflags, unsigned char bayer_pattern, unsigned unused_bits, unsigned otherflags,
-	  unsigned black_level)</h3>
-    <p>Parameters:
-<ul>
-<li>data, datalen - buffer passed
-<li>_raw_width/_raw_height/*margin - image size and margins
-<li> procflags:
- <ul>
- <li>for 10-bit format:
-  <ul>
-   <li>1: "4 pixels in 5 bytes" packing is used
-   <li>0: "6 pixels in 8 bytes" packing is used
-  </ul>
- <li>for 16-bit format:
-  <ul>
-   <li>1: Big-endian data
-  </ul>
- </ul>
- <li>bayer_pattern: one of LIBRAW_OPENBAYER_RGGB,LIBRAW_OPENBAYER_BGGR,
-                          LIBRAW_OPENBAYER_GRBG,LIBRAW_OPENBAYER_GBRG
- <li>unused_bits: count of upper zero bits
- <li>otherflags:
-  <ul>
-      <li>Bit 1 - filter (average neighbors) for pixels with values of zero
-      <li>Bits 2-4 - the orientation of the image (0=do not rotate, 3=180, 5=90CCW, 6=90CW)
-  </ul>
- <li>black_level: file black level (it also may be specified via imgdata.params)
-</ul>
-    See samples/openbayer_sample.cpp for usage sample (note, this sample is 'sample only', suited for
-    Kodak KAI-0340 sensor, you'll need change open_bayer() params for your data).
-
+    <h3>int LibRaw::open_bayer(unsigned char *data, unsigned datalen, ushort
+      _raw_width, ushort _raw_height, ushort _left_margin, ushort _top_margin,
+      ushort _right_margin, ushort _bottom_margin, unsigned char procflags,
+      unsigned char bayer_pattern, unsigned unused_bits, unsigned otherflags,
+      unsigned black_level)</h3>
+    <p>Parameters: </p>
+    <ul>
+      <li>data, datalen - buffer passed </li>
+      <li>_raw_width/_raw_height/*margin - image size and margins </li>
+      <li> procflags:
+        <ul>
+          <li>for 10-bit format:
+            <ul>
+              <li>1: "4 pixels in 5 bytes" packing is used </li>
+              <li>0: "6 pixels in 8 bytes" packing is used </li>
+            </ul>
+          </li>
+          <li>for 16-bit format:
+            <ul>
+              <li>1: Big-endian data </li>
+            </ul>
+          </li>
+        </ul>
+      </li>
+      <li>bayer_pattern: one of LIBRAW_OPENBAYER_RGGB,LIBRAW_OPENBAYER_BGGR,
+        LIBRAW_OPENBAYER_GRBG,LIBRAW_OPENBAYER_GBRG </li>
+      <li>unused_bits: count of upper zero bits </li>
+      <li>otherflags:
+        <ul>
+          <li>Bit 1 - filter (average neighbors) for pixels with values of zero
+          </li>
+          <li>Bits 2-4 - the orientation of the image (0=do not rotate, 3=180,
+            5=90CCW, 6=90CW) </li>
+        </ul>
+      </li>
+      <li>black_level: file black level (it also may be specified via
+        imgdata.params) </li>
+    </ul>
+    See samples/openbayer_sample.cpp for usage sample (note, this sample is
+    'sample only', suited for Kodak KAI-0340 sensor, you'll need change
+    open_bayer() params for your data).
     <p><a name="unpack"></a></p>
     <h3>int LibRaw::unpack(void)</h3>
     <p>Unpacks the RAW files of the image, calculates the black level (not for
@@ -354,6 +361,29 @@ <h4>int LibRaw::subtract_black()</h4>
         code convention</a>: positive if any system call has returned an error,
       negative (from the <a href="API-datastruct.html#LibRaw_errors">LibRaw
         error list</a>) if there has been an error situation within LibRaw.</p>
+    <a name="adjust_to_raw_inset_crop"></a>
+    <h4>int LibRaw::adjust_to_raw_inset_crop(unsigned mask, float maxcrop =
+      0.55f)</h4>
+    <p> Promotes imgdata.sizes.raw_inset_crops[] values to imgdata.sizes.*margin
+      and imgdata.sizes.width/height fields</p>
+    <p> Parameters<br>
+      mask: </p>
+    <ul>
+      <li>if bit 1 is set: prefer raw_inset_crops[1] </li>
+      <li>if bit 0 is set: prefer raw_inset_crops[0] </li>
+    </ul>
+    <p>maxcrop: limits crop to not less than (original width/height)*maxcrop; if
+      raw_inset_crops[i] data results in tighter crop, than this item is
+      ignored. </p>
+    <p>return value: index in raw_inset_crops[] used increased by one, so </p>
+    <ul>
+      <li>0: no changes made </li>
+      <li>1: [0]th data used </li>
+      <li>2: [1]th data used </li>
+    </ul>
+    <p>Note: this call SHOULD be used after LibRaw::unpack(), otherwise black
+      level calculation from masked area may be fooled resulting in wrong black
+      levels. </p>
     <p><a name="floatingpoint"></a></p>
     <h4>Support for floating point data</h4>
     <p>Libraw can read floating point DNG files (no other RAW formats may use
@@ -475,7 +505,6 @@ <h4>User-specified exif tag parser callback</h4>
       <li>void *ifp - pointer to LibRaw_abstract_datastream, positioned to tag
         data</li>
     </ul>
-    <p>&nbsp;</p>
     <p><a name="memerror"></a></p>
     <h4>Out-of-Memory Notifier</h4>
     <pre>        typedef void (* memory_callback)(void *callback_data,const char *file, const char *where);<br>        void LibRaw::set_memerror_handler(memory_callback func,void *callback_data);<br>    </pre>
diff --git a/doc/API-datastruct.html b/doc/API-datastruct.html
index ed578710..c5389713 100644
--- a/doc/API-datastruct.html
+++ b/doc/API-datastruct.html
@@ -1,1285 +1,1303 @@
-<html>
-  <head>
-    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
-    <title>LibRaw: Data Structures and Constants</title>
-  </head>
-  <body>
-    <p>LibRaw: Data Structures and Constants <a href="index.html"> [back to
-        Index] </a></p>
-    <h1>LibRaw: Data Structures and Constants</h1>
-    <p>LibRaw data structures are defined in header file libraw/libraw_types.h <br>
-      Constants used in its work are defined in file libraw/libraw_const.h</p>
-    <h2>Contents:</h2>
-    <ol>
-      <li><a href="#datastruct"> Data structures </a>
-        <ol>
-          <li><a href="#libraw_data_t"> libraw_data_t: Main Data Structure in
-              LibRaw </a></li>
-          <li><a href="#libraw_iparams_t"> Structure libraw_iparams_t: Main
-              Parameters of the Image </a></li>
-          <li><a href="#libraw_image_sizes_t"> Structure libraw_image_sizes_t:
-              Image Dimensions </a></li>
-          <li><a href="#libraw_colordata_t"> Structure libraw_colordata_t: Color
-              Information </a></li>
-          <li><a href="#libraw_imgother_t"> Structure libraw_imgother_t: Other
-              Parameters of the Image </a></li>
-          <li><a href="#libraw_rawdata_t"> Structure libraw_rawdata_t: holds
-              unpacked RAW data </a></li>
-          <li><a href="#libraw_thumbnail_t"> Structure libraw_thumbnail_t:
-              Description of Thumbnail </a></li>
-          <li><a href="#libraw_lensinfo_t"> Structure libraw_lensinfo_t - lens
-              data, extracted from EXIF/Makernotes </a></li>
-          <li><a href="#libraw_raw_unpack_params_t"> Structure
-              libraw_raw_unpack_params_t: metadata and raw decoding options and
-              flags</a></li>
-          <li><a href="#libraw_output_params_t"> Structure
-              libraw_output_params_t: Management of dcraw-style postprocessing </a></li>
-          <li><a href="#libraw_callbacks_t">Structure libraw_callbacks_t:
-              user-settable callbacks</a> </li>
-          <li><a href="#libraw_processed_image_t"> Structure
-              libraw_processed_image_t - result set for
-              dcraw_make_mem_image()/dcraw_make_mem_thumb() functions </a></li>
-        </ol>
-      </li>
-      <li><a href="#datastream"> Input abstraction layer </a>
-        <ul>
-          <li><a href="#datastream_data"> Data fields </a></li>
-        </ul>
-      </li>
-      <li><a href="#const"> Constants </a>
-        <ol>
-          <li><a href="#LibRaw_errors"> enum LibRaw_errors: Error Codes </a></li>
-          <li><a href="#decoder_flags"> enum LibRaw_decoder_flags - RAW data
-              format description </a></li>
-          <li><a href="#progress"> enum LibRaw_progress: Current State of LibRaw
-              Object </a></li>
-          <li><a href="#LibRaw_thumbnail_formats"> enum
-              LibRaw_thumbnail_formats: Thumbnail Data Formats </a></li>
-          <li><a href="#warnings"> Nonstandard Situations (Warnings) during RAW
-              Data Processing </a></li>
-          <li><a href="#LibRaw_image_formats"> enum LibRaw_image_formats -
-              possible types of data, contains in libraw_processed_image_t
-              structure</a></li>
-          <li><a href="#LibRaw_processing_options">enum
-              LibRaw_processing_options - flags that affects extracted RAW data</a></li>
-          <li><a href="#LibRaw_rawspecial_t">enum LibRaw_rawspecial_t - special
-              raw extraction modes</a></li>
-        </ol>
-      </li>
-    </ol>
-    <p><a name="datastruct"></a></p>
-    <h2>Data Structures</h2>
-    <p><a name="libraw_data_t"></a></p>
-    <h3>libraw_data_t: Main Data Structure of LibRaw</h3>
-    <p>Structure libraw_data_t is a "wrapping" for data structures accessible to
-      the user of the library. <br>
-      When one uses C++ API, it is accessible as LibRaw::imgdata
-      (class_instance.imgdata). The data in this structure appear after a file
-      is opened through open_file (and other open_ calls), except for the image
-      itself (filled by unpack()) and data containing the preview information
-      (filled by calling unpack_thumb()). </p>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> unsigned int progress_flags; </strong></dt>
-      <dd>This field records the past <a href="#progress"> phases of image
-          processing </a> .</dd>
-      <dt><strong> unsigned int process_warnings; </strong></dt>
-      <dd>This field records <a href="#warnings"> suspicious situations
-          (warnings) </a> that have emerged during image processing.</dd>
-      <dt><strong> libraw_iparams_t idata; </strong></dt>
-      <dd>The structure describes the main image parameters retrieved from the
-        RAW file. Fields of this structure are described in detail <a href="#libraw_iparams_t">
-          below </a> .</dd>
-      <dt><strong> libraw_image_sizes_t sizes; </strong></dt>
-      <dd>The structure describes the geometrical parameters of the image.
-        Fields of this structure are described in detail <a href="#libraw_image_sizes_t">
-          below </a> .</dd>
-      <dt><strong> libraw_lensinfo_t lens; </strong></dt>
-      <dd>The structure describes lens used for the shot. Fields of this
-        structure are described in detail <a href="#libraw_lensinfo_t"> below </a>
-        .</dd>
-      <dt><strong> libraw_makernotes_t makernotes; </strong></dt>
-      <dd>The structure contains camera/vendor specific metadata extracted from
-        file. No description provided, sorry, if you're interested in particular
-        tag/camera/vendor - use Exiftool documentation as a reference</dd>
-      <dt><strong> libraw_colordata_t color; </strong></dt>
-      <dd>The structure contains color data retrieved from the file. Fields of
-        this structure are described in detail <a href="#libraw_colordata_t">
-          below </a> .</dd>
-      <dt><strong> libraw_imgother_t other; </strong></dt>
-      <dd>Data structure for information purposes: it contains the image
-        parameters that have been extracted from the file but are not needed in
-        further file processing. Fields of this structure are described in
-        detail <a href="#libraw_imgother_t"> below </a> .</dd>
-      <dt><strong> libraw_thumbnail_t thumbnail; </strong></dt>
-      <dd>Data structure containing information on the preview and the preview
-        data themselves. All fields of this structure but thumbnail itself are
-        filled when open_file() is called. Thumbnail readed by unpack_thumb()
-        call. The fields are described in detail <a href="#libraw_thumbnail_t">
-          below </a> .</dd>
-      <dt><strong> libraw_rawdata_t rawdata; </strong></dt>
-      <dd>Data structure with pointer to raw-data buffer. Details are described
-        <a href="#libraw_rawdata_t"> below </a> .</dd>
-      <dt><strong> ushort (*image)[4]; </strong></dt>
-      <dd>The memory area that contains the image pixels per se. It is filled
-        when raw2image() or dcraw_process() is called.</dd>
-      <dt><strong> libraw_output_params_t params; </strong></dt>
-      <dd>Data structure intended for management of image postprocessing (using
-        the dcraw emulator). Fields of this structure are described in detail <a
-          href="#libraw_iparams_t"> below </a> .</dd>
-      <dt>libraw_callbacks_t callbacks;</dt>
-      <dd><a href="#libraw_callbacks_t">user-settable callbacks</a> </dd>
-    </dl>
-    <p><a name="libraw_iparams_t"></a></p>
-    <h3>Structure libraw_iparams_t: Main Parameters of the Image</h3>
-    <dl>
-      <dt><strong> char make[64]; </strong></dt>
-      <dd>Camera manufacturer.</dd>
-      <dt><strong> char model[64]; </strong></dt>
-      <dd>Camera model.</dd>
-      <dt><b>normalized_make[64]</b></dt>
-      <dd> There is a huge number of identical cameras sold under different
-        names, depending on the market (e.g. multiple Panasonic or Canon models)
-        and even some identical cameras sold under different brands (Panasonic
-        -&gt; Leica, Sony -&gt; Hasselblad). normalized_make contains primary
-        vendor name (e.g. Panasonic for Leica re-branded cameras). </dd>
-      <dt><b>normalized_model[64]</b></dt>
-      <dd> Primary camera model name. </dd>
-      <dt><b>unsigned maker_index</b></dt>
-      <dd>Primary vendor name in indexed form (enum LibRaw_cameramaker_index,
-        LIBRAW_CAMERAMAKER_* constant) </dd>
-      <dt><strong> char software[64]; </strong></dt>
-      <dd>Softwary name/version (mostly for DNG files, to distinguish in-camera
-        DNGs from Adobe DNG Converter produced ones).</dd>
-      <dt><strong> unsigned raw_count; </strong></dt>
-      <dd>Number of RAW images in file (0 means that the file has not been
-        recognized).</dd>
-      <dt><strong> unsigned is_foveon; </strong></dt>
-      <dd>Nonzero for Sigma Foveon images</dd>
-      <dt><strong> unsigned dng_version; </strong></dt>
-      <dd>DNG version (for the DNG format).</dd>
-      <dt><strong> int colors; </strong></dt>
-      <dd>Number of colors in the file.</dd>
-      <dt><strong> unsigned filters; </strong></dt>
-      <dd>Bit mask describing the order of color pixels in the matrix (0 for
-        full-color images). 32 bits of this field describe 16 pixels (8 rows
-        with two pixels in each, from left to right and from top to bottom).
-        Each two bits have values 0 to 3, which correspond to four possible
-        colors. Convenient work with this field is ensured by the
-        COLOR(row,column) function, which returns the number of the active color
-        for a given pixel.<br>
-        Values less than 1000 are reserved as special cases:
-        <ul>
-          <li><strong> 1 </strong> - Leaf Catchlight with 16x16 bayer matrix;</li>
-          <li><strong> 9 </strong> - Fuji X-Trans (6x6 matrix)</li>
-          <li>3..8 and 10..999 - are unused.</li>
-        </ul>
-      </dd>
-      <dt><strong> char xtrans[6][6]; </strong></dt>
-      <dt><strong> char xtrans_abs[6][6]; </strong></dt>
-      <dd>These matrices contains Fuji X-Trans row/col to color mapping. First
-        one is relative to visible area, while second is positioned relative to
-        sensor edges.</dd>
-      <dt><strong> char cdesc[5]; </strong></dt>
-      <dd>Description of colors numbered from 0 to 3 (RGBG,RGBE,GMCY, or GBTG).</dd>
-      <dt><strong> unsigned xmplen; char *xmpdata; </strong></dt>
-      <dd>XMP packed data length and pointer to extracted XMP packet.</dd>
-    </dl>
-    <p><a name="libraw_image_sizes_t"></a></p>
-    <h3>Structure libraw_image_sizes_t: Image Dimensions</h3>
-    <p>Structure libraw_image_sizes_t is a collection of all file data that
-      describe the size of the image. </p>
-    <h4> Data fields:</h4>
-    <dl>
-      <dt><strong> ushort raw_height, raw_width; </strong></dt>
-      <dd>Full size of RAW image (including the frame) in pixels.</dd>
-      <dt><strong> ushort height, width; </strong></dt>
-      <dd>Size of visible ("meaningful") part of the image (without the frame).</dd>
-      <dt><strong> ushort top_margin, left_margin; </strong></dt>
-      <dd>Coordinates of the top left corner of the frame (the second corner is
-        calculated from the full size of the image and size of its visible
-        part).</dd>
-      <dt><strong> ushort iheight, iwidth; </strong></dt>
-      <dd>Size of the output image (may differ from height/width for cameras
-        that require image rotation or have non-square pixels).</dd>
-      <dt><strong> unsigned raw_pitch; </strong></dt>
-      <dd>Full size of raw data row <strong> in bytes </strong> .</dd>
-      <dt><strong> double pixel_aspect; </strong></dt>
-      <dd>Pixel width/height ratio. If it is not unity, scaling of the image
-        along one of the axes is required during output.</dd>
-      <dt><strong> int flip; </strong></dt>
-      <dd>Image orientation (0 if does not require rotation; 3 if requires
-        180-deg rotation; 5 if 90 deg counterclockwise, 6 if 90 deg clockwise).</dd>
-    </dl>
-    <p><a name="libraw_colordata_t"></a></p>
-    <h3>Structure libraw_colordata_t: Color Information</h3>
-    <p>Structure libraw_colordata_t unites all color data, both retrieved from
-      the RAW file and calculated on the basis of the image itself. For
-      different cameras, there are different ways of color handling. </p>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> ushort curve[0x10000]; </strong></dt>
-      <dd>Camera tone curve. May be read from file as is, or calculated,
-        depending on file format;</dd>
-      <dt><strong> unsigned black; </strong></dt>
-      <dd>Black level. Depending on the camera, it may be zero (this means that
-        black has been subtracted at the unpacking stage or by the camera
-        itself), calculated at the unpacking stage, read from the RAW file, or
-        hardcoded.</dd>
-      <dt><strong> unsigned cblack[4102]; </strong></dt>
-      <dd>Per-channel black level correction. First 4 values are per-channel
-        correction, next two are black level pattern block size, than
-        cblack[4]*cblack[5] correction values (for indexes
-        [6....6+cblack[4]*cblack[5]).</dd>
-      <dt><strong> unsigned data_maximum; </strong></dt>
-      <dd>Maximum pixel value in current file. Calculated at raw2image or
-        dcraw_process() calls.</dd>
-      <dt><strong> unsigned maximum; </strong></dt>
-      <dd>Maximum pixel value. Calculated from the data for most cameras,
-        hardcoded for others. This value may be changed on postprocessing stage
-        (when black subtraction performed) and by automated maximum adjustment
-        (this adjustment performed if <strong> params.adjust_maximum_thr </strong>
-        is set to nonzero).</dd>
-      <dt><strong> unsigned linear_max[4]; </strong></dt>
-      <dd>Per-channel linear data maximum read from file metadata. If RAW file
-        does not contains this data, linear_max[] is set to zero. Black value is
-        not subtracted</dd>
-      <dt><strong> float fmaximum; </strong></dt>
-      <dd>Maximum pixel value in real image for floating data files.</dd>
-      <dt><strong> float fnorm; </strong></dt>
-      <dd>Normalization coefficient used while converting floating point raw
-        data to integer.</dd>
-      <dt><strong> ushort white[8][8]; </strong></dt>
-      <dd>Block of white pixels extracted from files CIFF/CRW. Not extracted for
-        other formats. Used to calculate white balance coefficients.</dd>
-      <dt><strong> float cam_xyz[4][3]; </strong></dt>
-      <dd>Camera RGB - XYZ conversion matrix. This matrix is constant (different
-        for different models). Last row is zero for RGB cameras and non-zero for
-        different color models (CMYG and so on).</dd>
-      <dt><strong> float cam_mul[4]; </strong></dt>
-      <dd>White balance coefficients (as shot). Either read from file or
-        calculated.</dd>
-      <dt><strong> float pre_mul[4]; </strong></dt>
-      <dd>White balance coefficients for daylight (daylight balance). Either
-        read from file, or calculated on the basis of file data, or taken from
-        hardcoded constants.</dd>
-      <dt><strong> float cmatrix[3][4]; </strong></dt>
-      <dd>Camera color data read from RAW file (if any)</dd>
-      <dt><strong> float rgb_cam[3][4]; </strong></dt>
-      <dd>Camera to sRGB conversion matrix</dd>
-      <dt><strong> float ccm[3][4]; </strong></dt>
-      <dd>Camera color correction matrix readed from file metadata (uniform
-        matrix if no such data in file)</dd>
-      <dt><strong> ph1_t phase_one_data; </strong></dt>
-      <dd>Color data block that is read for Phase One cameras.</dd>
-      <dt><strong> float flash_used; </strong></dt>
-      <dt><strong> float canon_ev; </strong></dt>
-      <dd>Fields used for white balance calculations (for some P&amp;S Canon
-        cameras).</dd>
-      <dt><strong> char model2[64]; </strong></dt>
-      <dd>Firmware revision (for some cameras).</dd>
-      <dt><strong> char UniqueCameraModel[64],LocalizedCameraModel[64]; </strong></dt>
-      <dd>Values from DNG tags with same names.</dd>
-      <dt><strong> void *profile; </strong></dt>
-      <dd>Pointer to the retrieved ICC profile (if it is present in the RAW
-        file).</dd>
-      <dt><strong> unsigned profile_length; </strong></dt>
-      <dd>Length of ICC profile in bytes.</dd>
-      <dt><strong> unsigned black_stat[8]; </strong></dt>
-      <dd>Black level statistics if calcluated from masked area: 4 sum of pixel
-        values, than 4 pixel counts (per channel).</dd>
-      <dt><strong> libraw_dng_color_t dng_color[2]; </strong></dt>
-      <dd>Color data read from DNG: illuminant, calbiration matrix and color
-        matrix for two light sources. (see DNG specs for details).</dd>
-      <dt>libraw_dng_levels_t dng_levels</dt>
-      <dd>DNG black/white levels, analog balance, WB for active IFD. See DNG
-        specs for details.</dd>
-      <dt>int WB_Coeffs[256][4]</dt>
-      <dd>Index: EXIF color source value, [i][0..3] WB Coeffs</dd>
-      <dt>float WBCT_Coeffs[64][5]</dt>
-      <dd>Color temperature in [i][0], WB coeffs in [i][1..4]</dd>
-      <dt>int as_shot_wb_applied</dt>
-      <dd>Set to 1 if WB already applied in camera (multishot modes; small raw)</dd>
-      <dt>libraw_P1_color_t P1_color[2]</dt>
-      <dd>Phase-one specific color data</dd>
-      <dt>unsigned raw_bps</dt>
-      <dd>RAW bits per pixel (PhaseOne: Raw format used)</dd>
-      <dt>int ExifColorSpace</dt>
-      <dd>EXIF color space parsed from EXIF tags: LIBRAW_COLORSPACE_Unknown,
-        LIBRAW_COLORSPACE_sRGB, or LIBRAW_COLORSPACE_Adobe</dd>
-    </dl>
-    <p><a name="libraw_imgother_t"></a></p>
-    <h3>Structure libraw_imgother_t: Other Parameters of the Image</h3>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> float iso_speed; </strong></dt>
-      <dd>ISO sensitivity.</dd>
-      <dt><strong> float shutter; </strong></dt>
-      <dd>Shutter speed.</dd>
-      <dt><strong> float aperture; </strong></dt>
-      <dd>Aperture.</dd>
-      <dt><strong> float focal_len; </strong></dt>
-      <dd>Focal length.</dd>
-      <dt><strong> time_t timestamp; </strong></dt>
-      <dd>Date of shooting.</dd>
-      <dt><strong> unsigned shot_order; </strong></dt>
-      <dd>Serial number of image.</dd>
-      <dt><strong> unsigned gpsdata[32]; </strong></dt>
-      <dd>GPS data (unparsed block, to write to output as is).</dd>
-      <dt><strong> libraw_gps_info_t parsed_gps; </strong></dt>
-      <dd>Parsed GPS-data: longitude/latitude/altitude and time stamp.</dd>
-      <dt><strong> char desc[512]; </strong></dt>
-      <dd>Image description.</dd>
-      <dt><strong> char artist[64]; </strong></dt>
-      <dd>Author of image.</dd>
-      <dt><strong> float FlashEC; </strong></dt>
-      <dd>Flash exposure compensation.</dd>
-    </dl>
-    <p><a name="libraw_rawdata_t"></a></p>
-    <h3>Structure libraw_rawdata_t: holds unpacked RAW data</h3>
-    <p>Structure libraw_rawdata_t holds:</p>
-    <ul>
-      <li>RAW-data from sensor, readed and unpacked by the <a href="API-CXX.html#unpack">
-          unpack() </a> call.</li>
-      <li>"backup" copy of color and over data modified during postprocessing.
-        When postprocessing calls repeats, the needed data is restored from this
-        backup.</li>
-    </ul>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt>void *raw_alloc;</dt>
-      <dd>Buffer allocated to hold RAW-data</dd>
-      <dt><strong> unsigned short *raw_image; </strong></dt>
-      <dd>Pointer to buffer with one-component (bayer) data.</dd>
-      <dt><strong> unsigned short (*color3_image)[3]; </strong></dt>
-      <dd>Pointer to 3-component pixel array.</dd>
-      <dt><strong> unsigned short (*color4_image)[4]; </strong></dt>
-      <dd>Pointer to buffer with 4-component pixel data data</dd>
-      <dt><strong> float *float_image; </strong></dt>
-      <dd>Pointer to buffer with one-component (bayer) data in FP-format.</dd>
-      <dt><strong> float (*float3_image)[3]; </strong></dt>
-      <dd>Pointer to 3-component FP pixel array.</dd>
-      <dt><strong> float (*float4_image)[4]; </strong></dt>
-      <dd>Pointer to buffer with 4-component pixel data data</dd>
-    </dl>
-    <p>After call to <a href="API-CXX.html#unpack"> unpack() </a> only one of
-      these fields is non-NULL.</p>
-    <p>All other fields of this structure are for internal use and should not be
-      touched by user code. <a name="libraw_thumbnail_t"></a></p>
-    <h3>Structure libraw_thumbnail_t: Description of Thumbnail</h3>
-    <p>Structure libraw_thumbnail_t describes all parameters associated with the
-      preview saved in the RAW file. </p>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> LibRaw_thumbnail_formats tformat; </strong></dt>
-      <dd>Thumbnail data format. One of the values among enum <a href="#LibRaw_thumbnail_formats">
-          LibRaw_thumbnail_formats </a> .</dd>
-      <dt><strong> ushort twidth, theight; </strong></dt>
-      <dd>Dimensions of the preview image in pixels.</dd>
-      <dt><strong> unsigned tlength; </strong></dt>
-      <dd>Thumbnail length in bytes.</dd>
-      <dt><strong> int tcolors; </strong></dt>
-      <dd>Number of colors in the preview.</dd>
-      <dt><strong> char *thumb; </strong></dt>
-      <dd>Pointer to thumbmail, extracted from the data file.</dd>
-    </dl>
-    <p><a name="libraw_lensinfo_t"></a></p>
-    <h3>Structure libraw_lensinfo_t: parsed lens data</h3>
-    <p>The following parameters are extracted from Makernotes and EXIF, to help
-      identify which lens was mounted on the camera. If the value is missing in
-      Makernotes or EXIF, the parameter is set to zero with some exceptions
-      noted below. In some cases the values for the fields like CameraFormat and
-      CameraMount are set based on the camera model and/or camera ID.</p>
-    <h4>libraw_makernotes_lens_t structure:</h4>
-    <ul>
-      <li><strong>LensID</strong> (if not -1) and <strong>CamID</strong>
-        (camera id, if non-zero) values are compatible with those used in
-        exiftool, like |0x0010 CanonModelID| and |22 LensType| see <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Canon.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Canon.html</a>
-        or 0x0207/CameraType and 0x0201/LensType (see <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Olympus.htmlhttp://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Olympus.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Olympus.html</a>
-        )</li>
-      <li><strong>Lens</strong> string, if not empty, contains the lens name
-        present in Makernotes.</li>
-      <li><strong>LensFormat </strong>and <strong>CameraFormat</strong>
-        currently provide one of value from <strong>enum LibRaw_camera_formats</strong>;</li>
-      <li>In a similar manner, values for <strong>LensMount</strong> and <strong>CameraMount</strong>
-        follow the <strong>enum LibRaw_camera_mounts</strong>;</li>
-      <li>In some cases, the Makernotes for MF cameras contain either an id for
-        the body, or a string containing the name of the body. The name is
-        copied to <strong>body</strong> field, while the id is converted to the
-        appropriate body name and also copied to 'body' field. In other cases
-        the 'body' field is empty.</li>
-      <li><strong>FocalType</strong> is set based on Makernotes tag, if present.
-        The values are: </li>
-      <ul>
-        <li>-1 Undefined</li>
-        <li>0 Unknown;</li>
-        <li>1 Fixed focal length lens</li>
-        <li>2 Zoom lens</li>
-      </ul>
-      <li><strong>LensFeatures_pre</strong> - lens name prefix and <strong>LensFeatures_suf</strong>
-        - lens name suffix: (if not empty) some cameras record alphabet soup
-        that characterizes the lens in separate Makernote tags (see, for
-        example, 0xb02a LensSpec at&nbsp;<a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Sony.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Sony.html</a>
-        ), and for some lenses those acronyms can be derived from the 'Lens'
-        field itself (see processCanonCameraInfo). Those can also help better
-        lens identification.</li>
-      <li><strong>MinFocal</strong> and <strong>MaxFocal</strong> , if
-        non-zero, contain the minimum and maximum focal lengths for the lens
-        mounted on the camera.</li>
-      <li><strong>MaxAp4MinFocal</strong>, <strong>MaxAp4MaxFocal</strong>, <strong>MinAp4MinFocal</strong>,
-        <strong>MinAp4MaxFocal</strong> - if non-zero, contain maximum aperture
-        available at minimal focal length, maximum aperture available at maximum
-        focal length, minimum aperture available at minimal focal length,
-        minimum aperture available at maximum focal length, respectively.</li>
-      <li><strong>MaxAp</strong> and <strong>MinAp</strong>, if non-zero,
-        contain the maximum aperture for the lens (usually it is the maximum
-        aperture for minimal focal length) and the minimum aperture across the
-        focal length range. For zooms with variable maximum aperture this is
-        usually the minimum aperture for the maximum focal length.</li>
-      <li><strong>CurFocal</strong>, if non-zero, is current focal length - that
-        is the focal length used to take the shot.</li>
-      <li><strong>CurAp</strong>, if non-zero, is current aperture.</li>
-      <li><strong>MaxAp4CurFocal</strong> and <strong>MinAp4CurFocal</strong>,
-        if non-zero, contain the minimum and maximum apertures for the current
-        focal length.</li>
-      <li><strong>LensFStops</strong> - if non-zero, contains the number of
-        aperture "clicks" or the number of f-stops, depending on the model of
-        the camera.</li>
-      <li><strong>TeleconverterID</strong>, <strong>AdapterID</strong>, <strong>AttachmentID</strong>,
-        if non-zero, are the numbers extracted from Makernotes to identify lens
-        accessories used to take the shot.</li>
-      <li><strong>Teleconverter</strong>, <strong>Adapter</strong>, <strong>Attachment</strong>,
-        if non-empty, are the strings containing the names of the accessories as
-        they appear in Makernotes, or for some cameras, decoded from a numeric
-        field in Makernotes.</li>
-      <li><strong>FocalUnits</strong> - an auxiliary field, should not be needed
-        most of the cases. See Canon.pm module in exiftool for more information
-        on this value.</li>
-      <li><strong>FocalLengthIn35mmFormat</strong>, if non-zero: for some reason
-        certain Samsung cameras record this value in Makernotes instead of the
-        EXIF proper. Also used for Sigma cameras.</li>
-    </ul>
-    <h4>libraw_nikonlens_t structure:</h4>
-    <p>Contains additional parameters needed to identify the lens on a Nikon
-      camera using a table - please see Nikon LensID Values at <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Nikon.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Nikon.html</a></p>
-    <h4>libraw_dnglens_t structure:</h4>
-    <p>Contains minimum focal length, maximum focal length, maximum aperture
-      available at minimal focal length, and maximum aperture available at
-      maximum focal length, extracted from EXIF field of a DNG raw file.</p>
-    <h4>libraw_lensinfo_t structure:</h4>
-    <p>Contains all the structures described above, plus parameters extracted
-      directly from EXIF fields:</p>
-    <ul>
-      <li><strong>MinFocal</strong> and <strong>MaxFocal</strong> , if
-        non-zero, contain the minimum and maximum focal lengths for the lens
-        mounted on the camera.</li>
-      <li><strong>MaxAp4MinFocal</strong>, <strong>MaxAp4MaxFocal</strong> - if
-        non-zero, contain maximum aperture available at minimal focal length and
-        maximum aperture available at maximum focal length</li>
-      <li><strong>LensMake</strong>, if not empty, contains a string with the
-        lens manufacturer name.</li>
-      <li><strong>Lens</strong>, if not empty, contains the lens name as
-        recorded in EXIF</li>
-      <li><strong>FocalLengthIn35mmFormat</strong> - if non-zero, same as
-        FocalLengthIn35mmFilm in EXIF standard, tag 0xa405.</li>
-      <li><strong>EXIF_MaxAp</strong> - if non-zero, contains the value derived
-        from EXIF tag 0x9205.</li>
-    </ul>
-    <p><a name="libraw_raw_unpack_params_t"></a></p>
-    <h3>Structure libraw_raw_unpack_params_t: RAW decoding options and flags</h3>
-    <p>Structure libraw_raw_unpack_params_t contains fields/flags that affects
-      RAWdata and metadata decoding</p>
-    <dl>
-      <dt><strong> int options </strong></dt>
-      <dd>Processing options used on unpack() phase for specific image formats,
-        see below for possible values:<a href="#LibRaw_processing_options">
-          LibRaw_processing_options</a></dd>
-      <dt><strong> int specials </strong></dt>
-      <dd>Special processing mode (e.g. omit YCC to RGB conversion), see below
-        for possible values. <a href="#LibRaw_rawspecial_t">
-          LibRaw_rawspecial_t</a></dd>
-      <dt><strong>int max_raw_memory_mb</strong></dt>
-      <dd>Stop processing if raw buffer size grows larger than that value (in
-        megabytes). Default is LIBRAW_MAX_ALLOC_MB_DEFAULT (2048Mb)</dd>
-      <dt><strong> int sony_arw2_posterization_thr </strong></dt>
-      <dd>If LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE used for
-        raw_processing_options, sets the level to suppress posterization display
-        in shadows.</dd>
-      <dt><strong> float coolscan_nef_gamma; </strong></dt>
-      <dd>Gamma value for Coolscan NEF decoding (no way to get if from file, it
-        should be set by calling application).</dd>
-      <dt><strong> char p4shot_order[5]; </strong></dt>
-      <dd>Shot order for Pentax 4shot files. Default is "3102".</dd>
-    </dl>
-    <h3></h3>
-    <h3>Structure libraw_output_params_t: management of dcraw-style
-      postprocessing</h3>
-    <p>Structure libraw_output_params_t (imgdata.params) is used for management
-      of dcraw-compatible calls dcraw_process(), dcraw_ppm_tiff_writer(), and
-      dcraw_thumb_writer(). Fields of this structure correspond to command line
-      keys of dcraw. </p>
-    <h4> Data fields:</h4>
-    <dl>
-      <dt><strong> unsigned greybox[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -A x y w h <br>
-        4 numbers corresponding to the coordinates (in pixels) of the rectangle
-        that is used to calculate the white balance. X and Y are coordinates of
-        the left-top rectangle corner; w and h are the rectangle's width and
-        height, respectively.</dd>
-      <dt><strong> unsigned cropbox[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        This field sets the image cropping rectangle. Cropbox[0] and cropbox[1]
-        are the rectangle's top-left corner coordinates, remaining two values
-        are width and height respectively. All coordinates are applied before
-        any image rotation.</dd>
-      <dt><strong> double aber[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -C <br>
-        Correction of chromatic aberrations; the only specified values are <br>
-        aber[0], the red multiplier <br>
-        aber[2], the blue multiplier. For some formats, it affects <a href="API-notes.html">
-          RAW data reading </a> , since correction of aberrations changes the
-        output size.</dd>
-      <dt><strong> double gamm[6]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -g power toe_slope <br>
-        Sets user gamma-curve. Library user should set first two fields of gamm
-        array: <br>
-        gamm[0] - <strong> inverted </strong> gamma value) <br>
-        gamm[1] - slope for linear part (so called toe slope). Set to zero for
-        simple power curve. <br>
-        Remaining 4 values are filled automatically.<br>
-        By default settings for rec. BT.709 are used: power 2.222 (i.e.
-        gamm[0]=1/2.222) and slope 4.5. For sRGB curve use gamm[0]=1/2.4 and
-        gamm[1]=12.92, for linear curve set gamm[0]/gamm[1] to 1.0. </dd>
-      <dt><strong> float user_mul[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -r mul0 mul1 mul2 mul3 <br>
-        4 multipliers (r,g,b,g) of the user's white balance.</dd>
-      <dt><strong> unsigned shot_select; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -s <br>
-        Selection of image number for processing (for formats that contain
-        several RAW images in one file).</dd>
-      <dt><strong> float bright; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -b <br>
-        Brightness (default 1.0).</dd>
-      <dt><strong> float threshold; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -n <br>
-        Parameter for noise reduction through wavelet denoising.</dd>
-      <dt><strong> int half_size; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -h <br>
-        Outputs the image in 50% size. For some formats, it affects <a href="API-notes.html">
-          RAW data reading </a> .</dd>
-      <dt><strong> int four_color_rgb; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -f <br>
-        Switches on separate interpolations for two green components.</dd>
-      <dt><strong> int highlight; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -H <br>
-        0-9: Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild).</dd>
-      <dt><strong> int use_auto_wb; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -a <br>
-        Use automatic white balance obtained after averaging over the entire
-        image.</dd>
-      <dt><strong> int use_camera_wb; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -w <br>
-        If possible, use the white balance from the camera.
-        <p> If camera-recorded WB is not available, dcraw_process() will
-          fallback to: </p>
-        <ul>
-          <li>Auto-WB if bit LIBRAW_PROCESSING_CAMERAWB_FALLBACK_TO_DAYLIGHT is
-            not set in params.raw_processing_options (or for the rare specific
-            case: no valid WB index was parsed from CRW file) </li>
-          <li>Daylight-WB if abovementioned bit is not set. </li>
-        </ul>
-      </dd>
-      <dt><strong> int use_camera_matrix; </strong></dt>
-      <dd><strong> dcraw keys: </strong> +M/-M <br>
-        <ul>
-          <li>0: do not use embedded color profile</li>
-          <li>1 (default): use embedded color profile (if present) for DNG files
-            (always); for other files only if use_camera_wb is set;</li>
-          <li>3: use embedded color data (if present) regardless of white
-            balance setting.</li>
-        </ul>
-      </dd>
-      <dt><strong> int output_color; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -o <br>
-        [0-8] Output colorspace (raw, sRGB, Adobe, Wide, ProPhoto, XYZ, ACES, DCI-P3, Rec. 2020).</dd>
-      <dt><strong> char* output_profile; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -o filename <br>
-        Path to output profile ICC file (used only if LibRaw compiled with LCMS
-        support)</dd>
-      <dt><strong> char* camera_profile; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -p file <br>
-        Path to input (camera) profile ICC file (or 'embed' for embedded
-        profile). Used only if LCMS support compiled in.</dd>
-      <dt><strong> char* bad_pixels; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -P file <br>
-        Path to file with bad pixels map (in dcraw format: "column row
-        date-of-pixel-death-in-UNIX-format", one pixel per row).</dd>
-      <dt><strong> char* dark_frame; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -K file <br>
-        Path to dark frame file (in 16-bit PGM format)</dd>
-      <dt><strong> int output_bps; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -4 <br>
-        8 bit (default)/16 bit (key -4).</dd>
-      <dt><strong> int output_tiff; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -T <br>
-        0/1: output PPM/TIFF.</dd>
-      <dt><strong> int output_flags; </strong></dt>
-      <dd><strong> dcraw keys:</strong> none<br>
-        Bitfield that allows to set output file options:
-        <ul>
-          <li><strong>LIBRAW_OUTPUT_FLAGS_PPMMETA</strong> - write additional
-            metadata into PPM/PGM output files</li>
-        </ul>
-      </dd>
-      <dt><strong> int user_flip; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -t <br>
-        [0-7] Flip image (0=none, 3=180, 5=90CCW, 6=90CW). Default -1, which
-        means taking the corresponding value from RAW. <br>
-        For some formats, <a href="API-notes.html"> affects RAW data reading </a>
-        , e.g., unpacking of thumbnails from Kodak cameras.</dd>
-      <dt><strong> int user_qual; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -q <br>
-        0-10: interpolation quality:
-        <ul>
-          <li>0 - linear interpolation</li>
-          <li>1 - VNG interpolation</li>
-          <li>2 - PPG interpolation</li>
-          <li>3 - AHD interpolation</li>
-          <li>4 - DCB interpolation</li>
-          <li>11 - DHT intepolation</li>
-          <li>12 - Modified AHD intepolation (by Anton Petrusevich)</li>
-        </ul>
-      </dd>
-      <dt><strong> int user_black; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -k <br>
-        User black level.</dd>
-      <dt><strong> int user_cblack[4]; </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        Per-channel corrections to user_black.</dd>
-      <dt><strong> int user_sat; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -S <br>
-        Saturation adjustment.</dd>
-      <dt><strong> int med_passes; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -m <br>
-        Number of median filter passes.</dd>
-      <dt><strong> int no_auto_bright; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -W <br>
-        Don't use automatic increase of brightness by histogram.</dd>
-      <dt><strong> float auto_bright_thr; </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        Portion of clipped pixels when auto brighness increase is used. Default
-        value is 0.01 (1%) for dcraw compatibility. Recommended value for modern
-        low-noise multimegapixel cameras depends on shooting style. Values in
-        0.001-0.00003 range looks reasonable.</dd>
-      <dt><strong> float adjust_maximum_thr; </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        This parameters controls auto-adjusting of maximum value based on
-        channel_maximum[] data, calculated from real frame data. If calculated
-        maximum is greater than adjust_maximum_thr*maximum, than maximum is set
-        to calculated_maximum. <br>
-        Default: 0.75. If you set this value above 0.99999, than default value
-        will be used. If you set this value below 0.00001, than no maximum
-        adjustment will be performed. <br>
-        Adjusting maximum should not damage any picture (esp. if you use default
-        value) and is very useful for correcting channel overflow problems
-        (magenta clouds on landscape shots, green-blue highlights for indoor
-        shots).</dd>
-      <dt><strong> int use_fuji_rotate; </strong></dt>
-      <dd><strong> dcraw keys: </strong> -j <br>
-        Default -1 (use), 0 - don't use rotation for cameras on a Fuji sensor.</dd>
-      <dt><strong> int green_matching; </strong></dt>
-      <dd>Turns on fixing of green channels disbalance. <strong> dcraw keys: </strong>
-        none <br>
-        Default: 0 (not use), 1 - turns on this postprocessing stage.
-        green_matching requires additional memory for image data.</dd>
-      <dt><strong> int dcb_iterations </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        Number of DCB correction passes. Default is -1 (no correction). Useful
-        only for DCB interpolation.</dd>
-      <dt><strong> int dcb_enhance_fl </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        nonzero: DCB interpolation with enhance interpolated colors.</dd>
-      <dt><strong> int fbdd_noiserd </strong></dt>
-      <dd><strong> dcraw keys: </strong> none <br>
-        Controls FBDD noise reduction before demosaic.
-        <ul>
-          <li>0 - do not use FBDD noise reduction</li>
-          <li>1 - light FBDD reduction</li>
-          <li>2 (and more) - full FBDD reduction</li>
-        </ul>
-      </dd>
-      <dt><strong> int exp_correc; float exp_shift,exp_preser; </strong></dt>
-      <dd>Exposure correction before demosaic. <br>
-        <ul>
-          <li>exp_correc: positive value turns the feature on (default: off).</li>
-          <li>exp_shift: exposure shift in linear scale. Usable range from 0.25
-            (2-stop darken) to 8.0 (3-stop lighter). Default: 1.0 (no exposure
-            shift).</li>
-          <li>exp_preser: preserve highlights when lighten the image. Usable
-            range from 0.0 (no preservation) to 1.0 (full preservation). 0.0 is
-            the default value.</li>
-        </ul>
-      </dd>
-      <dt><strong> int use_rawspeed; </strong></dt>
-      <dd>Turns on using RawSpeed library for data unpacking (only if RawSpeed
-        support compiled in).</dd>
-      <dt><strong>int use_dng_sdk; </strong></dt>
-      <dd>Turns on using Adobe DNG SDK (if compiled with it and dng host is set:
-        <br>
-        <ul>
-          <li>0 - do not use</li>
-          <li>1 - use for speciality formats (Float, Linear DNG, deflate
-            compression, 8 bit)</li>
-          <li>2 - use for all DNG files</li>
-        </ul>
-      </dd>
-      <dt><strong> int no_auto_scale; </strong></dt>
-      <dd>Disables pixel values scaling (call to LibRaw::scale_colors()) in
-        LibRaw::dcraw_process().<br>
-        This is <strong>special use value</strong> because white balance is
-        performed in scale_colors(), so skipping it will result in non-balanced
-        image.<br>
-        This setting is targeted to use with no_interpolation, or with own
-        interpolation callback call.</dd>
-      <dt><strong> int no_interpolation; </strong></dt>
-      <dd>Disables call to demosaic code in LibRaw::dcraw_process()</dd>
-    </dl>
-    <p><a name="libraw_callbacks_t"></a></p>
-    <h3>Structure libraw_callbacks_t: user-settable callbacks</h3>
-    <dl>
-      <dt>memory_callback mem_cb</dt>
-      <dd>Called on memory allocation error. Settable via set_memerror_handler.
-        See <a href="API-CXX.html#callbacks">C++ API</a> for details.</dd>
-      <dt>data_callback data_cb</dt>
+<html>
+  <head>
+    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
+    <title>LibRaw: Data Structures and Constants</title>
+  </head>
+  <body>
+    <p>LibRaw: Data Structures and Constants <a href="index.html"> [back to
+        Index] </a></p>
+    <h1>LibRaw: Data Structures and Constants</h1>
+    <p>LibRaw data structures are defined in header file libraw/libraw_types.h <br>
+      Constants used in its work are defined in file libraw/libraw_const.h</p>
+    <h2>Contents:</h2>
+    <ol>
+      <li><a href="#datastruct"> Data structures </a>
+        <ol>
+          <li><a href="#libraw_data_t"> libraw_data_t: Main Data Structure in
+              LibRaw </a></li>
+          <li><a href="#libraw_iparams_t"> Structure libraw_iparams_t: Main
+              Parameters of the Image </a></li>
+          <li><a href="#libraw_image_sizes_t"> Structure libraw_image_sizes_t:
+              Image Dimensions </a></li>
+          <li><a href="#libraw_colordata_t"> Structure libraw_colordata_t: Color
+              Information </a></li>
+          <li><a href="#libraw_imgother_t"> Structure libraw_imgother_t: Other
+              Parameters of the Image </a></li>
+          <li><a href="#libraw_rawdata_t"> Structure libraw_rawdata_t: holds
+              unpacked RAW data </a></li>
+          <li><a href="#libraw_thumbnail_t"> Structure libraw_thumbnail_t:
+              Description of Thumbnail </a></li>
+          <li><a href="#libraw_lensinfo_t"> Structure libraw_lensinfo_t - lens
+              data, extracted from EXIF/Makernotes </a></li>
+          <li><a href="#libraw_raw_unpack_params_t"> Structure
+              libraw_raw_unpack_params_t: metadata and raw decoding options and
+              flags</a></li>
+          <li><a href="#libraw_output_params_t"> Structure
+              libraw_output_params_t: Management of dcraw-style postprocessing </a></li>
+          <li><a href="#libraw_callbacks_t">Structure libraw_callbacks_t:
+              user-settable callbacks</a> </li>
+          <li><a href="#libraw_processed_image_t"> Structure
+              libraw_processed_image_t - result set for
+              dcraw_make_mem_image()/dcraw_make_mem_thumb() functions </a></li>
+        </ol>
+      </li>
+      <li><a href="#datastream"> Input abstraction layer </a>
+        <ul>
+          <li><a href="#datastream_data"> Data fields </a></li>
+        </ul>
+      </li>
+      <li><a href="#const"> Constants </a>
+        <ol>
+          <li><a href="#LibRaw_errors"> enum LibRaw_errors: Error Codes </a></li>
+          <li><a href="#decoder_flags"> enum LibRaw_decoder_flags - RAW data
+              format description </a></li>
+          <li><a href="#progress"> enum LibRaw_progress: Current State of LibRaw
+              Object </a></li>
+          <li><a href="#LibRaw_thumbnail_formats"> enum
+              LibRaw_thumbnail_formats: Thumbnail Data Formats </a></li>
+          <li><a href="#warnings"> Nonstandard Situations (Warnings) during RAW
+              Data Processing </a></li>
+          <li><a href="#LibRaw_image_formats"> enum LibRaw_image_formats -
+              possible types of data, contains in libraw_processed_image_t
+              structure</a></li>
+          <li><a href="#LibRaw_processing_options">enum
+              LibRaw_processing_options - flags that affects extracted RAW data</a></li>
+          <li><a href="#LibRaw_rawspecial_t">enum LibRaw_rawspecial_t - special
+              raw extraction modes</a></li>
+        </ol>
+      </li>
+    </ol>
+    <p><a name="datastruct"></a></p>
+    <h2>Data Structures</h2>
+    <p><a name="libraw_data_t"></a></p>
+    <h3>libraw_data_t: Main Data Structure of LibRaw</h3>
+    <p>Structure libraw_data_t is a "wrapping" for data structures accessible to
+      the user of the library. <br>
+      When one uses C++ API, it is accessible as LibRaw::imgdata
+      (class_instance.imgdata). The data in this structure appear after a file
+      is opened through open_file (and other open_ calls), except for the image
+      itself (filled by unpack()) and data containing the preview information
+      (filled by calling unpack_thumb()). </p>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> unsigned int progress_flags; </strong></dt>
+      <dd>This field records the past <a href="#progress"> phases of image
+          processing </a> .</dd>
+      <dt><strong> unsigned int process_warnings; </strong></dt>
+      <dd>This field records <a href="#warnings"> suspicious situations
+          (warnings) </a> that have emerged during image processing.</dd>
+      <dt><strong> libraw_iparams_t idata; </strong></dt>
+      <dd>The structure describes the main image parameters retrieved from the
+        RAW file. Fields of this structure are described in detail <a href="#libraw_iparams_t">
+          below </a> .</dd>
+      <dt><strong> libraw_image_sizes_t sizes; </strong></dt>
+      <dd>The structure describes the geometrical parameters of the image.
+        Fields of this structure are described in detail <a href="#libraw_image_sizes_t">
+          below </a> .</dd>
+      <dt><strong> libraw_lensinfo_t lens; </strong></dt>
+      <dd>The structure describes lens used for the shot. Fields of this
+        structure are described in detail <a href="#libraw_lensinfo_t"> below </a>
+        .</dd>
+      <dt><strong> libraw_makernotes_t makernotes; </strong></dt>
+      <dd>The structure contains camera/vendor specific metadata extracted from
+        file. No description provided, sorry, if you're interested in particular
+        tag/camera/vendor - use Exiftool documentation as a reference</dd>
+      <dt><strong> libraw_colordata_t color; </strong></dt>
+      <dd>The structure contains color data retrieved from the file. Fields of
+        this structure are described in detail <a href="#libraw_colordata_t">
+          below </a> .</dd>
+      <dt><strong> libraw_imgother_t other; </strong></dt>
+      <dd>Data structure for information purposes: it contains the image
+        parameters that have been extracted from the file but are not needed in
+        further file processing. Fields of this structure are described in
+        detail <a href="#libraw_imgother_t"> below </a> .</dd>
+      <dt><strong> libraw_thumbnail_t thumbnail; </strong></dt>
+      <dd>Data structure containing information on the preview and the preview
+        data themselves. All fields of this structure but thumbnail itself are
+        filled when open_file() is called. Thumbnail readed by unpack_thumb()
+        call. The fields are described in detail <a href="#libraw_thumbnail_t">
+          below </a> .</dd>
+      <dt><strong> libraw_rawdata_t rawdata; </strong></dt>
+      <dd>Data structure with pointer to raw-data buffer. Details are described
+        <a href="#libraw_rawdata_t"> below </a> .</dd>
+      <dt><strong> ushort (*image)[4]; </strong></dt>
+      <dd>The memory area that contains the image pixels per se. It is filled
+        when raw2image() or dcraw_process() is called.</dd>
+      <dt><strong> libraw_output_params_t params; </strong></dt>
+      <dd>Data structure intended for management of image postprocessing (using
+        the dcraw emulator). Fields of this structure are described in detail <a
+
+          href="#libraw_iparams_t"> below </a> .</dd>
+      <dt>libraw_callbacks_t callbacks;</dt>
+      <dd><a href="#libraw_callbacks_t">user-settable callbacks</a> </dd>
+    </dl>
+    <p><a name="libraw_iparams_t"></a></p>
+    <h3>Structure libraw_iparams_t: Main Parameters of the Image</h3>
+    <dl>
+      <dt><strong> char make[64]; </strong></dt>
+      <dd>Camera manufacturer.</dd>
+      <dt><strong> char model[64]; </strong></dt>
+      <dd>Camera model.</dd>
+      <dt><b>normalized_make[64]</b></dt>
+      <dd> There is a huge number of identical cameras sold under different
+        names, depending on the market (e.g. multiple Panasonic or Canon models)
+        and even some identical cameras sold under different brands (Panasonic
+        -&gt; Leica, Sony -&gt; Hasselblad). normalized_make contains primary
+        vendor name (e.g. Panasonic for Leica re-branded cameras). </dd>
+      <dt><b>normalized_model[64]</b></dt>
+      <dd> Primary camera model name. </dd>
+      <dt><b>unsigned maker_index</b></dt>
+      <dd>Primary vendor name in indexed form (enum LibRaw_cameramaker_index,
+        LIBRAW_CAMERAMAKER_* constant) </dd>
+      <dt><strong> char software[64]; </strong></dt>
+      <dd>Softwary name/version (mostly for DNG files, to distinguish in-camera
+        DNGs from Adobe DNG Converter produced ones).</dd>
+      <dt><strong> unsigned raw_count; </strong></dt>
+      <dd>Number of RAW images in file (0 means that the file has not been
+        recognized).</dd>
+      <dt><strong> unsigned is_foveon; </strong></dt>
+      <dd>Nonzero for Sigma Foveon images</dd>
+      <dt><strong> unsigned dng_version; </strong></dt>
+      <dd>DNG version (for the DNG format).</dd>
+      <dt><strong> int colors; </strong></dt>
+      <dd>Number of colors in the file.</dd>
+      <dt><strong> unsigned filters; </strong></dt>
+      <dd>Bit mask describing the order of color pixels in the matrix (0 for
+        full-color images). 32 bits of this field describe 16 pixels (8 rows
+        with two pixels in each, from left to right and from top to bottom).
+        Each two bits have values 0 to 3, which correspond to four possible
+        colors. Convenient work with this field is ensured by the
+        COLOR(row,column) function, which returns the number of the active color
+        for a given pixel.<br>
+        Values less than 1000 are reserved as special cases:
+        <ul>
+          <li><strong> 1 </strong> - Leaf Catchlight with 16x16 bayer matrix;</li>
+          <li><strong> 9 </strong> - Fuji X-Trans (6x6 matrix)</li>
+          <li>3..8 and 10..999 - are unused.</li>
+        </ul>
+      </dd>
+      <dt><strong> char xtrans[6][6]; </strong></dt>
+      <dt><strong> char xtrans_abs[6][6]; </strong></dt>
+      <dd>These matrices contains Fuji X-Trans row/col to color mapping. First
+        one is relative to visible area, while second is positioned relative to
+        sensor edges.</dd>
+      <dt><strong> char cdesc[5]; </strong></dt>
+      <dd>Description of colors numbered from 0 to 3 (RGBG,RGBE,GMCY, or GBTG).</dd>
+      <dt><strong> unsigned xmplen; char *xmpdata; </strong></dt>
+      <dd>XMP packed data length and pointer to extracted XMP packet.</dd>
+    </dl>
+    <p><a name="libraw_image_sizes_t"></a></p>
+    <h3>Structure libraw_image_sizes_t: Image Dimensions</h3>
+    <p>Structure libraw_image_sizes_t is a collection of all file data that
+      describe the size of the image. </p>
+    <h4> Data fields:</h4>
+    <dl>
+      <dt><strong> ushort raw_height, raw_width; </strong></dt>
+      <dd>Full size of RAW image (including the frame) in pixels.</dd>
+      <dt><strong> ushort height, width; </strong></dt>
+      <dd>Size of visible ("meaningful") part of the image (without the frame).</dd>
+      <dt><strong> ushort top_margin, left_margin; </strong></dt>
+      <dd>Coordinates of the top left corner of the frame (the second corner is
+        calculated from the full size of the image and size of its visible
+        part).</dd>
+      <dt><strong> ushort iheight, iwidth; </strong></dt>
+      <dd>Size of the output image (may differ from height/width for cameras
+        that require image rotation or have non-square pixels).</dd>
+      <dt><strong> unsigned raw_pitch; </strong></dt>
+      <dd>Full size of raw data row <strong> in bytes </strong> .</dd>
+      <dt><strong> double pixel_aspect; </strong></dt>
+      <dd>Pixel width/height ratio. If it is not unity, scaling of the image
+        along one of the axes is required during output.</dd>
+      <dt><strong> int flip; </strong></dt>
+      <dd>Image orientation (0 if does not require rotation; 3 if requires
+        180-deg rotation; 5 if 90 deg counterclockwise, 6 if 90 deg clockwise).</dd>
+      <dt><strong>libraw_raw_inset_crop_t raw_inset_crops[2];</strong></dt>
+      <dd>(<strong>libraw_raw_inset_crop_t: </strong>ushort cleft, ctop,
+        cwidth, cheight;)<ul>
+        <li>item at[0] contains standard crop data parsed from camera metadata (DNG:
+          DefaultCrop* tags, other formats: vendor specific tags)</li>
+        <li>item at [1] is 'user crop', in particular:
+       <br/>- set by DNG  DefaultUserCrop tag
+       <br/>- or set via raw aspect ratio tags (e.g. 16:9 aspect on Fujifilm cameras)
+          raw_inset_crops[1] is filled only if aspect ratio tags provides different
+          aspect ratio compared to raw_inset_crops[0].
+        </li></ul></dd>
+    </dl>
+    <p><a name="libraw_colordata_t"></a></p>
+    <h3>Structure libraw_colordata_t: Color Information</h3>
+    <p>Structure libraw_colordata_t unites all color data, both retrieved from
+      the RAW file and calculated on the basis of the image itself. For
+      different cameras, there are different ways of color handling. </p>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> ushort curve[0x10000]; </strong></dt>
+      <dd>Camera tone curve. May be read from file as is, or calculated,
+        depending on file format;</dd>
+      <dt><strong> unsigned black; </strong></dt>
+      <dd>Black level. Depending on the camera, it may be zero (this means that
+        black has been subtracted at the unpacking stage or by the camera
+        itself), calculated at the unpacking stage, read from the RAW file, or
+        hardcoded.</dd>
+      <dt><strong> unsigned cblack[4102]; </strong></dt>
+      <dd>Per-channel black level correction. First 4 values are per-channel
+        correction, next two are black level pattern block size, than
+        cblack[4]*cblack[5] correction values (for indexes
+        [6....6+cblack[4]*cblack[5]).</dd>
+      <dt><strong> unsigned data_maximum; </strong></dt>
+      <dd>Maximum pixel value in current file. Calculated at raw2image or
+        dcraw_process() calls.</dd>
+      <dt><strong> unsigned maximum; </strong></dt>
+      <dd>Maximum pixel value. Calculated from the data for most cameras,
+        hardcoded for others. This value may be changed on postprocessing stage
+        (when black subtraction performed) and by automated maximum adjustment
+        (this adjustment performed if <strong> params.adjust_maximum_thr </strong>
+        is set to nonzero).</dd>
+      <dt><strong> unsigned linear_max[4]; </strong></dt>
+      <dd>Per-channel linear data maximum read from file metadata. If RAW file
+        does not contains this data, linear_max[] is set to zero. Black value is
+        not subtracted</dd>
+      <dt><strong> float fmaximum; </strong></dt>
+      <dd>Maximum pixel value in real image for floating data files.</dd>
+      <dt><strong> float fnorm; </strong></dt>
+      <dd>Normalization coefficient used while converting floating point raw
+        data to integer.</dd>
+      <dt><strong> ushort white[8][8]; </strong></dt>
+      <dd>Block of white pixels extracted from files CIFF/CRW. Not extracted for
+        other formats. Used to calculate white balance coefficients.</dd>
+      <dt><strong> float cam_xyz[4][3]; </strong></dt>
+      <dd>Camera RGB - XYZ conversion matrix. This matrix is constant (different
+        for different models). Last row is zero for RGB cameras and non-zero for
+        different color models (CMYG and so on).</dd>
+      <dt><strong> float cam_mul[4]; </strong></dt>
+      <dd>White balance coefficients (as shot). Either read from file or
+        calculated.</dd>
+      <dt><strong> float pre_mul[4]; </strong></dt>
+      <dd>White balance coefficients for daylight (daylight balance). Either
+        read from file, or calculated on the basis of file data, or taken from
+        hardcoded constants.</dd>
+      <dt><strong> float cmatrix[3][4]; </strong></dt>
+      <dd>Camera color data read from RAW file (if any)</dd>
+      <dt><strong> float rgb_cam[3][4]; </strong></dt>
+      <dd>Camera to sRGB conversion matrix</dd>
+      <dt><strong> float ccm[3][4]; </strong></dt>
+      <dd>Camera color correction matrix readed from file metadata (uniform
+        matrix if no such data in file)</dd>
+      <dt><strong> ph1_t phase_one_data; </strong></dt>
+      <dd>Color data block that is read for Phase One cameras.</dd>
+      <dt><strong> float flash_used; </strong></dt>
+      <dt><strong> float canon_ev; </strong></dt>
+      <dd>Fields used for white balance calculations (for some P&amp;S Canon
+        cameras).</dd>
+      <dt><strong> char model2[64]; </strong></dt>
+      <dd>Firmware revision (for some cameras).</dd>
+      <dt><strong> char UniqueCameraModel[64],LocalizedCameraModel[64]; </strong></dt>
+      <dd>Values from DNG tags with same names.</dd>
+      <dt><strong> void *profile; </strong></dt>
+      <dd>Pointer to the retrieved ICC profile (if it is present in the RAW
+        file).</dd>
+      <dt><strong> unsigned profile_length; </strong></dt>
+      <dd>Length of ICC profile in bytes.</dd>
+      <dt><strong> unsigned black_stat[8]; </strong></dt>
+      <dd>Black level statistics if calcluated from masked area: 4 sum of pixel
+        values, than 4 pixel counts (per channel).</dd>
+      <dt><strong> libraw_dng_color_t dng_color[2]; </strong></dt>
+      <dd>Color data read from DNG: illuminant, calbiration matrix and color
+        matrix for two light sources. (see DNG specs for details).</dd>
+      <dt><strong>libraw_dng_levels_t dng_levels</strong></dt>
+      <dd>DNG black/white levels, analog balance, WB for active IFD. See DNG
+        specs for details.</dd>
+      <dt><strong>int WB_Coeffs[256][4]</strong></dt>
+      <dd>Index: EXIF color source value, [i][0..3] WB Coeffs</dd>
+      <dt><strong>float WBCT_Coeffs[64][5]</strong></dt>
+      <dd>Color temperature in [i][0], WB coeffs in [i][1..4]</dd>
+      <dt><strong>int as_shot_wb_applied</strong></dt>
+      <dd>Set to 1 if WB already applied in camera (multishot modes; small raw)</dd>
+      <dt><strong>libraw_P1_color_t P1_color[2]</strong></dt>
+      <dd>Phase-one specific color data</dd>
+      <dt><strong>unsigned raw_bps</strong></dt>
+      <dd>RAW bits per pixel (PhaseOne: Raw format used)</dd>
+      <dt><strong>int ExifColorSpace</strong></dt>
+      <dd>EXIF color space parsed from EXIF tags: LIBRAW_COLORSPACE_Unknown,
+        LIBRAW_COLORSPACE_sRGB, or LIBRAW_COLORSPACE_Adobe</dd>
+    </dl>
+    <p><a name="libraw_imgother_t"></a></p>
+    <h3>Structure libraw_imgother_t: Other Parameters of the Image</h3>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> float iso_speed; </strong></dt>
+      <dd>ISO sensitivity.</dd>
+      <dt><strong> float shutter; </strong></dt>
+      <dd>Shutter speed.</dd>
+      <dt><strong> float aperture; </strong></dt>
+      <dd>Aperture.</dd>
+      <dt><strong> float focal_len; </strong></dt>
+      <dd>Focal length.</dd>
+      <dt><strong> time_t timestamp; </strong></dt>
+      <dd>Date of shooting.</dd>
+      <dt><strong> unsigned shot_order; </strong></dt>
+      <dd>Serial number of image.</dd>
+      <dt><strong> unsigned gpsdata[32]; </strong></dt>
+      <dd>GPS data (unparsed block, to write to output as is).</dd>
+      <dt><strong> libraw_gps_info_t parsed_gps; </strong></dt>
+      <dd>Parsed GPS-data: longitude/latitude/altitude and time stamp.</dd>
+      <dt><strong> char desc[512]; </strong></dt>
+      <dd>Image description.</dd>
+      <dt><strong> char artist[64]; </strong></dt>
+      <dd>Author of image.</dd>
+      <dt><strong> float FlashEC; </strong></dt>
+      <dd>Flash exposure compensation.</dd>
+    </dl>
+    <p><a name="libraw_rawdata_t"></a></p>
+    <h3>Structure libraw_rawdata_t: holds unpacked RAW data</h3>
+    <p>Structure libraw_rawdata_t holds:</p>
+    <ul>
+      <li>RAW-data from sensor, readed and unpacked by the <a href="API-CXX.html#unpack">
+          unpack() </a> call.</li>
+      <li>"backup" copy of color and over data modified during postprocessing.
+        When postprocessing calls repeats, the needed data is restored from this
+        backup.</li>
+    </ul>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt>void *raw_alloc;</dt>
+      <dd>Buffer allocated to hold RAW-data</dd>
+      <dt><strong> unsigned short *raw_image; </strong></dt>
+      <dd>Pointer to buffer with one-component (bayer) data.</dd>
+      <dt><strong> unsigned short (*color3_image)[3]; </strong></dt>
+      <dd>Pointer to 3-component pixel array.</dd>
+      <dt><strong> unsigned short (*color4_image)[4]; </strong></dt>
+      <dd>Pointer to buffer with 4-component pixel data data</dd>
+      <dt><strong> float *float_image; </strong></dt>
+      <dd>Pointer to buffer with one-component (bayer) data in FP-format.</dd>
+      <dt><strong> float (*float3_image)[3]; </strong></dt>
+      <dd>Pointer to 3-component FP pixel array.</dd>
+      <dt><strong> float (*float4_image)[4]; </strong></dt>
+      <dd>Pointer to buffer with 4-component pixel data data</dd>
+    </dl>
+    <p>After call to <a href="API-CXX.html#unpack"> unpack() </a> only one of
+      these fields is non-NULL.</p>
+    <p>All other fields of this structure are for internal use and should not be
+      touched by user code. <a name="libraw_thumbnail_t"></a></p>
+    <h3>Structure libraw_thumbnail_t: Description of Thumbnail</h3>
+    <p>Structure libraw_thumbnail_t describes all parameters associated with the
+      preview saved in the RAW file. </p>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> LibRaw_thumbnail_formats tformat; </strong></dt>
+      <dd>Thumbnail data format. One of the values among enum <a href="#LibRaw_thumbnail_formats">
+          LibRaw_thumbnail_formats </a> .</dd>
+      <dt><strong> ushort twidth, theight; </strong></dt>
+      <dd>Dimensions of the preview image in pixels.</dd>
+      <dt><strong> unsigned tlength; </strong></dt>
+      <dd>Thumbnail length in bytes.</dd>
+      <dt><strong> int tcolors; </strong></dt>
+      <dd>Number of colors in the preview.</dd>
+      <dt><strong> char *thumb; </strong></dt>
+      <dd>Pointer to thumbmail, extracted from the data file.</dd>
+    </dl>
+    <p><a name="libraw_lensinfo_t"></a></p>
+    <h3>Structure libraw_lensinfo_t: parsed lens data</h3>
+    <p>The following parameters are extracted from Makernotes and EXIF, to help
+      identify which lens was mounted on the camera. If the value is missing in
+      Makernotes or EXIF, the parameter is set to zero with some exceptions
+      noted below. In some cases the values for the fields like CameraFormat and
+      CameraMount are set based on the camera model and/or camera ID.</p>
+    <h4>libraw_makernotes_lens_t structure:</h4>
+    <ul>
+      <li><strong>LensID</strong> (if not -1) and <strong>CamID</strong>
+        (camera id, if non-zero) values are compatible with those used in
+        exiftool, like |0x0010 CanonModelID| and |22 LensType| see <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Canon.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Canon.html</a>
+        or 0x0207/CameraType and 0x0201/LensType (see <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Olympus.htmlhttp://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Olympus.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Olympus.html</a>
+        )</li>
+      <li><strong>Lens</strong> string, if not empty, contains the lens name
+        present in Makernotes.</li>
+      <li><strong>LensFormat </strong>and <strong>CameraFormat</strong>
+        currently provide one of value from <strong>enum LibRaw_camera_formats</strong>;</li>
+      <li>In a similar manner, values for <strong>LensMount</strong> and <strong>CameraMount</strong>
+        follow the <strong>enum LibRaw_camera_mounts</strong>;</li>
+      <li>In some cases, the Makernotes for MF cameras contain either an id for
+        the body, or a string containing the name of the body. The name is
+        copied to <strong>body</strong> field, while the id is converted to the
+        appropriate body name and also copied to 'body' field. In other cases
+        the 'body' field is empty.</li>
+      <li><strong>FocalType</strong> is set based on Makernotes tag, if present.
+        The values are: </li>
+      <ul>
+        <li>-1 Undefined</li>
+        <li>0 Unknown;</li>
+        <li>1 Fixed focal length lens</li>
+        <li>2 Zoom lens</li>
+      </ul>
+      <li><strong>LensFeatures_pre</strong> - lens name prefix and <strong>LensFeatures_suf</strong>
+        - lens name suffix: (if not empty) some cameras record alphabet soup
+        that characterizes the lens in separate Makernote tags (see, for
+        example, 0xb02a LensSpec at&nbsp;<a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Sony.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Sony.html</a>
+        ), and for some lenses those acronyms can be derived from the 'Lens'
+        field itself (see processCanonCameraInfo). Those can also help better
+        lens identification.</li>
+      <li><strong>MinFocal</strong> and <strong>MaxFocal</strong> , if
+        non-zero, contain the minimum and maximum focal lengths for the lens
+        mounted on the camera.</li>
+      <li><strong>MaxAp4MinFocal</strong>, <strong>MaxAp4MaxFocal</strong>, <strong>MinAp4MinFocal</strong>,
+        <strong>MinAp4MaxFocal</strong> - if non-zero, contain maximum aperture
+        available at minimal focal length, maximum aperture available at maximum
+        focal length, minimum aperture available at minimal focal length,
+        minimum aperture available at maximum focal length, respectively.</li>
+      <li><strong>MaxAp</strong> and <strong>MinAp</strong>, if non-zero,
+        contain the maximum aperture for the lens (usually it is the maximum
+        aperture for minimal focal length) and the minimum aperture across the
+        focal length range. For zooms with variable maximum aperture this is
+        usually the minimum aperture for the maximum focal length.</li>
+      <li><strong>CurFocal</strong>, if non-zero, is current focal length - that
+        is the focal length used to take the shot.</li>
+      <li><strong>CurAp</strong>, if non-zero, is current aperture.</li>
+      <li><strong>MaxAp4CurFocal</strong> and <strong>MinAp4CurFocal</strong>,
+        if non-zero, contain the minimum and maximum apertures for the current
+        focal length.</li>
+      <li><strong>LensFStops</strong> - if non-zero, contains the number of
+        aperture "clicks" or the number of f-stops, depending on the model of
+        the camera.</li>
+      <li><strong>TeleconverterID</strong>, <strong>AdapterID</strong>, <strong>AttachmentID</strong>,
+        if non-zero, are the numbers extracted from Makernotes to identify lens
+        accessories used to take the shot.</li>
+      <li><strong>Teleconverter</strong>, <strong>Adapter</strong>, <strong>Attachment</strong>,
+        if non-empty, are the strings containing the names of the accessories as
+        they appear in Makernotes, or for some cameras, decoded from a numeric
+        field in Makernotes.</li>
+      <li><strong>FocalUnits</strong> - an auxiliary field, should not be needed
+        most of the cases. See Canon.pm module in exiftool for more information
+        on this value.</li>
+      <li><strong>FocalLengthIn35mmFormat</strong>, if non-zero: for some reason
+        certain Samsung cameras record this value in Makernotes instead of the
+        EXIF proper. Also used for Sigma cameras.</li>
+    </ul>
+    <h4>libraw_nikonlens_t structure:</h4>
+    <p>Contains additional parameters needed to identify the lens on a Nikon
+      camera using a table - please see Nikon LensID Values at <a href="http://www.sno.phy.queensu.ca/%7Ephil/exiftool/TagNames/Nikon.html">http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Nikon.html</a></p>
+    <h4>libraw_dnglens_t structure:</h4>
+    <p>Contains minimum focal length, maximum focal length, maximum aperture
+      available at minimal focal length, and maximum aperture available at
+      maximum focal length, extracted from EXIF field of a DNG raw file.</p>
+    <h4>libraw_lensinfo_t structure:</h4>
+    <p>Contains all the structures described above, plus parameters extracted
+      directly from EXIF fields:</p>
+    <ul>
+      <li><strong>MinFocal</strong> and <strong>MaxFocal</strong> , if
+        non-zero, contain the minimum and maximum focal lengths for the lens
+        mounted on the camera.</li>
+      <li><strong>MaxAp4MinFocal</strong>, <strong>MaxAp4MaxFocal</strong> - if
+        non-zero, contain maximum aperture available at minimal focal length and
+        maximum aperture available at maximum focal length</li>
+      <li><strong>LensMake</strong>, if not empty, contains a string with the
+        lens manufacturer name.</li>
+      <li><strong>Lens</strong>, if not empty, contains the lens name as
+        recorded in EXIF</li>
+      <li><strong>FocalLengthIn35mmFormat</strong> - if non-zero, same as
+        FocalLengthIn35mmFilm in EXIF standard, tag 0xa405.</li>
+      <li><strong>EXIF_MaxAp</strong> - if non-zero, contains the value derived
+        from EXIF tag 0x9205.</li>
+    </ul>
+    <p><a name="libraw_raw_unpack_params_t"></a></p>
+    <h3>Structure libraw_raw_unpack_params_t: RAW decoding options and flags</h3>
+    <p>Structure libraw_raw_unpack_params_t contains fields/flags that affects
+      RAWdata and metadata decoding</p>
+    <dl>
+      <dt><strong> int options </strong></dt>
+      <dd>Processing options used on unpack() phase for specific image formats,
+        see below for possible values:<a href="#LibRaw_processing_options">
+          LibRaw_processing_options</a></dd>
+      <dt><strong> unsigned shot_select; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -s <br>
+        Selection of image number for processing (for formats that contain
+        several RAW images in one file).</dd>
+      <dt><strong> int specials </strong></dt>
+      <dd>Special processing mode (e.g. omit YCC to RGB conversion), see below
+        for possible values. <a href="#LibRaw_rawspecial_t">
+          LibRaw_rawspecial_t</a></dd>
+      <dt><strong>int max_raw_memory_mb</strong></dt>
+      <dd>Stop processing if raw buffer size grows larger than that value (in
+        megabytes). Default is LIBRAW_MAX_ALLOC_MB_DEFAULT (2048Mb)</dd>
+      <dt><strong> int sony_arw2_posterization_thr </strong></dt>
+      <dd>If LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE used for
+        raw_processing_options, sets the level to suppress posterization display
+        in shadows.</dd>
+      <dt><strong> float coolscan_nef_gamma; </strong></dt>
+      <dd>Gamma value for Coolscan NEF decoding (no way to get if from file, it
+        should be set by calling application).</dd>
+      <dt><strong> char p4shot_order[5]; </strong></dt>
+      <dd>Shot order for Pentax 4shot files. Default is "3102".</dd>
+    </dl>
+    <h3></h3>
+    <h3>Structure libraw_output_params_t: management of dcraw-style
+      postprocessing</h3>
+    <p>Structure libraw_output_params_t (imgdata.params) is used for management
+      of dcraw-compatible calls dcraw_process(), dcraw_ppm_tiff_writer(), and
+      dcraw_thumb_writer(). Fields of this structure correspond to command line
+      keys of dcraw. </p>
+    <h4> Data fields:</h4>
+    <dl>
+      <dt><strong> unsigned greybox[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -A x y w h <br>
+        4 numbers corresponding to the coordinates (in pixels) of the rectangle
+        that is used to calculate the white balance. X and Y are coordinates of
+        the left-top rectangle corner; w and h are the rectangle's width and
+        height, respectively.</dd>
+      <dt><strong> unsigned cropbox[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        This field sets the image cropping rectangle. Cropbox[0] and cropbox[1]
+        are the rectangle's top-left corner coordinates, remaining two values
+        are width and height respectively. All coordinates are applied before
+        any image rotation.</dd>
+      <dt><strong> double aber[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -C <br>
+        Correction of chromatic aberrations; the only specified values are <br>
+        aber[0], the red multiplier <br>
+        aber[2], the blue multiplier. For some formats, it affects <a href="API-notes.html">
+          RAW data reading </a> , since correction of aberrations changes the
+        output size.</dd>
+      <dt><strong> double gamm[6]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -g power toe_slope <br>
+        Sets user gamma-curve. Library user should set first two fields of gamm
+        array: <br>
+        gamm[0] - <strong> inverted </strong> gamma value) <br>
+        gamm[1] - slope for linear part (so called toe slope). Set to zero for
+        simple power curve. <br>
+        Remaining 4 values are filled automatically.<br>
+        By default settings for rec. BT.709 are used: power 2.222 (i.e.
+        gamm[0]=1/2.222) and slope 4.5. For sRGB curve use gamm[0]=1/2.4 and
+        gamm[1]=12.92, for linear curve set gamm[0]/gamm[1] to 1.0. </dd>
+      <dt><strong> float user_mul[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -r mul0 mul1 mul2 mul3 <br>
+        4 multipliers (r,g,b,g) of the user's white balance.</dd>
+      <dt><strong>float bright; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -b <br>
+        Brightness (default 1.0).</dd>
+      <dt><strong> float threshold; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -n <br>
+        Parameter for noise reduction through wavelet denoising.</dd>
+      <dt><strong> int half_size; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -h <br>
+        Outputs the image in 50% size. For some formats, it affects <a href="API-notes.html">
+          RAW data reading </a> .</dd>
+      <dt><strong> int four_color_rgb; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -f <br>
+        Switches on separate interpolations for two green components.</dd>
+      <dt><strong> int highlight; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -H <br>
+        0-9: Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild).</dd>
+      <dt><strong> int use_auto_wb; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -a <br>
+        Use automatic white balance obtained after averaging over the entire
+        image.</dd>
+      <dt><strong> int use_camera_wb; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -w <br>
+        If possible, use the white balance from the camera.
+        <p> If camera-recorded WB is not available, dcraw_process() will
+          fallback to: </p>
+        <ul>
+          <li>Auto-WB if bit LIBRAW_PROCESSING_CAMERAWB_FALLBACK_TO_DAYLIGHT is
+            not set in params.raw_processing_options (or for the rare specific
+            case: no valid WB index was parsed from CRW file) </li>
+          <li>Daylight-WB if abovementioned bit is not set. </li>
+        </ul>
+      </dd>
+      <dt><strong> int use_camera_matrix; </strong></dt>
+      <dd><strong> dcraw keys: </strong> +M/-M <br>
+        <ul>
+          <li>0: do not use embedded color profile</li>
+          <li>1 (default): use embedded color profile (if present) for DNG files
+            (always); for other files only if use_camera_wb is set;</li>
+          <li>3: use embedded color data (if present) regardless of white
+            balance setting.</li>
+        </ul>
+      </dd>
+      <dt><strong> int output_color; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -o <br>
+        [0-8] Output colorspace (raw, sRGB, Adobe, Wide, ProPhoto, XYZ, ACES,
+        DCI-P3, Rec. 2020).</dd>
+      <dt><strong> char* output_profile; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -o filename <br>
+        Path to output profile ICC file (used only if LibRaw compiled with LCMS
+        support)</dd>
+      <dt><strong> char* camera_profile; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -p file <br>
+        Path to input (camera) profile ICC file (or 'embed' for embedded
+        profile). Used only if LCMS support compiled in.</dd>
+      <dt><strong> char* bad_pixels; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -P file <br>
+        Path to file with bad pixels map (in dcraw format: "column row
+        date-of-pixel-death-in-UNIX-format", one pixel per row).</dd>
+      <dt><strong> char* dark_frame; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -K file <br>
+        Path to dark frame file (in 16-bit PGM format)</dd>
+      <dt><strong> int output_bps; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -4 <br>
+        8 bit (default)/16 bit (key -4).</dd>
+      <dt><strong> int output_tiff; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -T <br>
+        0/1: output PPM/TIFF.</dd>
+      <dt><strong> int output_flags; </strong></dt>
+      <dd><strong> dcraw keys:</strong> none<br>
+        Bitfield that allows to set output file options:
+        <ul>
+          <li><strong>LIBRAW_OUTPUT_FLAGS_PPMMETA</strong> - write additional
+            metadata into PPM/PGM output files</li>
+        </ul>
+      </dd>
+      <dt><strong> int user_flip; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -t <br>
+        [0-7] Flip image (0=none, 3=180, 5=90CCW, 6=90CW). Default -1, which
+        means taking the corresponding value from RAW. <br>
+        For some formats, <a href="API-notes.html"> affects RAW data reading </a>
+        , e.g., unpacking of thumbnails from Kodak cameras.</dd>
+      <dt><strong> int user_qual; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -q <br>
+        0-10: interpolation quality:
+        <ul>
+          <li>0 - linear interpolation</li>
+          <li>1 - VNG interpolation</li>
+          <li>2 - PPG interpolation</li>
+          <li>3 - AHD interpolation</li>
+          <li>4 - DCB interpolation</li>
+          <li>11 - DHT intepolation</li>
+          <li>12 - Modified AHD intepolation (by Anton Petrusevich)</li>
+        </ul>
+      </dd>
+      <dt><strong> int user_black; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -k <br>
+        User black level.</dd>
+      <dt><strong> int user_cblack[4]; </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        Per-channel corrections to user_black.</dd>
+      <dt><strong> int user_sat; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -S <br>
+        Saturation adjustment.</dd>
+      <dt><strong> int med_passes; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -m <br>
+        Number of median filter passes.</dd>
+      <dt><strong> int no_auto_bright; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -W <br>
+        Don't use automatic increase of brightness by histogram.</dd>
+      <dt><strong> float auto_bright_thr; </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        Portion of clipped pixels when auto brighness increase is used. Default
+        value is 0.01 (1%) for dcraw compatibility. Recommended value for modern
+        low-noise multimegapixel cameras depends on shooting style. Values in
+        0.001-0.00003 range looks reasonable.</dd>
+      <dt><strong> float adjust_maximum_thr; </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        This parameters controls auto-adjusting of maximum value based on
+        channel_maximum[] data, calculated from real frame data. If calculated
+        maximum is greater than adjust_maximum_thr*maximum, than maximum is set
+        to calculated_maximum. <br>
+        Default: 0.75. If you set this value above 0.99999, than default value
+        will be used. If you set this value below 0.00001, than no maximum
+        adjustment will be performed. <br>
+        Adjusting maximum should not damage any picture (esp. if you use default
+        value) and is very useful for correcting channel overflow problems
+        (magenta clouds on landscape shots, green-blue highlights for indoor
+        shots).</dd>
+      <dt><strong> int use_fuji_rotate; </strong></dt>
+      <dd><strong> dcraw keys: </strong> -j <br>
+        Default -1 (use), 0 - don't use rotation for cameras on a Fuji sensor.</dd>
+      <dt><strong> int green_matching; </strong></dt>
+      <dd>Turns on fixing of green channels disbalance. <strong> dcraw keys: </strong>
+        none <br>
+        Default: 0 (not use), 1 - turns on this postprocessing stage.
+        green_matching requires additional memory for image data.</dd>
+      <dt><strong> int dcb_iterations </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        Number of DCB correction passes. Default is -1 (no correction). Useful
+        only for DCB interpolation.</dd>
+      <dt><strong> int dcb_enhance_fl </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        nonzero: DCB interpolation with enhance interpolated colors.</dd>
+      <dt><strong> int fbdd_noiserd </strong></dt>
+      <dd><strong> dcraw keys: </strong> none <br>
+        Controls FBDD noise reduction before demosaic.
+        <ul>
+          <li>0 - do not use FBDD noise reduction</li>
+          <li>1 - light FBDD reduction</li>
+          <li>2 (and more) - full FBDD reduction</li>
+        </ul>
+      </dd>
+      <dt><strong> int exp_correc; float exp_shift,exp_preser; </strong></dt>
+      <dd>Exposure correction before demosaic. <br>
+        <ul>
+          <li>exp_correc: positive value turns the feature on (default: off).</li>
+          <li>exp_shift: exposure shift in linear scale. Usable range from 0.25
+            (2-stop darken) to 8.0 (3-stop lighter). Default: 1.0 (no exposure
+            shift).</li>
+          <li>exp_preser: preserve highlights when lighten the image. Usable
+            range from 0.0 (no preservation) to 1.0 (full preservation). 0.0 is
+            the default value.</li>
+        </ul>
+      </dd>
+      <dt><strong> int use_rawspeed; </strong></dt>
+      <dd>Turns on using RawSpeed library for data unpacking (only if RawSpeed
+        support compiled in).</dd>
+      <dt><strong>int use_dng_sdk; </strong></dt>
+      <dd>Turns on using Adobe DNG SDK (if compiled with it and dng host is set:
+        <br>
+        <ul>
+          <li>0 - do not use</li>
+          <li>1 - use for speciality formats (Float, Linear DNG, deflate
+            compression, 8 bit)</li>
+          <li>2 - use for all DNG files</li>
+        </ul>
+      </dd>
+      <dt><strong> int no_auto_scale; </strong></dt>
+      <dd>Disables pixel values scaling (call to LibRaw::scale_colors()) in
+        LibRaw::dcraw_process().<br>
+        This is <strong>special use value</strong> because white balance is
+        performed in scale_colors(), so skipping it will result in non-balanced
+        image.<br>
+        This setting is targeted to use with no_interpolation, or with own
+        interpolation callback call.</dd>
+      <dt><strong> int no_interpolation; </strong></dt>
+      <dd>Disables call to demosaic code in LibRaw::dcraw_process()</dd>
+    </dl>
+    <p><a name="libraw_callbacks_t"></a></p>
+    <h3>Structure libraw_callbacks_t: user-settable callbacks</h3>
+    <dl>
+      <dt>memory_callback mem_cb</dt>
+      <dd>Called on memory allocation error. Settable via set_memerror_handler.
+        See <a href="API-CXX.html#callbacks">C++ API</a> for details.</dd>
+      <dt>data_callback data_cb</dt>
       <dd>Called on data error, settable via set_dataerror_handler. See <a href="API-CXX.html#callbacks">C++
-          API</a> for details.</dd>
-      <dt>progress_callback progress_cb</dt>
-      <dd>Called on process callback, settable via set_progress_handler. See <a
-          href="API-CXX.html#callbacks">C++ API</a> for details.</dd>
-      <dt>exif_parser_callback exif_cb, params: (void *context, int tag, int
-        type, int len, unsigned int ord, void *ifp)</dt>
-      <dd> Called by EXIF/TIFF IFD parsers on each processed tag.<br>
-        Parameters:
-        <ul>
-          <li>context: user-specified context, set via set_exifparser_handler()</li>
-          <li>tag: 16-bit of TIFF/EXIF tag or'ed with
-            <ul>
-              <li>0 - for EXIF parsing</li>
-              <li>0x20000 - for Kodak makernotes parsing</li>
-              <li>0x30000 - for Panasonic makernotes parsing</li>
-              <li>0x40000 - for EXIF Interop IFD parsing</li>
-              <li>0x50000 - for EXIF GPS IFD parsing</li>
-              <li>(ifdN + 1) &lt;&lt; 20) - for TIFF ifdN</li>
-            </ul>
-          </li>
-          <li>type: tag type (see TIFF/EXIF specs)</li>
-          <li>len: tag length</li>
-          <li>ord: byte order: 0x4949 for intel, 0x4d4d for motorola</li>
-          <li>ifp: pointer to LibRaw_abstract_datastream input stream,
-            positioned to start of data. There is no need to restore data
-            position in callback.</li>
-        </ul>
-      </dd>
-      <dt>int pre_identify_cb(void *)</dt>
-      <dd>Called with this pointer as the only arg before calling to
-        LibRaw::identify. If this callback return non-zero value, that means
-        that identify() is not needed and all internal data fields are filled
-        with values.</dd>
-      <dt>void post_identify_cb(void *)</dt>
-      <dd>Called after identify() from open_datastream(). May be used to tune
-        internal variables after metadata parse.</dd>
-      <dt>dcraw_process() callbacks</dt>
-      <dd>These callbacks are called before/after dcraw_process phases, the only
-        passed parameter is this pointer
-        <ul>
-          <li>pre_subtractblack_cb - called before black subtraction</li>
-          <li>pre_scalecolors_cb - called before scale_colors() call</li>
-          <li>pre_preinterpolate_cb - called before interpolaton (demosaic)</li>
-          <li>interpolate_bayer_cb - if set, called for bayer demosaic
-            (regardless of params.user_qual value)</li>
-          <li>interpolate_xtrans_cb - if set, called for X-Trans demosaic</li>
-          <li>post_interpolate_cb - called after demosaic step. Note: if this
-            callback is set, standard median_filter() is not called. So, if you
-            need median filtering you should call it from callback function.</li>
-          <li>pre_converttorgb_cb - called after convert_to_rgb()</li>
-          <li>post_converttorgb_cb - called after convert_to_rgb(), so very last
-            processing step.</li>
-        </ul>
-      </dd>
-    </dl>
-    <p><a name="libraw_decoder_info_t"></a></p>
-    <h3>Structure libraw_decoder_info_t: RAW decoder name and data format</h3>
-    <p>This structure describes RAW format decoder name and data format:</p>
-    <dl>
-      <dt>const char *decoder_name</dt>
-      <dd>Decoder function name</dd>
-      <dt>unsigned decoder_flags</dt>
-      <dd>Decoder data format. See <a href="#decoder_flags"> list of
-          LibRaw_decoder_flags </a> for details.</dd>
-    </dl>
-    <p><a name="libraw_processed_image_t"></a></p>
-    <h3>Structure libraw_processed_image_t - result set for
-      dcraw_make_mem_image()/dcraw_make_mem_thumb() functions</h3>
-    <p>Structure libraw_processed_image_t is produced by call of
-      dcraw_make_mem_image()/dcraw_make_mem_thumb() and contains in-memory image
-      of interpolated data or thumbnail. </p>
-    <h4>Data fields:</h4>
-    <dl>
-      <dt><strong> LibRaw_image_formats type </strong></dt>
-      <dd>This field records type of data, containing in remaining fields of
-        structure.
-        <ul>
-          <li><strong> LIBRAW_IMAGE_BITMAP </strong> - structure contains RGB
-            bitmap. All metadata fields (see below) are valid and describes
-            image data.</li>
-          <li><strong> LIBRAW_IMAGE_JPEG </strong> - structure contain
-            in-memory image of JPEG file. Only type, data_size and data fields
-            are valid (and nonzero);</li>
-        </ul>
-      </dd>
-      <dt><strong> ushort height,width </strong></dt>
-      <dd>Image size (in pixels). Valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
-      <dt><strong> ushort colors, bits </strong></dt>
-      <dd>Number of colors components (1 or 3) and color depth in bits (8 or
-        16). These fields are valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
-      <dt><strong> ushort gamma_corrected </strong></dt>
-      <dd>Is bitmap data gamma-corrected (always 1 for 8-bit data, may be 0 or 1
-        for 16-bit). Valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
-      <dt><strong> unsigned int data_size </strong></dt>
-      <dd>Size of <strong> data </strong> field (in bytes). For bitmap image
-        equal to (height*width*colors * (bits/8)). For JPEG image - exact JPEG
-        size (i.e. extracted thnumbnail size + JPEG header + EXIF header).</dd>
-      <dt><strong> unsigned char data[] </strong></dt>
-      <dd>Data array itself. Should be interpreted as RGB triplets for bitmap
-        type and as JPEG file for JPEG type.</dd>
-    </dl>
-    <p><a name="datastream"></a></p>
-    <h2>Input abstraction layer</h2>
-    <p>RAW data input (read) in LibRaw implemented by calling methods of object
-      derived from <strong> LibRaw_abstract_datastream </strong> abstract
-      class. Full list of methods is described in
-      href="API-CXX.html#datastream"&gt;C++ API reference.</p>
-    <p>There is two ready to use implementations of datastream objects:</p>
-    <ul>
-      <li><a href="API-CXX.html#file_datastream"> LibRaw_file_datastream </a> -
-        file input (filename provided to LibRaw).</li>
-      <li><a href="API-CXX.html#buffer_datastream"> LibRaw_buffer_datastream </a>
-        - input from memory buffer.</li>
-    </ul>
-    <p>LibRaw user can create own datastream object derived from <a href="API-CXX.html#datastream">
-        LibRaw_abstract_datastream </a> . For example, such object may
-      implement reading RAW data directly from camera (by remote interface).
-      LibRaw can use these objects via <a href="API-CXX.html#open_datastream">
-        LibRaw::open_datastream() </a> interface.</p>
-    <p>Datastreams can be used either via <a href="API-CXX.html#open_datastream">
-        LibRaw::open_datastream() </a> call (in this case datastream object
-      should be created an maintained by user) or via <a href="API-CXX.html#open_file">
-        LibRaw::open_file() </a> and <a href="API-CXX.html#open_buffer">
-        LibRaw::open_buffer() </a> shortcuts.</p>
-    <p>Only <a href="API-CXX.html"> C++ API </a> users may use object-oriented
-      interface and implement own input interfaces. For <a href="API-C.html"> C
-        API </a> users only built-on <strong>
-        libraw_open_file()/libraw_open_buffer() </strong> shortcuts are
-      available.</p>
-    <p><a name="datastream_data"></a></p>
-    <h4>Data fields</h4>
-    <p>Definition:</p>
-    <pre>	class LibRaw_abstract_datastream {...protected: LibRaw_abstract_datastream *substream;}
-</pre>
-    <p><strong> Description: </strong> Ojects derived from
-      LibRaw_abstract_datastream always contains pointer to secondary data
-      stream (substream). This substream initialized internally when needed
-      (really used only for Sony RAW data) and used for temporary switch input
-      stream to temporary memory buffer allocated internally in LibRaw.</p>
-    <p>Substream usage details described more precisely in <a href="API-CXX.html#own_datastreams">
-        own datastream objects creation guide </a> .</p>
-    <p><a name="const"></a></p>
-    <h2>Constants</h2>
-    <p><a name="LibRaw_errors"></a></p>
-    <h3>enum LibRaw_errors: Error Codes</h3>
-    <p>All functions returning integer numbers must return either errno or one
-      of the following error codes (see also <a href="API-notes.html#errors">
-        error code conventions </a> ).</p>
-    <p><strong> Fatal errors </strong> (return of such an error code implies
-      that file processing has to be terminated, since the state of data
-      structures is unknown).</p>
-    <dl>
-      <dt><strong> LIBRAW_UNSUFFICIENT_MEMORY </strong></dt>
-      <dd>Attempt to get memory from the system has failed. <br>
-        All allocated resources will be freed, <a href="API-CXX.html#recycle">
-          recycle() </a> will be called, and the LibRaw object will be brought
-        to the state "right after creation."</dd>
-      <dt><strong> LIBRAW_DATA_ERROR </strong></dt>
-      <dd>A fatal error emerged during data unpacking. <br>
-        All allocated resources will be freed, <a href="API-CXX.html#recycle">
-          recycle() </a> will be called, and the LibRaw object will be brought
-        to the state "right after creation."</dd>
-      <dt><strong> LIBRAW_IO_ERROR </strong></dt>
-      <dd>A fatal error emerged during file reading (premature end-of-file
-        encountered or file is corrupt). <br>
-        All allocated resources will be freed, <a href="API-CXX.html#recycle">
-          recycle() </a> will be called, and the LibRaw object will be brought
-        to the state "right after creation."</dd>
-      <dt><strong> LIBRAW_CANCELLED_BY_CALLBACK </strong></dt>
-      <dd>Processing cancelled due to calling application demand (by returning
-        nonzero code from <a href="API-CXX.html#progress"> progress callback </a>
-        ). <br>
-        All allocated resources will be freed, <a href="API-CXX.html#recycle">
-          recycle() </a> will be called, and the LibRaw object will be brought
-        to the state "right after creation."</dd>
-      <dt><strong> LIBRAW_BAD_CROP </strong></dt>
-      <dd>The incorrect cropping coordinates are set via params.cropbox[]: the
-        left-top corner of cropping rectangle is outside the image. The
-        processing will be cancelled, all allocated resources will be freed, <a
-          <dt=""><strong> LIBRAW_TOO_BIG</strong> </a></dd>
-      <dd><a <dt="">Raw data size exceeds data limit.</a></dd>
-      <a <dt=""> </a>
-    </dl>
-    <a <dt="">
-      <p><strong> Non-Fatal Errors </strong></p>
-    </a>
-    <dl>
-      <a <dt=""> <dt><strong> LIBRAW_SUCCESS=0 </strong></dt>
-        <dd>No error; function terminated successfully.</dd>
-        <dt><strong> LIBRAW_UNSPECIFIED_ERROR </strong></dt>
-        <dd>An unknown error has been encountered. This code should never be
-          generated.</dd>
-        <dt><strong> LIBRAW_FILE_UNSUPPORTED </strong></dt>
-        <dd>Unsupported file format (attempt to open a RAW file with a format
-          unknown to the program).</dd>
-        <dt><strong> LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE </strong></dt>
-        <dd>Attempt to retrieve a RAW image with a number absent in the data
-          file (only for formats supporting storage of several images in a
-          file).</dd>
-        <dt><strong> LIBRAW_OUT_OF_ORDER_CALL </strong></dt>
-      </a><dd><a <dt="">API functions have been called in wrong order (e.g., </a><a
-          href="API-CXX.html#unpack"> unpack() </a> before <a href="API-CXX.html#open_file">
-          open_file() </a> ) or the previous stage has ended with an error
-        (e.g., <a href="API-CXX.html#unpack"> unpack() </a> is called after <a
-          href="API-CXX.html#open_file"> open_file() </a> has returned an
-        error).</dd>
-      <dt><strong> LIBRAW_NO_THUMBNAIL </strong></dt>
-      <dd>Returned upon an attempt to retrieve a thumbnail from a file
-        containing no preview.</dd>
-      <dt><strong> LIBRAW_UNSUPPORTED_THUMBNAIL </strong></dt>
-      <dd>RAW file contains a preview of unsupported format.</dd>
-    </dl>
-    <p><a name="decoder_flags"></a></p>
-    <h3>enum LibRaw_decoder_flags - RAW data format description</h3>
-    <p>Depending of capabilities of given data format, the buffer with RAW data
-      may have different layouts:</p>
-    <dl>
-      <dt><strong> LIBRAW_DECODER_HASCURVE </strong></dt>
-      <dd>This flag is set if decoder uses RAW tone curve and curve data may be
-        modified before call to decoder (i.e. curve values are not read or
-        calculated within decoder).</dd>
-      <dt><strong> LIBRAW_DECODER_SONYARW2 </strong></dt>
-      <dd>This flag is set if file format is Sony ARW2.3, so sony_arw2_options
-        is applicable.</dd>
-      <dt><strong> LIBRAW_DECODER_TRYRAWSPEED </strong></dt>
-      <dd>This flag is set if file format is (possibly) supported by RawSpeed
-        library, so unpack() will try to use it.</dd>
-      <dt><strong> LIBRAW_DECODER_FIXEDMAXC </strong></dt>
-      <dd>Do not use automated maximum calculation for this data format.</dd>
-      <dt><strong> LIBRAW_DECODER_OWNALLOC </strong></dt>
-      <dd>Decoder allocates data, no need to pass allocated memory to decoder.</dd>
-      <dt><strong>LIBRAW_DECODER_ADOBECOPYPIXEL</strong></dt>
-      <dd>Internal flag, special to adobe DNG decoder.</dd>
-      <dt><strong>LIBRAW_DECODER_LEGACY_WITH_MARGINS</strong></dt>
-      <dd>Special flag uset for 4-channel (legacy) decoders with black/masked
-        areas</dd>
-      <dt><strong>LIBRAW_DECODER_3CHANNEL</strong></dt>
-      <dd>3-component full-color data (not usual 4-component)</dd>
-    </dl>
-    <p><a name="progress"></a></p>
-    <h3>enum LibRaw_progress: Current State of LibRaw Object</h3>
-    <p>LibRaw::imgdata.progress_flags contains a bit mask describing all stages
-      of file processing that have already been performed.</p>
-    <p><strong> File opening and RAW data extraction phase. </strong></p>
-    <dl>
-      <dt><strong> LIBRAW_PROGRESS_START=0 </strong></dt>
-      <dd>Object just created, no processing carried out.</dd>
-      <dt><strong> LIBRAW_PROGRESS_OPEN </strong></dt>
-      <dd>File to be processed has been opened.</dd>
-      <dt><strong> LIBRAW_PROGRESS_IDENTIFY </strong></dt>
-      <dd>Data identification performed, format recognized, metadata extracted.</dd>
-      <dt><strong> LIBRAW_PROGRESS_SIZE_ADJUST </strong></dt>
-      <dd>Data sizes adjusted (for files that require such adjustment, namely,
-        certain files from Kodak cameras).</dd>
-      <dt><strong> LIBRAW_PROGRESS_LOAD_RAW </strong></dt>
-      <dd>RAW data loaded.</dd>
-    </dl>
-    <p><strong> The following flags are set during usage of image processing
-        that has been taken from dcraw. </strong></p>
-    <dl>
-      <dt><strong> LIBRAW_PROGRESS_RAW2_IMAGE </strong></dt>
-      <dd>imgdata.image array allocated and filled with data.</dd>
-      <dt><strong> LIBRAW_PROGRESS_REMOVE_ZEROES </strong></dt>
-      <dd>Zero values removed for cameras that require such removal (Panasonic
-        cameras).</dd>
-      <dt><strong> LIBRAW_PROGRESS_BAD_PIXELS </strong></dt>
-      <dd>Bad (dead) pixels removed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_DARK_FRAME </strong></dt>
-      <dd>Dark frame subtracted from RAW data.</dd>
-      <dt><strong> LIBRAW_PROGRESS_FOVEON_INTERPOLATE </strong></dt>
-      <dd>Interpolation for cameras with a Foveon sensor performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_SCALE_COLORS </strong></dt>
-      <dd>White balance performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_PRE_INTERPOLATE </strong></dt>
-      <dd>Image size reduction (for the half_size mode) performed, as well as
-        copying of 2nd green channel to the 1st one in points where the second
-        channel is present and the first one is absent.</dd>
-      <dt><strong> LIBRAW_PROGRESS_INTERPOLATE </strong></dt>
-      <dd>Interpolation (debayer) performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_MIX_GREEN </strong></dt>
-      <dd>Averaging of green channels performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_MEDIAN_FILTER </strong></dt>
-      <dd>Median filtration performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_HIGHLIGHTS </strong></dt>
-      <dd>Work with highlights performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_FUJI_ROTATE </strong></dt>
-      <dd>For images from Fuji cameras, rotation performed (or
-        adjust_sizes_info_only() called).</dd>
-      <dt><strong> LIBRAW_PROGRESS_FLIP </strong></dt>
-      <dd>Dimensions recalculated for images shot with a rotated camera
-        (sizes.iwidth/sizes.iheight swapped).</dd>
-      <dt><strong> LIBRAW_PROGRESS_CONVERT_RGB </strong></dt>
-      <dd>Conversion into output RGB space performed.</dd>
-      <dt><strong> LIBRAW_PROGRESS_STRETCH </strong></dt>
-      <dd>Image dimensions changed for cameras with non-square pixels.</dd>
-      <dt><strong> LIBRAW_PROGRESS_STAGE17 - LIBRAW_PROGRESS_STAGE27 </strong></dt>
-      <dd>Reserved for possible appearance of other processing stages.</dd>
-    </dl>
-    <p><strong> The following flags are set during loading of thumbnails. </strong></p>
-    <p><strong> LIBRAW_PROGRESS_THUMB_LOAD </strong> Thumbnail data have been
-      loaded (for Kodak cameras, the necessary conversions have also been made).
-      <strong> LIBRAW_PROGRESS_TRESERVED1 - LIBRAW_PROGRESS_TRESERVED3 </strong>
-      Reserved for possible future processing stages.</p>
-    <p><a name="LibRaw_whitebalance_code"></a></p>
-    <h3>enum LibRaw_whitebalance_code - names for standard light sources</h3>
-    <p>LIBRAW_WBI_lightsource_name, where name and value are standard EXIF light
-      sources. <a name="LibRaw_runtime_capabilities"></a></p>
-    <h3>enum LibRaw_camera_mounts - codes for camera mounts</h3>
-    <p>Constant name (e.g. LIBRAW_MOUNT_Leica_SL) speaks for itself</p>
-    <h3>enum LibRaw_runtime_capabilities - libraw capabilities set at build</h3>
-    <ul>
-      <li><strong>LIBRAW_CAPS_RAWSPEED</strong> - compiled with RawSpeed</li>
-      <li><strong>LIBRAW_CAPS_DNGSDK </strong>- compiled with Adobe DNG SDK</li>
-      <li><strong>LIBRAW_CAPS_GPRSDK</strong> - compiled w/ GoPro GPR SDK</li>
-      <li><strong>LIBRAW_CAPS_UNICODEPATHS</strong> - compiled with Windows
-        unicode (wchar_t*) filenames support</li>
-    </ul>
-    <p><a name="LibRaw_thumbnail_formats"></a></p>
-    <h3>enum LibRaw_thumbnail_formats: Thumbnail Data Formats</h3>
-    <p>Thumbnail data format is written in the imgdata.thumbnail.tformat data
-      field. <br>
-      Presently LibRaw knows about four thumbnail formats, among which two are
-      unpacked:</p>
-    <dl>
-      <dt><strong> LIBRAW_THUMBNAIL_UNKNOWN </strong></dt>
-      <dd>Format unknown or thumbnail not yet read.</dd>
-      <dt><strong> LIBRAW_THUMBNAIL_JPEG </strong></dt>
-      <dd>The thumbnail buffer contains a JPEG file (read from the RAW file "as
-        is," without any manipulations performed on it).</dd>
-      <dt><strong> LIBRAW_THUMBNAIL_BITMAP </strong></dt>
-      <dd>The thumbnail buffer contains the gamma-adjusted RGB bitmap (for Kodak
-        cameras, the gamma correction is performed with allowance for maximum
-        values and the white balance is set in accordance with the camera
-        settings). <br>
-        In this format, each pixel of the image is represented by a 8-bit RGB
-        triplet.</dd>
-      <dt><strong>LIBRAW_THUMBNAIL_BITMAP16</strong></dt>
-      <dd>The thumbnail buffer contains the gamma-adjusted 16-bit RGB bitmap. To
+          API</a> for details.</dd>
+      <dt>progress_callback progress_cb</dt>
+      <dd>Called on process callback, settable via set_progress_handler. See <a
+
+          href="API-CXX.html#callbacks">C++ API</a> for details.</dd>
+      <dt>exif_parser_callback exif_cb, params: (void *context, int tag, int
+        type, int len, unsigned int ord, void *ifp)</dt>
+      <dd> Called by EXIF/TIFF IFD parsers on each processed tag.<br>
+        Parameters:
+        <ul>
+          <li>context: user-specified context, set via set_exifparser_handler()</li>
+          <li>tag: 16-bit of TIFF/EXIF tag or'ed with
+            <ul>
+              <li>0 - for EXIF parsing</li>
+              <li>0x20000 - for Kodak makernotes parsing</li>
+              <li>0x30000 - for Panasonic makernotes parsing</li>
+              <li>0x40000 - for EXIF Interop IFD parsing</li>
+              <li>0x50000 - for EXIF GPS IFD parsing</li>
+              <li>(ifdN + 1) &lt;&lt; 20) - for TIFF ifdN</li>
+            </ul>
+          </li>
+          <li>type: tag type (see TIFF/EXIF specs)</li>
+          <li>len: tag length</li>
+          <li>ord: byte order: 0x4949 for intel, 0x4d4d for motorola</li>
+          <li>ifp: pointer to LibRaw_abstract_datastream input stream,
+            positioned to start of data. There is no need to restore data
+            position in callback.</li>
+        </ul>
+      </dd>
+      <dt>int pre_identify_cb(void *)</dt>
+      <dd>Called with this pointer as the only arg before calling to
+        LibRaw::identify. If this callback return non-zero value, that means
+        that identify() is not needed and all internal data fields are filled
+        with values.</dd>
+      <dt>void post_identify_cb(void *)</dt>
+      <dd>Called after identify() from open_datastream(). May be used to tune
+        internal variables after metadata parse.</dd>
+      <dt>dcraw_process() callbacks</dt>
+      <dd>These callbacks are called before/after dcraw_process phases, the only
+        passed parameter is this pointer
+        <ul>
+          <li>pre_subtractblack_cb - called before black subtraction</li>
+          <li>pre_scalecolors_cb - called before scale_colors() call</li>
+          <li>pre_preinterpolate_cb - called before interpolaton (demosaic)</li>
+          <li>interpolate_bayer_cb - if set, called for bayer demosaic
+            (regardless of params.user_qual value)</li>
+          <li>interpolate_xtrans_cb - if set, called for X-Trans demosaic</li>
+          <li>post_interpolate_cb - called after demosaic step. Note: if this
+            callback is set, standard median_filter() is not called. So, if you
+            need median filtering you should call it from callback function.</li>
+          <li>pre_converttorgb_cb - called after convert_to_rgb()</li>
+          <li>post_converttorgb_cb - called after convert_to_rgb(), so very last
+            processing step.</li>
+        </ul>
+      </dd>
+    </dl>
+    <p><a name="libraw_decoder_info_t"></a></p>
+    <h3>Structure libraw_decoder_info_t: RAW decoder name and data format</h3>
+    <p>This structure describes RAW format decoder name and data format:</p>
+    <dl>
+      <dt>const char *decoder_name</dt>
+      <dd>Decoder function name</dd>
+      <dt>unsigned decoder_flags</dt>
+      <dd>Decoder data format. See <a href="#decoder_flags"> list of
+          LibRaw_decoder_flags </a> for details.</dd>
+    </dl>
+    <p><a name="libraw_processed_image_t"></a></p>
+    <h3>Structure libraw_processed_image_t - result set for
+      dcraw_make_mem_image()/dcraw_make_mem_thumb() functions</h3>
+    <p>Structure libraw_processed_image_t is produced by call of
+      dcraw_make_mem_image()/dcraw_make_mem_thumb() and contains in-memory image
+      of interpolated data or thumbnail. </p>
+    <h4>Data fields:</h4>
+    <dl>
+      <dt><strong> LibRaw_image_formats type </strong></dt>
+      <dd>This field records type of data, containing in remaining fields of
+        structure.
+        <ul>
+          <li><strong> LIBRAW_IMAGE_BITMAP </strong> - structure contains RGB
+            bitmap. All metadata fields (see below) are valid and describes
+            image data.</li>
+          <li><strong> LIBRAW_IMAGE_JPEG </strong> - structure contain
+            in-memory image of JPEG file. Only type, data_size and data fields
+            are valid (and nonzero);</li>
+        </ul>
+      </dd>
+      <dt><strong> ushort height,width </strong></dt>
+      <dd>Image size (in pixels). Valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
+      <dt><strong> ushort colors, bits </strong></dt>
+      <dd>Number of colors components (1 or 3) and color depth in bits (8 or
+        16). These fields are valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
+      <dt><strong> ushort gamma_corrected </strong></dt>
+      <dd>Is bitmap data gamma-corrected (always 1 for 8-bit data, may be 0 or 1
+        for 16-bit). Valid only if type==LIBRAW_IMAGE_BITMAP.</dd>
+      <dt><strong> unsigned int data_size </strong></dt>
+      <dd>Size of <strong> data </strong> field (in bytes). For bitmap image
+        equal to (height*width*colors * (bits/8)). For JPEG image - exact JPEG
+        size (i.e. extracted thnumbnail size + JPEG header + EXIF header).</dd>
+      <dt><strong> unsigned char data[] </strong></dt>
+      <dd>Data array itself. Should be interpreted as RGB triplets for bitmap
+        type and as JPEG file for JPEG type.</dd>
+    </dl>
+    <p><a name="datastream"></a></p>
+    <h2>Input abstraction layer</h2>
+    <p>RAW data input (read) in LibRaw implemented by calling methods of object
+      derived from <strong> LibRaw_abstract_datastream </strong> abstract
+      class. Full list of methods is described in
+      href="API-CXX.html#datastream"&gt;C++ API reference.</p>
+    <p>There is two ready to use implementations of datastream objects:</p>
+    <ul>
+      <li><a href="API-CXX.html#file_datastream"> LibRaw_file_datastream </a> -
+        file input (filename provided to LibRaw).</li>
+      <li><a href="API-CXX.html#buffer_datastream"> LibRaw_buffer_datastream </a>
+        - input from memory buffer.</li>
+    </ul>
+    <p>LibRaw user can create own datastream object derived from <a href="API-CXX.html#datastream">
+        LibRaw_abstract_datastream </a> . For example, such object may
+      implement reading RAW data directly from camera (by remote interface).
+      LibRaw can use these objects via <a href="API-CXX.html#open_datastream">
+        LibRaw::open_datastream() </a> interface.</p>
+    <p>Datastreams can be used either via <a href="API-CXX.html#open_datastream">
+        LibRaw::open_datastream() </a> call (in this case datastream object
+      should be created an maintained by user) or via <a href="API-CXX.html#open_file">
+        LibRaw::open_file() </a> and <a href="API-CXX.html#open_buffer">
+        LibRaw::open_buffer() </a> shortcuts.</p>
+    <p>Only <a href="API-CXX.html"> C++ API </a> users may use object-oriented
+      interface and implement own input interfaces. For <a href="API-C.html"> C
+        API </a> users only built-on <strong>
+        libraw_open_file()/libraw_open_buffer() </strong> shortcuts are
+      available.</p>
+    <p><a name="datastream_data"></a></p>
+    <h4>Data fields</h4>
+    <p>Definition:</p>
+    <pre>	class LibRaw_abstract_datastream {...protected: LibRaw_abstract_datastream *substream;}
+</pre>
+    <p><strong> Description: </strong> Ojects derived from
+      LibRaw_abstract_datastream always contains pointer to secondary data
+      stream (substream). This substream initialized internally when needed
+      (really used only for Sony RAW data) and used for temporary switch input
+      stream to temporary memory buffer allocated internally in LibRaw.</p>
+    <p>Substream usage details described more precisely in <a href="API-CXX.html#own_datastreams">
+        own datastream objects creation guide </a> .</p>
+    <p><a name="const"></a></p>
+    <h2>Constants</h2>
+    <p><a name="LibRaw_errors"></a></p>
+    <h3>enum LibRaw_errors: Error Codes</h3>
+    <p>All functions returning integer numbers must return either errno or one
+      of the following error codes (see also <a href="API-notes.html#errors">
+        error code conventions </a> ).</p>
+    <p><strong> Fatal errors </strong> (return of such an error code implies
+      that file processing has to be terminated, since the state of data
+      structures is unknown).</p>
+    <dl>
+      <dt><strong> LIBRAW_UNSUFFICIENT_MEMORY </strong></dt>
+      <dd>Attempt to get memory from the system has failed. <br>
+        All allocated resources will be freed, <a href="API-CXX.html#recycle">
+          recycle() </a> will be called, and the LibRaw object will be brought
+        to the state "right after creation."</dd>
+      <dt><strong> LIBRAW_DATA_ERROR </strong></dt>
+      <dd>A fatal error emerged during data unpacking. <br>
+        All allocated resources will be freed, <a href="API-CXX.html#recycle">
+          recycle() </a> will be called, and the LibRaw object will be brought
+        to the state "right after creation."</dd>
+      <dt><strong> LIBRAW_IO_ERROR </strong></dt>
+      <dd>A fatal error emerged during file reading (premature end-of-file
+        encountered or file is corrupt). <br>
+        All allocated resources will be freed, <a href="API-CXX.html#recycle">
+          recycle() </a> will be called, and the LibRaw object will be brought
+        to the state "right after creation."</dd>
+      <dt><strong> LIBRAW_CANCELLED_BY_CALLBACK </strong></dt>
+      <dd>Processing cancelled due to calling application demand (by returning
+        nonzero code from <a href="API-CXX.html#progress"> progress callback </a>
+        ). <br>
+        All allocated resources will be freed, <a href="API-CXX.html#recycle">
+          recycle() </a> will be called, and the LibRaw object will be brought
+        to the state "right after creation."</dd>
+      <dt><strong> LIBRAW_BAD_CROP </strong></dt>
+      <dd>The incorrect cropping coordinates are set via params.cropbox[]: the
+        left-top corner of cropping rectangle is outside the image. The
+        processing will be cancelled, all allocated resources will be freed, <a
+
+          <dt=""><strong> LIBRAW_TOO_BIG</strong> </a></dd>
+      <dd><a <dt="">Raw data size exceeds data limit.</a></dd>
+      <a <dt=""> </a>
+    </dl>
+    <a <dt="">
+      <p><strong> Non-Fatal Errors </strong></p>
+    </a>
+    <dl>
+      <a <dt=""> <dt><strong> LIBRAW_SUCCESS=0 </strong></dt>
+        <dd>No error; function terminated successfully.</dd>
+        <dt><strong> LIBRAW_UNSPECIFIED_ERROR </strong></dt>
+        <dd>An unknown error has been encountered. This code should never be
+          generated.</dd>
+        <dt><strong> LIBRAW_FILE_UNSUPPORTED </strong></dt>
+        <dd>Unsupported file format (attempt to open a RAW file with a format
+          unknown to the program).</dd>
+        <dt><strong> LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE </strong></dt>
+        <dd>Attempt to retrieve a RAW image with a number absent in the data
+          file (only for formats supporting storage of several images in a
+          file).</dd>
+        <dt><strong> LIBRAW_OUT_OF_ORDER_CALL </strong></dt>
+      </a><dd><a <dt="">API functions have been called in wrong order (e.g., </a><a
+
+          href="API-CXX.html#unpack"> unpack() </a> before <a href="API-CXX.html#open_file">
+          open_file() </a> ) or the previous stage has ended with an error
+        (e.g., <a href="API-CXX.html#unpack"> unpack() </a> is called after <a
+
+          href="API-CXX.html#open_file"> open_file() </a> has returned an
+        error).</dd>
+      <dt><strong> LIBRAW_NO_THUMBNAIL </strong></dt>
+      <dd>Returned upon an attempt to retrieve a thumbnail from a file
+        containing no preview.</dd>
+      <dt><strong> LIBRAW_UNSUPPORTED_THUMBNAIL </strong></dt>
+      <dd>RAW file contains a preview of unsupported format.</dd>
+    </dl>
+    <p><a name="decoder_flags"></a></p>
+    <h3>enum LibRaw_decoder_flags - RAW data format description</h3>
+    <p>Depending of capabilities of given data format, the buffer with RAW data
+      may have different layouts:</p>
+    <dl>
+      <dt><strong> LIBRAW_DECODER_HASCURVE </strong></dt>
+      <dd>This flag is set if decoder uses RAW tone curve and curve data may be
+        modified before call to decoder (i.e. curve values are not read or
+        calculated within decoder).</dd>
+      <dt><strong> LIBRAW_DECODER_SONYARW2 </strong></dt>
+      <dd>This flag is set if file format is Sony ARW2.3, so sony_arw2_options
+        is applicable.</dd>
+      <dt><strong> LIBRAW_DECODER_TRYRAWSPEED </strong></dt>
+      <dd>This flag is set if file format is (possibly) supported by RawSpeed
+        library, so unpack() will try to use it.</dd>
+      <dt><strong> LIBRAW_DECODER_FIXEDMAXC </strong></dt>
+      <dd>Do not use automated maximum calculation for this data format.</dd>
+      <dt><strong> LIBRAW_DECODER_OWNALLOC </strong></dt>
+      <dd>Decoder allocates data, no need to pass allocated memory to decoder.</dd>
+      <dt><strong>LIBRAW_DECODER_ADOBECOPYPIXEL</strong></dt>
+      <dd>Internal flag, special to adobe DNG decoder.</dd>
+      <dt><strong>LIBRAW_DECODER_LEGACY_WITH_MARGINS</strong></dt>
+      <dd>Special flag uset for 4-channel (legacy) decoders with black/masked
+        areas</dd>
+      <dt><strong>LIBRAW_DECODER_3CHANNEL</strong></dt>
+      <dd>3-component full-color data (not usual 4-component)</dd>
+    </dl>
+    <p><a name="progress"></a></p>
+    <h3>enum LibRaw_progress: Current State of LibRaw Object</h3>
+    <p>LibRaw::imgdata.progress_flags contains a bit mask describing all stages
+      of file processing that have already been performed.</p>
+    <p><strong> File opening and RAW data extraction phase. </strong></p>
+    <dl>
+      <dt><strong> LIBRAW_PROGRESS_START=0 </strong></dt>
+      <dd>Object just created, no processing carried out.</dd>
+      <dt><strong> LIBRAW_PROGRESS_OPEN </strong></dt>
+      <dd>File to be processed has been opened.</dd>
+      <dt><strong> LIBRAW_PROGRESS_IDENTIFY </strong></dt>
+      <dd>Data identification performed, format recognized, metadata extracted.</dd>
+      <dt><strong> LIBRAW_PROGRESS_SIZE_ADJUST </strong></dt>
+      <dd>Data sizes adjusted (for files that require such adjustment, namely,
+        certain files from Kodak cameras).</dd>
+      <dt><strong> LIBRAW_PROGRESS_LOAD_RAW </strong></dt>
+      <dd>RAW data loaded.</dd>
+    </dl>
+    <p><strong> The following flags are set during usage of image processing
+        that has been taken from dcraw. </strong></p>
+    <dl>
+      <dt><strong> LIBRAW_PROGRESS_RAW2_IMAGE </strong></dt>
+      <dd>imgdata.image array allocated and filled with data.</dd>
+      <dt><strong> LIBRAW_PROGRESS_REMOVE_ZEROES </strong></dt>
+      <dd>Zero values removed for cameras that require such removal (Panasonic
+        cameras).</dd>
+      <dt><strong> LIBRAW_PROGRESS_BAD_PIXELS </strong></dt>
+      <dd>Bad (dead) pixels removed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_DARK_FRAME </strong></dt>
+      <dd>Dark frame subtracted from RAW data.</dd>
+      <dt><strong> LIBRAW_PROGRESS_FOVEON_INTERPOLATE </strong></dt>
+      <dd>Interpolation for cameras with a Foveon sensor performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_SCALE_COLORS </strong></dt>
+      <dd>White balance performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_PRE_INTERPOLATE </strong></dt>
+      <dd>Image size reduction (for the half_size mode) performed, as well as
+        copying of 2nd green channel to the 1st one in points where the second
+        channel is present and the first one is absent.</dd>
+      <dt><strong> LIBRAW_PROGRESS_INTERPOLATE </strong></dt>
+      <dd>Interpolation (debayer) performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_MIX_GREEN </strong></dt>
+      <dd>Averaging of green channels performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_MEDIAN_FILTER </strong></dt>
+      <dd>Median filtration performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_HIGHLIGHTS </strong></dt>
+      <dd>Work with highlights performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_FUJI_ROTATE </strong></dt>
+      <dd>For images from Fuji cameras, rotation performed (or
+        adjust_sizes_info_only() called).</dd>
+      <dt><strong> LIBRAW_PROGRESS_FLIP </strong></dt>
+      <dd>Dimensions recalculated for images shot with a rotated camera
+        (sizes.iwidth/sizes.iheight swapped).</dd>
+      <dt><strong> LIBRAW_PROGRESS_CONVERT_RGB </strong></dt>
+      <dd>Conversion into output RGB space performed.</dd>
+      <dt><strong> LIBRAW_PROGRESS_STRETCH </strong></dt>
+      <dd>Image dimensions changed for cameras with non-square pixels.</dd>
+      <dt><strong> LIBRAW_PROGRESS_STAGE17 - LIBRAW_PROGRESS_STAGE27 </strong></dt>
+      <dd>Reserved for possible appearance of other processing stages.</dd>
+    </dl>
+    <p><strong> The following flags are set during loading of thumbnails. </strong></p>
+    <p><strong> LIBRAW_PROGRESS_THUMB_LOAD </strong> Thumbnail data have been
+      loaded (for Kodak cameras, the necessary conversions have also been made).
+      <strong> LIBRAW_PROGRESS_TRESERVED1 - LIBRAW_PROGRESS_TRESERVED3 </strong>
+      Reserved for possible future processing stages.</p>
+    <p><a name="LibRaw_whitebalance_code"></a></p>
+    <h3>enum LibRaw_whitebalance_code - names for standard light sources</h3>
+    <p>LIBRAW_WBI_lightsource_name, where name and value are standard EXIF light
+      sources. <a name="LibRaw_runtime_capabilities"></a></p>
+    <h3>enum LibRaw_camera_mounts - codes for camera mounts</h3>
+    <p>Constant name (e.g. LIBRAW_MOUNT_Leica_SL) speaks for itself</p>
+    <h3>enum LibRaw_runtime_capabilities - libraw capabilities set at build</h3>
+    <ul>
+      <li><strong>LIBRAW_CAPS_RAWSPEED</strong> - compiled with RawSpeed</li>
+      <li><strong>LIBRAW_CAPS_DNGSDK </strong>- compiled with Adobe DNG SDK</li>
+      <li><strong>LIBRAW_CAPS_GPRSDK</strong> - compiled w/ GoPro GPR SDK</li>
+      <li><strong>LIBRAW_CAPS_UNICODEPATHS</strong> - compiled with Windows
+        unicode (wchar_t*) filenames support</li>
+    </ul>
+    <p><a name="LibRaw_thumbnail_formats"></a></p>
+    <h3>enum LibRaw_thumbnail_formats: Thumbnail Data Formats</h3>
+    <p>Thumbnail data format is written in the imgdata.thumbnail.tformat data
+      field. <br>
+      Presently LibRaw knows about four thumbnail formats, among which two are
+      unpacked:</p>
+    <dl>
+      <dt><strong> LIBRAW_THUMBNAIL_UNKNOWN </strong></dt>
+      <dd>Format unknown or thumbnail not yet read.</dd>
+      <dt><strong> LIBRAW_THUMBNAIL_JPEG </strong></dt>
+      <dd>The thumbnail buffer contains a JPEG file (read from the RAW file "as
+        is," without any manipulations performed on it).</dd>
+      <dt><strong> LIBRAW_THUMBNAIL_BITMAP </strong></dt>
+      <dd>The thumbnail buffer contains the gamma-adjusted RGB bitmap (for Kodak
+        cameras, the gamma correction is performed with allowance for maximum
+        values and the white balance is set in accordance with the camera
+        settings). <br>
+        In this format, each pixel of the image is represented by a 8-bit RGB
+        triplet.</dd>
+      <dt><strong>LIBRAW_THUMBNAIL_BITMAP16</strong></dt>
+      <dd>The thumbnail buffer contains the gamma-adjusted 16-bit RGB bitmap. To
         get this format instead of <strong> LIBRAW_THUMBNAIL_BITMAP </strong>you
-        need to set <strong>LIBRAW_PROCESSING_USE_PPM16_THUMBS</strong> in
-        processing options.</dd>
-      <dt><strong> LIBRAW_THUMBNAIL_LAYER </strong></dt>
-      <dd>Data format is presently recognized upon opening of RAW file but not
-        supported: not unpacked into LibRaw::unpack_thumb.</dd>
-      <dt><strong> LIBRAW_THUMBNAIL_ROLLEI </strong></dt>
-      <dd>Data format is presently recognized upon opening of RAW file but not
-        supported: not unpacked into LibRaw::unpack_thumb.</dd>
-    </dl>
-    <p><a name="warnings"></a></p>
-    <h3>Nonstandard Situations (Warnings) during RAW Data Processing</h3>
-    <p>Some suspicious situations emerging during image processing are not fatal
-      but may affect the result of data retrieval or postprocessing. Such states
-      are indicated by setting a bit in the imgdata.process_warnings field.</p>
-    <dl>
-      <dt><strong> LIBRAW_WARN_BAD_CAMERA_WB </strong></dt>
-      <dd>Postprocessing must use white balance of the camera but this balance
-        is not suitable for use.</dd>
-      <dt><strong> LIBRAW_WARN_NO_METADATA </strong></dt>
-      <dd>Only for cameras where the metadata are taken from an external JPEG
-        file: metadata extraction has failed.</dd>
-      <dt><strong> LIBRAW_WARN_NO_JPEGLIB </strong></dt>
-      <dd>Only for P&amp;S Kodak cameras: data in JPEG format. At the same time,
-        open_file() will return LIBRAW_FILE_UNSUPPORTED.</dd>
-      <dt><strong> LIBRAW_WARN_NO_EMBEDDED_PROFILE </strong></dt>
-      <dd>(only if LCMS support compiled in). Caller set embedded input profile
-        use, but no such profile exists in RAW.</dd>
-      <dt><strong> LIBRAW_WARN_NO_INPUT_PROFILE </strong></dt>
-      <dd>(only if LCMS support compiled in). Error when opening input profile
-        ICC file.</dd>
-      <dt><strong> LIBRAW_WARN_BAD_OUTPUT_PROFILE </strong></dt>
-      <dd>(only if LCMS support compiled in). Error when opening output profile
-        ICC file.</dd>
-      <dt><strong> LIBRAW_WARN_NO_BADPIXELMAP </strong></dt>
-      <dd>Error when opening bad pixels map file.</dd>
-      <dt><strong> LIBRAW_WARN_BAD_DARKFRAME_FILE </strong></dt>
-      <dd>Error when opening dark frame file.</dd>
-      <dt><strong> LIBRAW_WARN_BAD_DARKFRAME_DIM </strong></dt>
-      <dd>Dark frame file either differs in dimensions from RAW-file processed,
-        or have wrong format. Dark frame should be in 16-bit PGM format (one can
-        generate it using simple_dcraw -4 -D).</dd>
-      <dt><strong> LIBRAW_WARN_RAWSPEED_PROBLEM </strong></dt>
-      <dd>Problems detected in RawSpeed decompressor. The image data processed
-        by LibRaw own decoder.</dd>
-      <dt><strong> LIBRAW_WARN_RAWSPEED_UNSUPPORTED </strong></dt>
-      <dd>This file not supported by RawSpeed (although compatible decoder
-        exists).</dd>
-      <dt><strong> LIBRAW_WARN_RAWSPEED_PROCESSED </strong></dt>
-      <dd>Not warning, but information. The file was decoded by RawSpeed.</dd>
-      <dt><strong> LIBRAW_WARN_FALLBACK_TO_AHD </strong></dt>
-      <dd>Incorrect/unsupported user_qual was set, AHD demosaic used instead.</dd>
-      <dt><strong> LIBRAW_WARN_PARSEFUJI_PROCESSED</strong></dt>
-      <dd>Not really a warning, but flag that fuji parser was used.</dd>
-      <dt><strong>LIBRAW_DNGSDK_PROCESSED</strong></dt>
-      <dd>Not really a warning: image was decoded by DNG SDK</dd>
-      <dt><strong> LIBRAW_DNG_IMAGES_REORDERED</strong></dt>
-      <dd>DNG sub0images was reordered </dd>
-      <dt><strong>LIBRAW_DNG_STAGE2_APPLIED</strong></dt>
-      <dd>DNG Stage2 conversion was performed</dd>
-      <dt><strong> LIBRAW_DNG_STAGE3_APPLIED</strong></dt>
-      <dd>DNG Stage3 conversion was performed</dd>
-    </dl>
-    <dl>
-    </dl>
-    <p><a name="LibRaw_image_formats"></a></p>
-    <h3>enum LibRaw_image_formats - possible types of data, contains in
-      libraw_processed_image_t structure</h3>
-    <p><strong> type </strong> field of libraw_processed_image_t structure may
-      have one of these values:</p>
-    <dl>
-      <dt><strong> LIBRAW_IMAGE_BITMAP </strong></dt>
-      <dd>The structure contains RGB-bitmap, metadata described in other fields
-        of libraw_processed_image_t.</dd>
-      <dt><strong> LIBRAW_IMAGE_JPEG </strong></dt>
-      <dd>libraw_processed_image_t structure contains JPEG image (in memory).
-        Only data_size field is meaningful.</dd>
-    </dl>
-    <p> <a name="LibRaw_processing_options"></a></p>
-    <h3> enum enum LibRaw_processing_options - bit that affects RAW data
-      extraction</h3>
-    These flags could be OR'ed with imgdata.params.raw_processing_options:
-    <p>Pentax 4-shot options:</p>
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_PENTAX_PS_ALLFRAMES</b> - merge all frames for
-        Pentax 4-shot files</li>
-    </ul>
-    <p>Floating point DNG files:</p>
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT</b> - convert FP data to
-        16-bit integer</li>
-    </ul>
-    <p>Sony ARQ Files:</p>
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_ARQ_SKIP_CHANNEL_SWAP</b> - do not perform Sony
-        ARQ channel swap to RGBG channel format, but use RGGB original channel
-        order</li>
-    </ul>
-    <p>DNG processing flags:</p>
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP</b> - use DNG DefaultCrop*
-        tags for cropping</li>
-      <li><b>LIBRAW_RAWOPTIONS_DONT_CHECK_DNG_ILLUMINANT</b> - skip DNG
-        illuminant check when parsing DNG color data (use for compatibility w/
-        older LibRaw versions).</li>
-      <li><b>LIBRAW_RAWOPTIONS_DNGSDK_ZEROCOPY</b> - do not copy data extracted
-        by Adobe DNG SDK into separate buffer, but use DNG SDK buffer as is.</li>
-      <li><b>LIBRAW_RAWOPTIONS_DNG_ADD_ENHANCED</b> - if set, LibRaw will add
-        Enhanced DNG frame (NewSubfileType == 16) to the list of available
-        frames.</li>
-      <li><b>LIBRAW_RAWOPTIONS_DNG_ADD_PREVIEWS</b> - if set, LibRaw will add
-        previews (NewSubfileType == 1) to the frames list.</li>
-      <li><b>LIBRAW_RAWOPTIONS_DNG_PREFER_LARGEST_IMAGE</b>- By default, DNG
-        frames are not reordered and are available in same order as in DNG&nbsp;
-        (LibRaw traverses IFD/Sub-IFD trees in deep-first order).This bit will
-        prioritize the largest image</li>
-      <li><strong>LIBRAW_RAWOPTIONS_DNG_STAGE2</strong> - request DNG Stage2
-        processing (by DNG SDK)</li>
-      <li><strong>LIBRAW_RAWOPTIONS_DNG_STAGE3</strong> - request DNG Stage3
-        processing</li>
-      <li><strong>LIBRAW_RAWOPTIONS_DNG_ALLOWSIZECHANGE</strong> - by default,
-        if image size parsed by DNG SDK does not match image dimensions parsed
-        by LibRaw, processing will stop with LIBRAW_DATA_ERROR code. This flags
-        allows size change in LibRaw::unpack() stage.</li>
-      <li><strong>LIBRAW_RAWOPTIONS_DNG_DISABLEWBADJUST</strong> - by default,
-        for DNG images with different per-channel maximums WB adjustment
-        procedure is performed. This flag disables such adjustment.</li>
-    </ul>
-    Other flags
-    <ul>
-      <li><b>LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS</b> - disable
-        auto-rotation for Kodak PPM bitmaps</li>
-      <li><b>LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS</b> - enable 16-bit PPM
-        thumbnails</li>
-      <li><b>LIBRAW_RAWOPTIONS_ZEROFILTERS_FOR_MONOCHROMETIFFS</b> - by default,
-        LibRaw assigns bayer pattern for Monochrome TIFF files (e.g. images from
-        Kodak 760).This does not work as expected if input file is really
-        monochrome (e.g. scan from Imacon X1 in monochrome mode).This flag will
-        force monochrome mode for TIFF RAWs w/o bayer filter tags (so, it will
-        break old Kodak processing). It is better to make it settable via user
-        interaction.</li>
-      <li><strong>LIBRAW_RAWOPTIONS_PROVIDE_NONSTANDARD_WB</strong> - If set and
-        when applicable, color.cam_mul[] and color.WB_Coeffs/WBCT_Coeffs will
-        contain WB settings for a non-standard workflow. Right now only Sony
-        DSC-F828 is affected: camera-recorded white balance can't be directly
-        applied to raw data because WB is for RGB, while raw data is RGBE.</li>
-      <li><strong>LIBRAW_RAWOPTIONS_CAMERAWB_FALLBACK_TO_DAYLIGHT</strong> - if
-        use_camera_wb is set, but no camera-recorded white balance present in
-        metadata, then fallback to daylight WB (default: fallback to
-        auto-balance).</li>
-      <li><strong>LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_KNOWN_VENDORS</strong> -
-        Some cameras (e.g.Ricoh) may record broken thumbnail in file:data offset
-        plus data size is beyond filecontents. This flag enforces size+offset
-        checks for files from known vendors (this will result into correct but
-        smaller thumbnail selected).</li>
-      <li><strong>LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_ALL_VENDORS</strong> - same
-        is above, but check is performed regardless of vendor (Make tag).</li>
-    </ul>
-    <ul>
-    </ul>
-    <p> <a name="LibRaw_rawspecial_t"></a></p>
-    <h3>enum LibRaw_rawspecial_t - special/non standard RAW extraction modes</h3>
-    These flags are applied to imgdata.rawparams:
-    <p>Sony ARW2.3 processing options: (for more details see
-      http://www.rawdigger.com/howtouse/sony-craw-arw2-posterization-detection)</p>
-    <ul>
-      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_BASEONLY</b> - decode only base pixels,
-        leave delta pixels as zero;</li>
-      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTAONLY</b> - decode only delta pixels
-        with base pixels zeroed;</li>
-      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTAZEROBASE</b> - decode delta pixels,
-        do not add base value;</li>
-      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTATOVALUE</b> - show possible
-        posterization areas;</li>
-    </ul>
-    <p>Sigma Quattro decoding flags:</p>
-    <ul>
-      <li><b>LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATERG</b> - disable R/G channels
-        interpolation</li>
-      <li><b>LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATEAF</b> - disable data
-        interpolation of low-sensitivity (AF or overexposure control) points on
-        Quattro sensors.</li>
-    </ul>
-    <p>Canon/Nikon small RAW (YCC) decoding flags (do not use both at same
-      time):</p>
-    <ul>
-      <li><b>LIBRAW_RAWSPECIAL_SRAW_NO_RGB</b> - disable YCC to RGB conversion</li>
-      <li><b>LIBRAW_RAWSPECIAL_SRAW_NO_INTERPOLATE</b> - disable missing color
-        values interpolation</li>
-    </ul>
-    <a href="index.html">[back to Index] </a>
-  </body>
-</html>
+        need to set <strong>LIBRAW_PROCESSING_USE_PPM16_THUMBS</strong> in
+        processing options.</dd>
+      <dt><strong> LIBRAW_THUMBNAIL_LAYER </strong></dt>
+      <dd>Data format is presently recognized upon opening of RAW file but not
+        supported: not unpacked into LibRaw::unpack_thumb.</dd>
+      <dt><strong> LIBRAW_THUMBNAIL_ROLLEI </strong></dt>
+      <dd>Data format is presently recognized upon opening of RAW file but not
+        supported: not unpacked into LibRaw::unpack_thumb.</dd>
+      <dt><strong>LIBRAW_THUMBNAIL_H265</strong></dt>
+      <dd>The thumbnail buffer contains a H.265 data frame (read from RAW file
+        as is, no manipulations performed on it).</dd>
+    </dl>
+    <p><a name="warnings"></a></p>
+    <h3>Nonstandard Situations (Warnings) during RAW Data Processing</h3>
+    <p>Some suspicious situations emerging during image processing are not fatal
+      but may affect the result of data retrieval or postprocessing. Such states
+      are indicated by setting a bit in the imgdata.process_warnings field.</p>
+    <dl>
+      <dt><strong> LIBRAW_WARN_BAD_CAMERA_WB </strong></dt>
+      <dd>Postprocessing must use white balance of the camera but this balance
+        is not suitable for use.</dd>
+      <dt><strong> LIBRAW_WARN_NO_METADATA </strong></dt>
+      <dd>Only for cameras where the metadata are taken from an external JPEG
+        file: metadata extraction has failed.</dd>
+      <dt><strong> LIBRAW_WARN_NO_JPEGLIB </strong></dt>
+      <dd>Only for P&amp;S Kodak cameras: data in JPEG format. At the same time,
+        open_file() will return LIBRAW_FILE_UNSUPPORTED.</dd>
+      <dt><strong> LIBRAW_WARN_NO_EMBEDDED_PROFILE </strong></dt>
+      <dd>(only if LCMS support compiled in). Caller set embedded input profile
+        use, but no such profile exists in RAW.</dd>
+      <dt><strong> LIBRAW_WARN_NO_INPUT_PROFILE </strong></dt>
+      <dd>(only if LCMS support compiled in). Error when opening input profile
+        ICC file.</dd>
+      <dt><strong> LIBRAW_WARN_BAD_OUTPUT_PROFILE </strong></dt>
+      <dd>(only if LCMS support compiled in). Error when opening output profile
+        ICC file.</dd>
+      <dt><strong> LIBRAW_WARN_NO_BADPIXELMAP </strong></dt>
+      <dd>Error when opening bad pixels map file.</dd>
+      <dt><strong> LIBRAW_WARN_BAD_DARKFRAME_FILE </strong></dt>
+      <dd>Error when opening dark frame file.</dd>
+      <dt><strong> LIBRAW_WARN_BAD_DARKFRAME_DIM </strong></dt>
+      <dd>Dark frame file either differs in dimensions from RAW-file processed,
+        or have wrong format. Dark frame should be in 16-bit PGM format (one can
+        generate it using simple_dcraw -4 -D).</dd>
+      <dt><strong> LIBRAW_WARN_RAWSPEED_PROBLEM </strong></dt>
+      <dd>Problems detected in RawSpeed decompressor. The image data processed
+        by LibRaw own decoder.</dd>
+      <dt><strong> LIBRAW_WARN_RAWSPEED_UNSUPPORTED </strong></dt>
+      <dd>This file not supported by RawSpeed (although compatible decoder
+        exists).</dd>
+      <dt><strong> LIBRAW_WARN_RAWSPEED_PROCESSED </strong></dt>
+      <dd>Not warning, but information. The file was decoded by RawSpeed.</dd>
+      <dt><strong> LIBRAW_WARN_FALLBACK_TO_AHD </strong></dt>
+      <dd>Incorrect/unsupported user_qual was set, AHD demosaic used instead.</dd>
+      <dt><strong> LIBRAW_WARN_PARSEFUJI_PROCESSED</strong></dt>
+      <dd>Not really a warning, but flag that fuji parser was used.</dd>
+      <dt><strong>LIBRAW_DNGSDK_PROCESSED</strong></dt>
+      <dd>Not really a warning: image was decoded by DNG SDK</dd>
+      <dt><strong> LIBRAW_DNG_IMAGES_REORDERED</strong></dt>
+      <dd>DNG sub0images was reordered </dd>
+      <dt><strong>LIBRAW_DNG_STAGE2_APPLIED</strong></dt>
+      <dd>DNG Stage2 conversion was performed</dd>
+      <dt><strong> LIBRAW_DNG_STAGE3_APPLIED</strong></dt>
+      <dd>DNG Stage3 conversion was performed</dd>
+    </dl>
+    <dl>
+    </dl>
+    <p><a name="LibRaw_image_formats"></a></p>
+    <h3>enum LibRaw_image_formats - possible types of data, contains in
+      libraw_processed_image_t structure</h3>
+    <p><strong> type </strong> field of libraw_processed_image_t structure may
+      have one of these values:</p>
+    <dl>
+      <dt><strong> LIBRAW_IMAGE_BITMAP </strong></dt>
+      <dd>The structure contains RGB-bitmap, metadata described in other fields
+        of libraw_processed_image_t.</dd>
+      <dt><strong> LIBRAW_IMAGE_JPEG </strong></dt>
+      <dd>libraw_processed_image_t structure contains JPEG image (in memory).
+        Only data_size field is meaningful.</dd>
+    </dl>
+    <p> <a name="LibRaw_processing_options"></a></p>
+    <h3> enum enum LibRaw_processing_options - bit that affects RAW data
+      extraction</h3>
+    These flags could be OR'ed with imgdata.params.raw_processing_options:
+    <p>Pentax 4-shot options:</p>
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_PENTAX_PS_ALLFRAMES</b> - merge all frames for
+        Pentax 4-shot files</li>
+    </ul>
+    <p>Floating point DNG files:</p>
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT</b> - convert FP data to
+        16-bit integer</li>
+    </ul>
+    <p>Sony ARQ Files:</p>
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_ARQ_SKIP_CHANNEL_SWAP</b> - do not perform Sony
+        ARQ channel swap to RGBG channel format, but use RGGB original channel
+        order</li>
+    </ul>
+    <p>DNG processing flags:</p>
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_DONT_CHECK_DNG_ILLUMINANT</b> - skip DNG
+        illuminant check when parsing DNG color data (use for compatibility w/
+        older LibRaw versions).</li>
+      <li><b>LIBRAW_RAWOPTIONS_DNGSDK_ZEROCOPY</b> - do not copy data extracted
+        by Adobe DNG SDK into separate buffer, but use DNG SDK buffer as is.</li>
+      <li><b>LIBRAW_RAWOPTIONS_DNG_ADD_ENHANCED</b> - if set, LibRaw will add
+        Enhanced DNG frame (NewSubfileType == 16) to the list of available
+        frames.</li>
+      <li><b>LIBRAW_RAWOPTIONS_DNG_ADD_PREVIEWS</b> - if set, LibRaw will add
+        previews (NewSubfileType == 1) to the frames list.</li>
+      <li><b>LIBRAW_RAWOPTIONS_DNG_PREFER_LARGEST_IMAGE</b>- By default, DNG
+        frames are not reordered and are available in same order as in DNG&nbsp;
+        (LibRaw traverses IFD/Sub-IFD trees in deep-first order).This bit will
+        prioritize the largest image</li>
+      <li><strong>LIBRAW_RAWOPTIONS_DNG_STAGE2</strong> - request DNG Stage2
+        processing (by DNG SDK)</li>
+      <li><strong>LIBRAW_RAWOPTIONS_DNG_STAGE3</strong> - request DNG Stage3
+        processing</li>
+      <li><strong>LIBRAW_RAWOPTIONS_DNG_ALLOWSIZECHANGE</strong> - by default,
+        if image size parsed by DNG SDK does not match image dimensions parsed
+        by LibRaw, processing will stop with LIBRAW_DATA_ERROR code. This flags
+        allows size change in LibRaw::unpack() stage.</li>
+      <li><strong>LIBRAW_RAWOPTIONS_DNG_DISABLEWBADJUST</strong> - by default,
+        for DNG images with different per-channel maximums WB adjustment
+        procedure is performed. This flag disables such adjustment.</li>
+    </ul>
+    Other flags
+    <ul>
+      <li><b>LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS</b> - disable
+        auto-rotation for Kodak PPM bitmaps</li>
+      <li><b>LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS</b> - enable 16-bit PPM
+        thumbnails</li>
+      <li><b>LIBRAW_RAWOPTIONS_ZEROFILTERS_FOR_MONOCHROMETIFFS</b> - by default,
+        LibRaw assigns bayer pattern for Monochrome TIFF files (e.g. images from
+        Kodak 760).This does not work as expected if input file is really
+        monochrome (e.g. scan from Imacon X1 in monochrome mode).This flag will
+        force monochrome mode for TIFF RAWs w/o bayer filter tags (so, it will
+        break old Kodak processing). It is better to make it settable via user
+        interaction.</li>
+      <li><strong>LIBRAW_RAWOPTIONS_PROVIDE_NONSTANDARD_WB</strong> - If set and
+        when applicable, color.cam_mul[] and color.WB_Coeffs/WBCT_Coeffs will
+        contain WB settings for a non-standard workflow. Right now only Sony
+        DSC-F828 is affected: camera-recorded white balance can't be directly
+        applied to raw data because WB is for RGB, while raw data is RGBE.</li>
+      <li><strong>LIBRAW_RAWOPTIONS_CAMERAWB_FALLBACK_TO_DAYLIGHT</strong> - if
+        use_camera_wb is set, but no camera-recorded white balance present in
+        metadata, then fallback to daylight WB (default: fallback to
+        auto-balance).</li>
+      <li><strong>LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_KNOWN_VENDORS</strong> -
+        Some cameras (e.g.Ricoh) may record broken thumbnail in file:data offset
+        plus data size is beyond filecontents. This flag enforces size+offset
+        checks for files from known vendors (this will result into correct but
+        smaller thumbnail selected).</li>
+      <li><strong>LIBRAW_RAWOPTIONS_CHECK_THUMBNAILS_ALL_VENDORS</strong> - same
+        is above, but check is performed regardless of vendor (Make tag).</li>
+    </ul>
+    <ul>
+    </ul>
+    <p> <a name="LibRaw_rawspecial_t"></a></p>
+    <h3>enum LibRaw_rawspecial_t - special/non standard RAW extraction modes</h3>
+    These flags are applied to imgdata.rawparams:
+    <p>Sony ARW2.3 processing options: (for more details see
+      http://www.rawdigger.com/howtouse/sony-craw-arw2-posterization-detection)</p>
+    <ul>
+      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_BASEONLY</b> - decode only base pixels,
+        leave delta pixels as zero;</li>
+      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTAONLY</b> - decode only delta pixels
+        with base pixels zeroed;</li>
+      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTAZEROBASE</b> - decode delta pixels,
+        do not add base value;</li>
+      <li><b>LIBRAW_RAWSPECIAL_SONYARW2_DELTATOVALUE</b> - show possible
+        posterization areas;</li>
+    </ul>
+    <p>Sigma Quattro decoding flags:</p>
+    <ul>
+      <li><b>LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATERG</b> - disable R/G channels
+        interpolation</li>
+      <li><b>LIBRAW_RAWSPECIAL_NODP2Q_INTERPOLATEAF</b> - disable data
+        interpolation of low-sensitivity (AF or overexposure control) points on
+        Quattro sensors.</li>
+    </ul>
+    <p>Canon/Nikon small RAW (YCC) decoding flags (do not use both at same
+      time):</p>
+    <ul>
+      <li><b>LIBRAW_RAWSPECIAL_SRAW_NO_RGB</b> - disable YCC to RGB conversion</li>
+      <li><b>LIBRAW_RAWSPECIAL_SRAW_NO_INTERPOLATE</b> - disable missing color
+        values interpolation</li>
+    </ul>
+    <a href="index.html">[back to Index] </a>
+  </body>
+</html>
diff --git a/doc/Samples-LibRaw.html b/doc/Samples-LibRaw.html
index 37b41c08..c72a3f94 100644
--- a/doc/Samples-LibRaw.html
+++ b/doc/Samples-LibRaw.html
@@ -27,8 +27,8 @@ <h2>Overview of Examples in the Distribution Package (samples/*)</h2>
       <li><strong>dcraw_half</strong> Demonstrates the use of <a href="API-C.html">C
           API</a>. The example emulates the behavior of <strong>dcraw -h</strong>
         (no other control parameters can be specified in this example). </li>
-      <li><strong>dcraw_emu</strong> Complete emulation of dcraw (except for
-        keys -D -d -P -K -i -e, which are considered in other usage examples).
+      <li><strong>dcraw_emu</strong> Almost complete emulation of dcraw (except for
+        keys -D -d -E -i -v -e, which are considered in other usage examples).
         Of most interest is processing of command line keys (copied from dcraw).
         <br>
         <p>This sample supports additional command-line parameters absent in
diff --git a/internal/libraw_cameraids.h b/internal/libraw_cameraids.h
index c88ed037..538d1057 100644
--- a/internal/libraw_cameraids.h
+++ b/internal/libraw_cameraids.h
@@ -86,7 +86,9 @@ it under the terms of the one of two licenses as you choose:
 #define CanonID_EOS_850D          (0x80000000ULL + 0x435ULL)
 #define CanonID_EOS_250D          (0x80000000ULL + 0x436ULL)
 #define CanonID_EOS_90D           (0x80000000ULL + 0x437ULL)
+#define CanonID_EOS_R3            (0x80000000ULL + 0x450ULL)
 #define CanonID_EOS_R6            (0x80000000ULL + 0x453ULL)
+#define CanonID_EOS_M50_Mark_II   (0x80000000ULL + 0x468ULL)
 
 // CanonID_EOS_D2000C after Canon's TIFF2CR2 convertor:
 #define CanonID_EOS_D2000C        (0x80000000ULL + 0x520ULL)
@@ -154,6 +156,7 @@ it under the terms of the one of two licenses as you choose:
 #define OlyID_E_M10_Mark_IV   OlyID_str2hex("S0088")
 #define OlyID_E_M5_Mark_III   OlyID_str2hex("S0089")
 #define OlyID_E_M1_Mark_III   OlyID_str2hex("S0092")
+#define OlyID_E_P7            OlyID_str2hex("S0093")
 #define OlyID_C_3030Z         OlyID_str2hex("SX351")
 #define OlyID_C_5050Z         OlyID_str2hex("SX558")
 #define OlyID_C_350Z          OlyID_str2hex("SX751")
@@ -216,6 +219,8 @@ it under the terms of the one of two licenses as you choose:
 #define PentaxID_K_70         0x13222ULL
 #define PentaxID_KP           0x1322cULL
 #define PentaxID_K_1_Mark_II  0x13240ULL
+#define PentaxID_K_3_III      0x13254ULL
+#define PentaxID_GR_IIIx      0x1329aULL
 
 #define SonyID_DSC_R1           0x002ULL
 #define SonyID_DSLR_A100        0x100ULL
@@ -302,5 +307,10 @@ it under the terms of the one of two licenses as you choose:
 #define SonyID_ILCE_6100        0x17bULL
 #define SonyID_ZV_1             0x17cULL
 #define SonyID_ILCE_7C          0x17dULL
+#define SonyID_ZV_E10           0x17eULL
 #define SonyID_ILCE_7SM3        0x17fULL
+#define SonyID_ILCE_1           0x180ULL
+#define SonyID_ILME_FX3         0x181ULL
+#define SonyID_ILCE_7RM3A       0x182ULL
+#define SonyID_ILCE_7RM4A       0x183ULL
 #endif
diff --git a/internal/libraw_internal_funcs.h b/internal/libraw_internal_funcs.h
index 4eee0a09..d86dccc1 100644
--- a/internal/libraw_internal_funcs.h
+++ b/internal/libraw_internal_funcs.h
@@ -51,10 +51,11 @@ it under the terms of the one of two licenses as you choose:
 	static libraw_static_table_t Sony_SR2_wb_list;
 	static libraw_static_table_t Sony_SR2_wb_list1;
 /*  */
-	int     find_ifd_by_offset(int );
+	int	find_ifd_by_offset(int );
 	ushort	sget2 (uchar *s);
 	ushort	sget2Rev(uchar *s);
-	int 	parseCR3(unsigned long long oAtomList, unsigned long long szAtomList, short &nesting, char *AtomNameStack, short& nTrack, short &TrackType);
+	libraw_area_t	get_CanonArea();
+	int	parseCR3(INT64 oAtomList, INT64 szAtomList, short &nesting, char *AtomNameStack, short& nTrack, short &TrackType);
 	void	selectCRXTrack(short maxTrack);
 	void	setCanonBodyFeatures (unsigned long long id);
 	void	processCanonCameraInfo (unsigned long long id, uchar *CameraInfo, unsigned maxlen, unsigned type, unsigned dng_writer);
@@ -127,7 +128,7 @@ it under the terms of the one of two licenses as you choose:
 
 	ushort      get2();
 	unsigned    sget4 (uchar *s);
-    unsigned    getint(int type);
+	unsigned    getint(int type);
 	float       int_to_float (int i);
 	double      getreal (int type);
 	double      sgetreal(int type, uchar *s);
@@ -196,6 +197,7 @@ it under the terms of the one of two licenses as you choose:
 //	void        fuji_load_raw();
 	int         guess_RAFDataGeneration (uchar *RAFData_start);
 	void        parse_fuji (int offset);
+    void        parse_fuji_thumbnail(int offset);
 #ifdef LIBRAW_OLD_VIDEO_SUPPORT
 // RedCine
 	void        parse_redcine();
@@ -213,6 +215,9 @@ it under the terms of the one of two licenses as you choose:
 //int         bayer (unsigned row, unsigned col);
 	int         p1raw(unsigned,unsigned);
 	void        phase_one_flat_field (int is_float, int nc);
+	int 	    p1rawc(unsigned row, unsigned col, unsigned& count);
+	void 	    phase_one_fix_col_pixel_avg(unsigned row, unsigned col);
+	void 	    phase_one_fix_pixel_grad(unsigned row, unsigned col);
 	void        phase_one_load_raw();
 	unsigned    ph1_bits (int nbits);
 	void        phase_one_load_raw_c();
@@ -280,6 +285,7 @@ it under the terms of the one of two licenses as you choose:
 	void        sony_arw_load_raw();
 	void        sony_arw2_load_raw();
 	void        sony_arq_load_raw();
+	void        sony_ljpeg_load_raw();
 	void        samsung_load_raw();
 	void        samsung2_load_raw();
 	void        samsung3_load_raw();
@@ -336,7 +342,7 @@ it under the terms of the one of two licenses as you choose:
 	void        parse_gps_libraw(int base);
 	void        aRGB_coeff(double aRGB_cam[3][3]);
 	void        romm_coeff(float romm_cam[3][3]);
-	void        parse_mos (int offset);
+	void        parse_mos (INT64 offset);
 	void        parse_qt (int end);
 	void        get_timestamp (int reversed);
 
diff --git a/internal/var_defines.h b/internal/var_defines.h
index 234257ea..36c6adb9 100644
--- a/internal/var_defines.h
+++ b/internal/var_defines.h
@@ -106,7 +106,7 @@ it under the terms of the one of two licenses as you choose:
 #define aber              (imgdata.params.aber)
 #define gamm              (imgdata.params.gamm)
 #define user_mul          (imgdata.params.user_mul)
-#define shot_select       (imgdata.params.shot_select)
+#define shot_select       (imgdata.rawparams.shot_select)
 #define bright            (imgdata.params.bright)
 #define threshold         (imgdata.params.threshold)
 #define half_size         (imgdata.params.half_size)
diff --git a/libraw/libraw.h b/libraw/libraw.h
index 2a8a07c4..585bda0c 100644
--- a/libraw/libraw.h
+++ b/libraw/libraw.h
@@ -225,6 +225,7 @@ class DllDef LibRaw
   void raw2image_start();
   void free_image();
   int adjust_maximum();
+  int adjust_to_raw_inset_crop(unsigned mask, float maxcrop = 0.55f); 
   void set_exifparser_handler(exif_parser_callback cb, void *data)
   {
     callbacks.exifparser_data = data;
diff --git a/libraw/libraw_const.h b/libraw/libraw_const.h
index 5fe08170..fd6ba741 100644
--- a/libraw/libraw_const.h
+++ b/libraw/libraw_const.h
@@ -24,6 +24,19 @@ it under the terms of the one of two licenses as you choose:
 #define LIBRAW_MAX_ALLOC_MB_DEFAULT 2048L
 #endif
 
+#ifndef LIBRAW_MAX_NONDNG_RAW_FILE_SIZE
+#define LIBRAW_MAX_NONDNG_RAW_FILE_SIZE 2147483647ULL
+#endif
+
+#ifndef LIBRAW_MAX_DNG_RAW_FILE_SIZE
+#ifdef USE_DNGSDK
+#define LIBRAW_MAX_DNG_RAW_FILE_SIZE 4294967295ULL
+#else
+#define LIBRAW_MAX_DNG_RAW_FILE_SIZE 2147483647ULL
+#endif
+#endif
+
+
 /* limit thumbnail size, default is 512Mb*/
 #ifndef LIBRAW_MAX_THUMBNAIL_MB
 #define LIBRAW_MAX_THUMBNAIL_MB 512L
@@ -89,7 +102,8 @@ enum LibRaw_dngfields_marks
   LIBRAW_DNGFM_PREVIEWCS = 1 << 11,
   LIBRAW_DNGFM_ASSHOTNEUTRAL = 1 << 12,
   LIBRAW_DNGFM_BASELINEEXPOSURE = 1 << 13,
-  LIBRAW_DNGFM_LINEARRESPONSELIMIT = 1 << 14
+  LIBRAW_DNGFM_LINEARRESPONSELIMIT = 1 << 14,
+  LIBRAW_DNGFM_USERCROP = 1 << 15,
 };
 
 enum LibRaw_As_Shot_WB_Applied_codes
@@ -347,6 +361,7 @@ enum LibRaw_cameramaker_index
   LIBRAW_CAMERAMAKER_VIVO,
   LIBRAW_CAMERAMAKER_HMD_Global,
   LIBRAW_CAMERAMAKER_HUAWEI,
+  LIBRAW_CAMERAMAKER_RaspberryPi,
   // Insert additional indexes here
   LIBRAW_CAMERAMAKER_TheLastOne
 };
@@ -431,16 +446,19 @@ enum LibRaw_camera_formats
 enum LibRawImageAspects
 {
   LIBRAW_IMAGE_ASPECT_UNKNOWN = 0,
-  LIBRAW_IMAGE_ASPECT_3to2,
-  LIBRAW_IMAGE_ASPECT_1to1,
-  LIBRAW_IMAGE_ASPECT_4to3,
-  LIBRAW_IMAGE_ASPECT_16to9,
-  LIBRAW_IMAGE_ASPECT_6to6,
-  LIBRAW_IMAGE_ASPECT_5to4,
-  LIBRAW_IMAGE_ASPECT_7to6,
-  LIBRAW_IMAGE_ASPECT_6to5,
-  LIBRAW_IMAGE_ASPECT_7to5,
-  LIBRAW_IMAGE_ASPECT_OTHER
+  LIBRAW_IMAGE_ASPECT_OTHER = 1,
+  LIBRAW_IMAGE_ASPECT_MINIMAL_REAL_ASPECT_VALUE = 99, /* 1:10*/
+  LIBRAW_IMAGE_ASPECT_MAXIMAL_REAL_ASPECT_VALUE = 10000, /* 10: 1*/
+  // Value:  width / height * 1000
+  LIBRAW_IMAGE_ASPECT_3to2 =  (1000 * 3)/2,
+  LIBRAW_IMAGE_ASPECT_1to1 =  1000,
+  LIBRAW_IMAGE_ASPECT_4to3 =  (1000 * 4)/ 3,
+  LIBRAW_IMAGE_ASPECT_16to9 = (1000 * 16) / 9,
+  //LIBRAW_IMAGE_ASPECT_6to6, // what is the difference with 1:1 ?
+  LIBRAW_IMAGE_ASPECT_5to4 = (1000 * 5) / 4,
+  LIBRAW_IMAGE_ASPECT_7to6 = (1000 * 7) / 6,
+  LIBRAW_IMAGE_ASPECT_6to5 = (1000 * 6) / 5,
+  LIBRAW_IMAGE_ASPECT_7to5 = (1000 * 7) / 5
 };
 
 enum LibRaw_lens_focal_types
@@ -495,6 +513,25 @@ enum LibRaw_sony_cameratypes
   LIBRAW_SONY_CameraType_UNKNOWN = 0xffff
 };
 
+enum LibRaw_Sony_0x2010_Type {
+  LIBRAW_SONY_Tag2010None = 0,
+  LIBRAW_SONY_Tag2010a,
+  LIBRAW_SONY_Tag2010b,
+  LIBRAW_SONY_Tag2010c,
+  LIBRAW_SONY_Tag2010d,
+  LIBRAW_SONY_Tag2010e,
+  LIBRAW_SONY_Tag2010f,
+  LIBRAW_SONY_Tag2010g,
+  LIBRAW_SONY_Tag2010h,
+  LIBRAW_SONY_Tag2010i
+};
+enum LibRaw_Sony_0x9050_Type {
+  LIBRAW_SONY_Tag9050None = 0,
+  LIBRAW_SONY_Tag9050a,
+  LIBRAW_SONY_Tag9050b,
+  LIBRAW_SONY_Tag9050c
+};
+
 enum LIBRAW_SONY_FOCUSMODEmodes
 {
   LIBRAW_SONY_FOCUSMODE_MF     = 0,
@@ -561,7 +598,7 @@ enum LibRaw_processing_options
   LIBRAW_RAWOPTIONS_CONVERTFLOAT_TO_INT = 1 << 1,
   LIBRAW_RAWOPTIONS_ARQ_SKIP_CHANNEL_SWAP = 1 << 2,
   LIBRAW_RAWOPTIONS_NO_ROTATE_FOR_KODAK_THUMBNAILS = 1 << 3,
-  LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP = 1 << 4,
+//  LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP = 1 << 4,
   LIBRAW_RAWOPTIONS_USE_PPM16_THUMBS = 1 << 5,
   LIBRAW_RAWOPTIONS_DONT_CHECK_DNG_ILLUMINANT = 1 << 6,
   LIBRAW_RAWOPTIONS_DNGSDK_ZEROCOPY = 1 << 7,
diff --git a/libraw/libraw_internal.h b/libraw/libraw_internal.h
index fbda7818..0a530a84 100644
--- a/libraw/libraw_internal.h
+++ b/libraw/libraw_internal.h
@@ -142,8 +142,10 @@ typedef struct
   unsigned kodak_cbpp;
   INT64 strip_offset, data_offset;
   INT64 meta_offset;
+  INT64 exif_offset, ifd0_offset;
   unsigned data_size;
   unsigned meta_length;
+  unsigned cr3_exif_length, cr3_ifd0_length;
   unsigned thumb_misc;
   unsigned fuji_layout;
   unsigned tiff_samples;
diff --git a/libraw/libraw_types.h b/libraw/libraw_types.h
index 1492f06c..662fe796 100644
--- a/libraw/libraw_types.h
+++ b/libraw/libraw_types.h
@@ -205,7 +205,7 @@ typedef unsigned long long UINT64;
 
   typedef struct
   {
-    ushort cleft, ctop, cwidth, cheight, aspect;
+    ushort cleft, ctop, cwidth, cheight;
   } libraw_raw_inset_crop_t;
 
   typedef struct
@@ -216,9 +216,15 @@ typedef unsigned long long UINT64;
     double pixel_aspect;
     int flip;
     int mask[8][4];
-    libraw_raw_inset_crop_t raw_inset_crop;
+    ushort raw_aspect;
+    libraw_raw_inset_crop_t raw_inset_crops[2];
   } libraw_image_sizes_t;
 
+ typedef struct
+  {
+    short t,l,b,r; // top, left, bottom, right pixel coordinates, (0,0) is top left pixel;
+  } libraw_area_t; 
+
   struct ph1_t
   {
     int format, key_off, tag_21a;
@@ -243,7 +249,8 @@ typedef unsigned long long UINT64;
     float dng_fcblack[LIBRAW_CBLACK_SIZE];
     float dng_fblack;
     unsigned dng_whitelevel[4];
-    unsigned default_crop[4]; /* Origin and size */
+    ushort default_crop[4]; /* Origin and size */
+    float    user_crop[4]; // top-left-bottom-right relative to default_crop
     unsigned preview_colorspace;
     float analogbalance[4];
     float asshotneutral[4];
@@ -287,14 +294,7 @@ typedef unsigned long long UINT64;
     /* sensor */
     short SensorWidth;
     short SensorHeight;
-    short SensorLeftBorder;
-    short SensorTopBorder;
-    short SensorRightBorder;
-    short SensorBottomBorder;
-    short BlackMaskLeftBorder;
-    short BlackMaskTopBorder;
-    short BlackMaskRightBorder;
-    short BlackMaskBottomBorder;
+
     int   AFMicroAdjMode;
     float AFMicroAdjValue;
     short MakernotesFlip;
@@ -304,9 +304,13 @@ typedef unsigned long long UINT64;
     short RF_lensID;
     int AutoLightingOptimizer;
     int HighlightTonePriority;
-    short LeftOpticalBlack[4]; // use this, when present, to estimate black levels?
-    short UpperOpticalBlack[4];
-    short ActiveArea[4];
+
+   libraw_area_t DefaultCropAbsolute;
+   libraw_area_t RecommendedImageArea;   // contains the image in proper aspect ratio?
+   libraw_area_t LeftOpticalBlack;       // use this, when present, to estimate black levels?
+   libraw_area_t UpperOpticalBlack;
+   libraw_area_t ActiveArea;
+    
     short ISOgain[2]; // AutoISO & BaseISO per ExifTool
   } libraw_canon_makernotes_t;
 
@@ -423,6 +427,11 @@ typedef unsigned long long UINT64;
     */
     ushort BlackLevel[9];
     unsigned RAFData_ImageSizeTable[32];
+    int AutoBracketing;
+    int SequenceNumber;
+    int SeriesLength;
+    float PixelShiftOffset[2];
+    int ImageCount;
   } libraw_fuji_info_t;
 
   typedef struct
@@ -494,6 +503,11 @@ typedef unsigned long long UINT64;
     ushort SensorWidth;
     ushort SensorHeight;
     ushort Active_D_Lighting;
+    unsigned ShotInfoVersion;
+    short MakernotesFlip;
+    double RollAngle;  // positive is clockwise, CW
+    double PitchAngle; // positive is upwords
+    double YawAngle;   // positive is to the right
   } libraw_nikon_makernotes_t;
 
   typedef struct
@@ -518,6 +532,11 @@ typedef unsigned long long UINT64;
     ushort   FocusStepNear;
     double   FocusDistance;
     ushort   AspectFrame[4]; // left, top, width, height
+    unsigned StackedImage[2];
+    uchar    isLiveND;
+    unsigned LiveNDfactor;
+    ushort   Panorama_mode;
+    ushort   Panorama_frameNum;
   } libraw_olympus_makernotes_t;
 
   typedef struct
@@ -649,6 +668,7 @@ typedef unsigned long long UINT64;
     ushort   HighISONoiseReduction;           // init in 0xffff
     ushort   HDR[2];
     ushort   group2010;
+    ushort   group9050;
     ushort   real_iso_offset;                 // init in 0xffff
     ushort   MeteringMode_offset;
     ushort   ExposureProgram_offset;
@@ -673,16 +693,19 @@ typedef unsigned long long UINT64;
     ushort   prd_BayerPattern;  /* 0 -> not valid; 1 -> RGGB; 4 -> GBRG */
 
     ushort   SonyRawFileType; /* init in 0xffff
+                               valid for ARW 2.0 and up (FileFormat >= 3000)
                                takes precedence over RAWFileType and Quality:
                                0  for uncompressed 14-bit raw
                                1  for uncompressed 12-bit raw
-                               2  for compressed raw
+                               2  for compressed raw (lossy)
                                3  for lossless compressed raw
+                               4  for lossless compressed raw v.2 (ILCE-1)
                             */
     ushort RAWFileType;     /* init in 0xffff
                                takes precedence over Quality
                                0 for compressed raw,
                                1 for uncompressed;
+                               2 lossless compressed raw v.2
                             */
     unsigned Quality;       /* init in 0xffffffff
                                0 or 6 for raw, 7 or 8 for compressed raw */
@@ -757,12 +780,12 @@ typedef unsigned long long UINT64;
                       0    Name unknown
                       1    "RAW 1"
                       2    "RAW 2"
-                      3    "IIQ L"
+                      3    "IIQ L" (IIQ L14)
                       4    Never seen
                       5    "IIQ S"
-                      6    "IIQ S v.2"
+                      6    "IIQ Sv2" (S14 / S14+)
                       7    Never seen
-                      8    Name unknown
+                      8    "IIQ L16" (IIQ L16EX / IIQ L16)
                       */
 	int ExifColorSpace;
   } libraw_colordata_t;
@@ -840,7 +863,6 @@ typedef unsigned long long UINT64;
     double aber[4];        /* -C */
     double gamm[6];        /* -g */
     float user_mul[4];     /* -r mul0 mul1 mul2 mul3 */
-    unsigned shot_select;  /* -s */
     float bright;          /* -b */
     float threshold;       /* -n */
     int half_size;         /* -h */
@@ -888,6 +910,7 @@ typedef unsigned long long UINT64;
       /* DNG SDK */
       int use_dngsdk;
       unsigned options;
+      unsigned shot_select;  /* -s */
       unsigned specials;
       unsigned max_raw_memory_mb;
       int sony_arw2_posterization_thr;
diff --git a/libraw/libraw_version.h b/libraw/libraw_version.h
index a72e9d2d..4d5a0321 100644
--- a/libraw/libraw_version.h
+++ b/libraw/libraw_version.h
@@ -25,7 +25,7 @@ it under the terms of the one of two licenses as you choose:
 #define LIBRAW_PATCH_VERSION 0
 #define LIBRAW_VERSION_TAIL Snapshot202101
 
-#define LIBRAW_SHLIB_CURRENT 21
+#define LIBRAW_SHLIB_CURRENT 22
 #define LIBRAW_SHLIB_REVISION 0
 #define LIBRAW_SHLIB_AGE 0
 
diff --git a/samples/4channels.cpp b/samples/4channels.cpp
index 9040a2d9..82d40f4e 100644
--- a/samples/4channels.cpp
+++ b/samples/4channels.cpp
@@ -60,6 +60,7 @@ int main(int ac, char *av[])
 #define T RawProcessor.imgdata.thumbnail
 #define P2 RawProcessor.imgdata.other
 #define OUT RawProcessor.imgdata.params
+#define OUTR RawProcessor.imgdata.rawparams
 
   OUT.output_bps = 16;
   OUT.output_tiff = 1;
@@ -74,7 +75,7 @@ int main(int ac, char *av[])
       if (av[i][1] == 's' && av[i][2] == 0)
       {
         i++;
-        OUT.shot_select = av[i] ? atoi(av[i]) : 0;
+        OUTR.shot_select = av[i] ? atoi(av[i]) : 0;
       }
       else if (av[i][1] == 'g' && av[i][2] == 0)
         use_gamma = 1;
@@ -158,8 +159,8 @@ int main(int ac, char *av[])
       else
         snprintf(lname, 7, "%c", ((char *)("GCMY"))[layer]);
 
-      if (OUT.shot_select)
-        snprintf(outfn, sizeof(outfn), "%s-%d.%s.tiff", av[i], OUT.shot_select,
+      if (OUTR.shot_select)
+        snprintf(outfn, sizeof(outfn), "%s-%d.%s.tiff", av[i], OUTR.shot_select,
                  lname);
       else
         snprintf(outfn, sizeof(outfn), "%s.%s.tiff", av[i], lname);
diff --git a/samples/dcraw_emu.cpp b/samples/dcraw_emu.cpp
index c4498b91..2d21016b 100644
--- a/samples/dcraw_emu.cpp
+++ b/samples/dcraw_emu.cpp
@@ -348,7 +348,7 @@ int main(int argc, char *argv[])
       OUT.highlight = atoi(argv[arg++]);
       break;
     case 's':
-      OUT.shot_select = abs(atoi(argv[arg++]));
+      OUTR.shot_select = abs(atoi(argv[arg++]));
       break;
     case 'o':
       if (isdigit(argv[arg][0]) && !isdigit(argv[arg][1]))
diff --git a/samples/postprocessing_benchmark.cpp b/samples/postprocessing_benchmark.cpp
index 151e2848..703a7a37 100644
--- a/samples/postprocessing_benchmark.cpp
+++ b/samples/postprocessing_benchmark.cpp
@@ -43,6 +43,7 @@ int main(int argc, char *argv[])
 #undef OUT
 #endif
 #define OUT RawProcessor.imgdata.params
+#define OUTR RawProcessor.imgdata.rawparams
 #define S RawProcessor.imgdata.sizes
 
   if (argc < 2)
@@ -105,7 +106,7 @@ int main(int argc, char *argv[])
       OUT.threshold = (float)atof(argv[arg++]);
       break;
     case 's':
-      OUT.shot_select = abs(atoi(argv[arg++]));
+      OUTR.shot_select = abs(atoi(argv[arg++]));
       break;
     case 'B':
       for (c = 0; c < 4; c++)
@@ -186,7 +187,7 @@ int main(int argc, char *argv[])
              "Params:      WB=%s Highlight=%d Qual=%d HalfSize=%s Median=%d "
              "Wavelet=%.0f\n"
              "Crop:        %u-%u:%ux%u, active Mpix: %.2f, %.1f frames/sec\n",
-             mpixsec, argv[arg], OUT.shot_select, rmpix, msec,
+             mpixsec, argv[arg], OUTR.shot_select, rmpix, msec,
              OUT.use_auto_wb ? "auto" : "default", OUT.highlight, OUT.user_qual,
              OUT.half_size ? "YES" : "No", OUT.med_passes, OUT.threshold,
              crop[0], crop[1], crop[2], crop[3], mpix, 1000.0f / msec);
diff --git a/samples/raw-identify.cpp b/samples/raw-identify.cpp
index f47b7b9b..49cf9a7e 100644
--- a/samples/raw-identify.cpp
+++ b/samples/raw-identify.cpp
@@ -509,13 +509,13 @@ void print_verbose(FILE *outfile, LibRaw &MyCoolRawProcessor, std::string &fn)
     fprintf(outfile, "Thumb size:  %4d x %d\n", T.twidth, T.theight);
   fprintf(outfile, "Full size:   %4d x %d\n", S.raw_width, S.raw_height);
 
-  if (S.raw_inset_crop.cwidth)
+  if (S.raw_inset_crops[0].cwidth)
   {
-    fprintf(outfile, "Raw inset, width x height: %4d x %d ", S.raw_inset_crop.cwidth, S.raw_inset_crop.cheight);
-    if (S.raw_inset_crop.cleft != 0xffff)
-      fprintf(outfile, "left: %d ", S.raw_inset_crop.cleft);
-    if (S.raw_inset_crop.ctop != 0xffff)
-      fprintf(outfile, "top: %d", S.raw_inset_crop.ctop);
+    fprintf(outfile, "Raw inset, width x height: %4d x %d ", S.raw_inset_crops[0].cwidth, S.raw_inset_crops[0].cheight);
+    if (S.raw_inset_crops[0].cleft != 0xffff)
+      fprintf(outfile, "left: %d ", S.raw_inset_crops[0].cleft);
+    if (S.raw_inset_crops[0].ctop != 0xffff)
+      fprintf(outfile, "top: %d", S.raw_inset_crops[0].ctop);
     fprintf(outfile, "\n");
   }
 
@@ -673,6 +673,7 @@ void print_verbose(FILE *outfile, LibRaw &MyCoolRawProcessor, std::string &fn)
     fprintf(outfile, "\nDerived D65 multipliers:");
     for (int c = 0; c < P1.colors; c++)
       fprintf(outfile, " %f", C.pre_mul[c]);
+    fprintf(outfile, "\n");
   }
 }
 
diff --git a/samples/unprocessed_raw.cpp b/samples/unprocessed_raw.cpp
index ff35497b..2f30ce4c 100644
--- a/samples/unprocessed_raw.cpp
+++ b/samples/unprocessed_raw.cpp
@@ -70,6 +70,7 @@ int main(int ac, char *av[])
 
 #define S RawProcessor.imgdata.sizes
 #define OUT RawProcessor.imgdata.params
+#define OUTR RawProcessor.imgdata.rawparams
 
   for (i = 1; i < ac; i++)
   {
@@ -86,7 +87,7 @@ int main(int ac, char *av[])
       else if (av[i][1] == 's' && av[i][2] == 0)
       {
         i++;
-        OUT.shot_select = av[i] ? atoi(av[i]) : 0;
+        OUTR.shot_select = av[i] ? atoi(av[i]) : 0;
       }
       else
         goto usage;
@@ -150,8 +151,8 @@ int main(int ac, char *av[])
         printf("Gamma-corrected....\n");
     }
 
-    if (OUT.shot_select)
-      snprintf(outfn, sizeof(outfn), "%s-%d.%s", av[i], OUT.shot_select,
+    if (OUTR.shot_select)
+      snprintf(outfn, sizeof(outfn), "%s-%d.%s", av[i], OUTR.shot_select,
                out_tiff ? "tiff" : "pgm");
     else
       snprintf(outfn, sizeof(outfn), "%s.%s", av[i], out_tiff ? "tiff" : "pgm");
diff --git a/src/decoders/canon_600.cpp b/src/decoders/canon_600.cpp
index 8508da85..59576f1f 100644
--- a/src/decoders/canon_600.cpp
+++ b/src/decoders/canon_600.cpp
@@ -93,7 +93,7 @@ void LibRaw::canon_600_auto_wb()
   int test[8], total[2][8], ratio[2][2], stat[2];
 
   memset(&total, 0, sizeof total);
-  i = canon_ev + 0.5;
+  i = int(canon_ev + 0.5);
   if (i < 10)
     mar = 150;
   else if (i > 12)
@@ -137,7 +137,8 @@ void LibRaw::canon_600_auto_wb()
   {
     st = count[0] * 200 < count[1];
     for (i = 0; i < 4; i++)
-      pre_mul[i] = 1.0 / (total[st][i] + total[st][i + 4]);
+		if (total[st][i] + total[st][i + 4])
+			pre_mul[i] = 1.0f / (total[st][i] + total[st][i + 4]);
   }
 }
 
@@ -168,7 +169,7 @@ void LibRaw::canon_600_coeff()
   if (flash_used)
     t = 5;
   for (raw_color = i = 0; i < 3; i++)
-    FORCC rgb_cam[i][c] = table[t][i * 4 + c] / 1024.0;
+    FORCC rgb_cam[i][c] = float(table[t][i * 4 + c]) / 1024.f;
 }
 
 void LibRaw::canon_600_load_raw()
diff --git a/src/decoders/decoders_dcraw.cpp b/src/decoders/decoders_dcraw.cpp
index 6f1ea5a8..c81ad6b5 100644
--- a/src/decoders/decoders_dcraw.cpp
+++ b/src/decoders/decoders_dcraw.cpp
@@ -203,7 +203,8 @@ int LibRaw::canon_has_lowbits()
 void LibRaw::canon_load_raw()
 {
   ushort *pixel, *prow, *huff[2];
-  int nblocks, lowbits, i, c, row, r, save, val;
+  int nblocks, lowbits, i, c, row, r, val;
+  INT64 save;
   int block, diffbuf[64], leaf, len, diff, carry = 0, pnum = 0, base[2];
 
   crw_init_tables(tiff_compress, huff);
@@ -834,7 +835,7 @@ void LibRaw::nikon_read_curve()
   if (ver0 == 0x49 || ver1 == 0x58)
     fseek(ifp, 2110, SEEK_CUR);
   read_shorts(vpred[0], 4);
-  max = 1 << tiff_bps & 0x7fff;
+  step = max = 1 << tiff_bps & 0x7fff;
   if ((csize = get2()) > 1)
     step = max / (csize - 1);
   if (ver0 == 0x44 && (ver1 == 0x20 || (ver1 == 0x40 && step > 3)) && step > 0)
@@ -941,7 +942,7 @@ void LibRaw::nikon_yuv_load_raw()
 {
   if (!image)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
-  int row, col, yuv[4], rgb[3], b, c;
+  int row, col, yuv[4]={0,0,0,0}, rgb[3], b, c;
   UINT64 bitbuf = 0;
   float cmul[4];
   FORC4 { cmul[c] = cam_mul[c] > 0.001f ? cam_mul[c] : 1.f; }
@@ -1117,6 +1118,7 @@ void LibRaw::panasonic_load_raw()
 {
   int row, col, i, j, sh = 0, pred[2], nonz[2];
   unsigned bytes[16];
+  memset(bytes,0,sizeof(bytes)); // make gcc11 happy
   ushort *raw_block_data;
 
   pana_data(0, 0);
@@ -1606,7 +1608,7 @@ void LibRaw::samsung_load_raw()
         if (idest < maxpixels &&
             isrc <
                 maxpixels) // less than zero is handled by unsigned conversion
-          RAW(row, col + c) = (i > 0 ? ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) : 0) + 			                
+          RAW(row, col + c) = (i > 0 ? ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) : 0) +
             (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);
         else
           derror();
diff --git a/src/decoders/decoders_libraw.cpp b/src/decoders/decoders_libraw.cpp
index f7c473f0..701b19b5 100644
--- a/src/decoders/decoders_libraw.cpp
+++ b/src/decoders/decoders_libraw.cpp
@@ -313,14 +313,16 @@ void LibRaw::nikon_load_striped_packed_raw()
 
 struct pana_cs6_page_decoder
 {
-  unsigned int pixelbuffer[14], lastoffset, maxoffset;
+  unsigned int pixelbuffer[18], lastoffset, maxoffset;
   unsigned char current, *buffer;
   pana_cs6_page_decoder(unsigned char *_buffer, unsigned int bsize)
       : lastoffset(0), maxoffset(bsize), current(0), buffer(_buffer)
   {
   }
   void read_page(); // will throw IO error if not enough space in buffer
+  void read_page12(); // 12-bit variant
   unsigned int nextpixel() { return current < 14 ? pixelbuffer[current++] : 0; }
+  unsigned int nextpixel12() { return current < 18 ? pixelbuffer[current++] : 0; }
 };
 
 void pana_cs6_page_decoder::read_page()
@@ -328,14 +330,12 @@ void pana_cs6_page_decoder::read_page()
   if (!buffer || (maxoffset - lastoffset < 16))
     throw LIBRAW_EXCEPTION_IO_EOF;
 #define wbuffer(i) ((unsigned short)buffer[lastoffset + 15 - i])
-  pixelbuffer[0] = (wbuffer(0) << 6) | (wbuffer(1) >> 2); // 14 bit
-  pixelbuffer[1] =
-      (((wbuffer(1) & 0x3) << 12) | (wbuffer(2) << 4) | (wbuffer(3) >> 4)) &
-      0x3fff;
-  pixelbuffer[2] = (wbuffer(3) >> 2) & 0x3;
-  pixelbuffer[3] = ((wbuffer(3) & 0x3) << 8) | wbuffer(4);
-  pixelbuffer[4] = (wbuffer(5) << 2) | (wbuffer(6) >> 6);
-  pixelbuffer[5] = ((wbuffer(6) & 0x3f) << 4) | (wbuffer(7) >> 4);
+  pixelbuffer[0] = (wbuffer(0) << 6) | (wbuffer(1) >> 2);                                         // 14 bit
+  pixelbuffer[1] = (((wbuffer(1) & 0x3) << 12) | (wbuffer(2) << 4) | (wbuffer(3) >> 4)) & 0x3fff; // 14 bit
+  pixelbuffer[2] = (wbuffer(3) >> 2) & 0x3;                                                       // 2
+  pixelbuffer[3] = ((wbuffer(3) & 0x3) << 8) | wbuffer(4);                                        // 10
+  pixelbuffer[4] = (wbuffer(5) << 2) | (wbuffer(6) >> 6);                                         // 10
+  pixelbuffer[5] = ((wbuffer(6) & 0x3f) << 4) | (wbuffer(7) >> 4);                                // 10
   pixelbuffer[6] = (wbuffer(7) >> 2) & 0x3;
   pixelbuffer[7] = ((wbuffer(7) & 0x3) << 8) | wbuffer(8);
   pixelbuffer[8] = ((wbuffer(9) << 2) & 0x3fc) | (wbuffer(10) >> 6);
@@ -349,22 +349,70 @@ void pana_cs6_page_decoder::read_page()
   lastoffset += 16;
 }
 
+void pana_cs6_page_decoder::read_page12()
+{
+  if (!buffer || (maxoffset - lastoffset < 16))
+    throw LIBRAW_EXCEPTION_IO_EOF;
+#define wb(i) ((unsigned short)buffer[lastoffset + 15 - i])
+  pixelbuffer[0] = (wb(0) << 4) | (wb(1) >> 4);              // 12 bit: 8/0 + 4 upper bits of /1
+  pixelbuffer[1] = (((wb(1) & 0xf) << 8) | (wb(2))) & 0xfff; // 12 bit: 4l/1 + 8/2
+  
+  pixelbuffer[2] = (wb(3) >> 6) & 0x3;                       // 2; 2u/3, 6 low bits remains in wb(3) 
+  pixelbuffer[3] = ((wb(3) & 0x3f) << 2) | (wb(4) >> 6);     // 8; 6l/3 + 2u/4; 6 low bits remains in wb(4)
+  pixelbuffer[4] = ((wb(4) & 0x3f) << 2) | (wb(5) >> 6);     // 8: 6l/4 + 2u/5; 6 low bits remains in wb(5)
+  pixelbuffer[5] = ((wb(5) & 0x3f) << 2) | (wb(6) >> 6);     // 8: 6l/5 + 2u/6, 6 low bits remains in wb(6)
+
+  pixelbuffer[6] = (wb(6) >> 4) & 0x3;                       // 2, 4 low bits remains in wb(6)
+  pixelbuffer[7] = ((wb(6) & 0xf) << 4) | (wb(7) >> 4);      // 8: 4 low bits from wb(6), 4 upper bits from wb(7)
+  pixelbuffer[8] = ((wb(7) & 0xf) << 4) | (wb(8) >> 4);      // 8: 4 low bits from wb7, 4 upper bits from wb8
+  pixelbuffer[9] = ((wb(8) & 0xf) << 4) | (wb(9) >> 4);      // 8: 4 low bits from wb8, 4 upper bits from wb9
+
+  pixelbuffer[10] = (wb(9) >> 2) & 0x3;                      // 2: bits 2-3 from wb9, two low bits remain in wb9
+  pixelbuffer[11] = ((wb(9) & 0x3) << 6) | (wb(10) >> 2);    // 8: 2 bits from wb9, 6 bits from wb10
+  pixelbuffer[12] = ((wb(10) & 0x3) << 6) | (wb(11) >> 2);   // 8: 2 bits from wb10, 6 bits from wb11
+  pixelbuffer[13] = ((wb(11) & 0x3) << 6) | (wb(12) >> 2);   // 8: 2 bits from wb11, 6 bits from wb12
+
+  pixelbuffer[14] = wb(12) & 0x3;                            // 2: low bits from wb12
+  pixelbuffer[15] = wb(13);
+  pixelbuffer[16] = wb(14);
+  pixelbuffer[17] = wb(15);
+#undef wb
+  current = 0;
+  lastoffset += 16;
+}
+
+
+
 void LibRaw::panasonicC6_load_raw()
 {
   const int rowstep = 16;
-  const int blocksperrow = imgdata.sizes.raw_width / 11;
+  const bool _12bit = libraw_internal_data.unpacker_data.pana_bpp == 12;
+  const int pixperblock =  _12bit ? 14 : 11;
+  const int blocksperrow = imgdata.sizes.raw_width / pixperblock;
   const int rowbytes = blocksperrow * 16;
-  unsigned char *iobuf = (unsigned char *)malloc(rowbytes * rowstep);
-  merror(iobuf, "panasonicC6_load_raw()");
+  const unsigned pixelbase0 = _12bit ? 0x80 : 0x200;
+  const unsigned pixelbase_compare = _12bit ? 0x800 : 0x2000;
+  const unsigned spix_compare = _12bit ? 0x3fff : 0xffff;
+  const unsigned pixel_mask = _12bit ? 0xfff : 0x3fff;
+  std::vector<unsigned char> iobuf;
+  try
+  {
+      iobuf.resize(rowbytes * rowstep);
+  }
+  catch (...)
+  {
+    merror(NULL, "panasonicC6_load_raw()");
+    throw LIBRAW_EXCEPTION_ALLOC;
+  }
 
   for (int row = 0; row < imgdata.sizes.raw_height - rowstep + 1;
        row += rowstep)
   {
     int rowstoread = MIN(rowstep, imgdata.sizes.raw_height - row);
     if (libraw_internal_data.internal_data.input->read(
-            iobuf, rowbytes, rowstoread) != rowstoread)
+            iobuf.data(), rowbytes, rowstoread) != rowstoread)
       throw LIBRAW_EXCEPTION_IO_EOF;
-    pana_cs6_page_decoder page(iobuf, rowbytes * rowstoread);
+    pana_cs6_page_decoder page(iobuf.data(), rowbytes * rowstoread);
     for (int crow = 0, col = 0; crow < rowstoread; crow++, col = 0)
     {
       unsigned short *rowptr =
@@ -372,27 +420,30 @@ void LibRaw::panasonicC6_load_raw()
                .raw_image[(row + crow) * imgdata.sizes.raw_pitch / 2];
       for (int rblock = 0; rblock < blocksperrow; rblock++)
       {
-        page.read_page();
+          if (_12bit)
+              page.read_page12();
+          else
+              page.read_page();
         unsigned oddeven[2] = {0, 0}, nonzero[2] = {0, 0};
         unsigned pmul = 0, pixel_base = 0;
-        for (int pix = 0; pix < 11; pix++)
+        for (int pix = 0; pix < pixperblock; pix++)
         {
           if (pix % 3 == 2)
           {
-            unsigned base = page.nextpixel();
+            unsigned base = _12bit ? page.nextpixel12(): page.nextpixel();
             if (base > 3)
               throw LIBRAW_EXCEPTION_IO_CORRUPT; // not possible b/c of 2-bit
                                                  // field, but....
             if (base == 3)
               base = 4;
-            pixel_base = 0x200 << base;
+            pixel_base = pixelbase0 << base;
             pmul = 1 << base;
           }
-          unsigned epixel = page.nextpixel();
+          unsigned epixel = _12bit ? page.nextpixel12() : page.nextpixel();
           if (oddeven[pix % 2])
           {
             epixel *= pmul;
-            if (pixel_base < 0x2000 && nonzero[pix % 2] > pixel_base)
+            if (pixel_base < pixelbase_compare && nonzero[pix % 2] > pixel_base)
               epixel += nonzero[pix % 2] - pixel_base;
             nonzero[pix % 2] = epixel;
           }
@@ -405,20 +456,20 @@ void LibRaw::panasonicC6_load_raw()
               epixel = nonzero[pix % 2];
           }
           unsigned spix = epixel - 0xf;
-          if (spix <= 0xffff)
-            rowptr[col++] = spix & 0xffff;
+          if (spix <= spix_compare)
+            rowptr[col++] = spix & spix_compare;
           else
           {
             epixel = (((signed int)(epixel + 0x7ffffff1)) >> 0x1f);
-            rowptr[col++] = epixel & 0x3fff;
+            rowptr[col++] = epixel & pixel_mask;
           }
         }
       }
     }
   }
-  free(iobuf);
 }
 
+
 void LibRaw::panasonicC7_load_raw()
 {
   const int rowstep = 16;
@@ -482,7 +533,7 @@ void LibRaw::unpacked_load_raw_fuji_f700s20()
 {
   int base_offset = 0;
   int row_size = imgdata.sizes.raw_width * 2; // in bytes
-  if (imgdata.idata.raw_count == 2 && imgdata.params.shot_select)
+  if (imgdata.idata.raw_count == 2 && imgdata.rawparams.shot_select)
   {
     libraw_internal_data.internal_data.input->seek(-row_size, SEEK_CUR);
     base_offset = row_size; // in bytes
diff --git a/src/decoders/decoders_libraw_dcrdefs.cpp b/src/decoders/decoders_libraw_dcrdefs.cpp
index 78f16068..d36c0e3c 100644
--- a/src/decoders/decoders_libraw_dcrdefs.cpp
+++ b/src/decoders/decoders_libraw_dcrdefs.cpp
@@ -14,6 +14,48 @@
 
 #include "../../internal/dcraw_defs.h"
 
+void LibRaw::sony_ljpeg_load_raw()
+{
+  unsigned trow = 0, tcol = 0, jrow, jcol, row, col;
+  INT64 save;
+  struct jhead jh;
+
+  while (trow < raw_height)
+  {
+    checkCancel();
+    save = ftell(ifp); // We're at
+    if (tile_length < INT_MAX)
+      fseek(ifp, get4(), SEEK_SET);
+    if (!ljpeg_start(&jh, 0))
+      break;
+    try
+    {
+      for (row = jrow = 0; jrow < (unsigned)jh.high; jrow++, row += 2)
+      {
+        checkCancel();
+        ushort(*rowp)[4] = (ushort(*)[4])ljpeg_row(jrow, &jh);
+        for (col = jcol = 0; jcol < (unsigned)jh.wide; jcol++, col += 2)
+        {
+          RAW(trow + row, tcol + col) = rowp[jcol][0];
+          RAW(trow + row, tcol + col + 1) = rowp[jcol][1];
+          RAW(trow + row + 1, tcol + col) = rowp[jcol][2];
+          RAW(trow + row + 1, tcol + col + 1) = rowp[jcol][3];
+        }
+      }
+    }
+    catch (...)
+    {
+      ljpeg_end(&jh);
+      throw;
+    }
+    fseek(ifp, save + 4, SEEK_SET);
+    if ((tcol += tile_width) >= raw_width)
+      trow += tile_length + (tcol = 0);
+    ljpeg_end(&jh);
+  }
+}
+
+
 void LibRaw::nikon_coolscan_load_raw()
 {
   if (!image)
diff --git a/src/decoders/dng.cpp b/src/decoders/dng.cpp
index 7ecbf399..4393ada9 100644
--- a/src/decoders/dng.cpp
+++ b/src/decoders/dng.cpp
@@ -48,7 +48,8 @@ void LibRaw::adobe_copy_pixel(unsigned row, unsigned col, ushort **rp)
 }
 void LibRaw::lossless_dng_load_raw()
 {
-  unsigned save, trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;
+  unsigned trow = 0, tcol = 0, jwide, jrow, jcol, row, col, i, j;
+  INT64 save;
   struct jhead jh;
   ushort *rp;
 
@@ -180,7 +181,8 @@ void LibRaw::lossy_dng_load_raw()
   JSAMPARRAY buf;
   JSAMPLE(*pixel)[3];
   unsigned sorder = order, ntags, opcode, deg, i, j, c;
-  unsigned save = data_offset - 4, trow = 0, tcol = 0, row, col;
+  unsigned trow = 0, tcol = 0, row, col;
+  INT64 save = data_offset - 4;
   ushort cur[3][256];
   double coeff[9], tot;
 
@@ -211,7 +213,7 @@ void LibRaw::lossy_dng_load_raw()
       {
         for (tot = j = 0; j <= deg; j++)
           tot += coeff[j] * pow(i / 255.0, (int)j);
-        cur[c][i] = tot * 0xffff;
+        cur[c][i] = (ushort)(tot * 0xffff);
       }
     }
     order = sorder;
diff --git a/src/decoders/fp_dng.cpp b/src/decoders/fp_dng.cpp
index b5534282..dd34565a 100644
--- a/src/decoders/fp_dng.cpp
+++ b/src/decoders/fp_dng.cpp
@@ -99,7 +99,7 @@ inline void DecodeDeltaBytes(unsigned char *bytePtr, int cols, int channels)
   {
     unsigned char b0 = bytePtr[0];
     bytePtr += 1;
-    for (uint32_t col = 1; col < cols; ++col)
+    for (int col = 1; col < cols; ++col)
     {
       b0 += bytePtr[0];
       bytePtr[0] = b0;
@@ -130,7 +130,7 @@ inline void DecodeDeltaBytes(unsigned char *bytePtr, int cols, int channels)
     unsigned char b2 = bytePtr[2];
     unsigned char b3 = bytePtr[3];
     bytePtr += 4;
-    for (uint32_t col = 1; col < cols; ++col)
+    for (int col = 1; col < cols; ++col)
     {
       b0 += bytePtr[0];
       b1 += bytePtr[1];
@@ -311,14 +311,14 @@ void tile_stripe_data_t::init(tiff_ifd_t *ifd, const libraw_image_sizes_t& sizes
     {
         // ifd->bytes points to tile size table if more than 1 tile exists
         stream->seek(ifd->bytes, SEEK_SET);
-        for (size_t t = 0; t < tileCnt; ++t)
+        for (int t = 0; t < tileCnt; ++t)
         {
             tBytes[t] = static_get4(stream, _order); ;
             maxBytesInTile = MAX(maxBytesInTile, tBytes[t]);
         }
     }
     else if (striped)
-        for (size_t t = 0; t < tileCnt && t < ifd->strip_byte_counts_count; ++t)
+        for (int t = 0; t < tileCnt && t < ifd->strip_byte_counts_count; ++t)
         {
             tBytes[t] = ifd->strip_byte_counts[t];
             maxBytesInTile = MAX(maxBytesInTile, tBytes[t]);
@@ -587,7 +587,7 @@ void swap32(uchar *data, int len)
 void LibRaw::uncompressed_fp_dng_load_raw()
 {
     int iifd = find_ifd_by_offset(libraw_internal_data.unpacker_data.data_offset);
-    if (iifd < 0 || iifd > libraw_internal_data.identify_data.tiff_nifds)
+    if (iifd < 0 || iifd > (int)libraw_internal_data.identify_data.tiff_nifds)
         throw LIBRAW_EXCEPTION_DECODE_RAW;
     struct tiff_ifd_t *ifd = &tiff_ifd[iifd];
 
@@ -620,7 +620,7 @@ void LibRaw::uncompressed_fp_dng_load_raw()
 
     for (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += tiles.tileHeight)
     {
-        for (size_t x = 0; x < imgdata.sizes.raw_width  && t < tiles.tileCnt; x += tiles.tileWidth, ++t)
+        for (unsigned x = 0; x < imgdata.sizes.raw_width  && t < (unsigned)tiles.tileCnt; x += tiles.tileWidth, ++t)
         {
             libraw_internal_data.internal_data.input->seek(tiles.tOffsets[t], SEEK_SET);
             size_t rowsInTile = y + tiles.tileHeight > imgdata.sizes.raw_height ? imgdata.sizes.raw_height - y : tiles.tileHeight;
@@ -629,7 +629,6 @@ void LibRaw::uncompressed_fp_dng_load_raw()
             int inrowbytes = colsInTile * bytesps * ifd->samples;
             int fullrowbytes = tiles.tileWidth *bytesps * ifd->samples;
             int outrowbytes = colsInTile * sizeof(float) * ifd->samples;
-            std::vector<uchar> vec(fullrowbytes > inrowbytes ? fullrowbytes : 0);
 
             for (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed
             {
diff --git a/src/decoders/load_mfbacks.cpp b/src/decoders/load_mfbacks.cpp
index e621f06b..0c11eaf6 100644
--- a/src/decoders/load_mfbacks.cpp
+++ b/src/decoders/load_mfbacks.cpp
@@ -18,11 +18,122 @@
 
 #include "../../internal/dcraw_defs.h"
 
+inline uint32_t abs32(int32_t x)
+{
+  // Branchless version.
+  uint32_t sm = x >> 31;
+  return (uint32_t) ((x + sm) ^ sm);
+}
+
+inline uint32_t min32(uint32_t x, uint32_t y)
+{
+  return x < y ? x : y;
+}
+
+inline uint32_t max32(uint32_t x, uint32_t y)
+{
+  return x > y ? x : y;
+}
+
+inline uint32_t constain32(uint32_t x, uint32_t l, uint32_t u)
+{
+  return x < l ? l : (x > u ? u : x);
+}
+
+int unsigned_cmp(const void *a, const void *b)
+{
+  if (!a || !b)
+    return 0;
+
+  return *(unsigned *)a > *(unsigned *)b ? 1 : (*(unsigned *)a < *(unsigned *)b ? -1 : 0);
+}
+
+int LibRaw::p1rawc(unsigned row, unsigned col, unsigned& count)
+{
+  return (row < raw_height && col < raw_width) ? (++count, RAW(row, col)) : 0;
+}
+
 int LibRaw::p1raw(unsigned row, unsigned col)
 {
   return (row < raw_height && col < raw_width) ? RAW(row, col) : 0;
 }
 
+
+// DNG SDK version of fixing pixels in bad column using averages sets
+// corrected not to use pixels in the same column
+void LibRaw::phase_one_fix_col_pixel_avg(unsigned row, unsigned col)
+{
+  static const int8_t dir[3][8][2] = {
+  { {-2,-2}, {-2, 2}, {2,-2}, {2, 2}, { 0, 0}, { 0, 0}, {0, 0}, {0, 0} },
+  { {-2,-4}, {-4,-2}, {2,-4}, {4,-2}, {-2, 4}, {-4, 2}, {2, 4}, {4, 2} },
+  { {-4,-4}, {-4, 4}, {4,-4}, {4, 4}, { 0, 0}, { 0, 0}, {0, 0}, {0, 0} } };
+
+  for (int set=0; set < 3; ++set)
+  {
+    uint32_t total = 0;
+    uint32_t count = 0;
+    for (int i = 0; i < 8; ++i)
+    {
+      if (!dir[set][i][0] && !dir[set][i][1])
+        break;
+
+      total += p1rawc(row+dir[set][i][0], col+dir[set][i][1], count);
+    }
+
+    if (count)
+    {
+      RAW(row,col) = (uint16_t)((total + (count >> 1)) / count);
+      break;
+    }
+  }
+}
+
+// DNG SDK version of fixing pixels in bad column using gradient prediction
+void LibRaw::phase_one_fix_pixel_grad(unsigned row, unsigned col)
+{
+  static const int8_t grad_sets[7][12][2] = {
+    { {-4,-2}, { 4, 2}, {-3,-1}, { 1, 1}, {-1,-1}, { 3, 1}, 
+      {-4,-1}, { 0, 1}, {-2,-1}, { 2, 1}, { 0,-1}, { 4, 1} },
+    { {-2,-2}, { 2, 2}, {-3,-1}, {-1, 1}, {-1,-1}, { 1, 1}, 
+      { 1,-1}, { 3, 1}, {-2,-1}, { 0, 1}, { 0,-1}, { 2, 1} },
+    { {-2,-4}, { 2, 4}, {-1,-3}, { 1, 1}, {-1,-1}, { 1, 3}, 
+      {-2,-1}, { 0, 3}, {-1,-2}, { 1, 2}, { 0,-3}, { 2, 1} },
+    { { 0,-2}, { 0, 2}, {-1,-1}, {-1, 1}, { 1,-1}, { 1, 1}, 
+      {-1,-2}, {-1, 2}, { 0,-1}, { 0,-1}, { 1,-2}, { 1, 2} },
+    { {-2, 4}, { 2,-4}, {-1, 3}, { 1,-1}, {-1, 1}, { 1,-3}, 
+      {-2, 1}, { 0,-3}, {-1, 2}, { 1,-2}, { 0, 3}, { 2,-1} },
+    { {-2, 2}, { 2,-2}, {-3, 1}, {-1,-1}, {-1, 1}, { 1,-1}, 
+      { 1, 1}, { 3,-1}, {-2, 1}, { 0,-1}, { 0, 1}, { 2,-1} },
+    { {-4, 2}, { 4,-2}, {-3, 1}, { 1,-1}, {-1, 1}, { 3,-1}, 
+      {-4, 1}, { 0,-1}, {-2, 1}, { 2,-1}, { 0, 1}, { 4,-1} } };
+
+  uint32_t est[7], grad[7];
+  uint32_t lower = min32(p1raw(row,col-2), p1raw(row, col+2));
+  uint32_t upper = max32(p1raw(row,col-2), p1raw(row, col+2));
+  uint32_t minGrad = 0xFFFFFFFF;
+  for (int i = 0; i<7; ++i)
+  {
+    est[i] = p1raw(row+grad_sets[i][0][0], col+grad_sets[i][0][1]) +
+             p1raw(row+grad_sets[i][1][0], col+grad_sets[i][1][1]);
+    grad[i] = 0;
+    for (int j=0; j<12; j+=2)
+      grad[i] += abs32(p1raw(row+grad_sets[i][j][0], col+grad_sets[i][j][1]) -
+                       p1raw(row+grad_sets[i][j+1][0], col+grad_sets[i][j+1][1]));
+    minGrad = min32(minGrad, grad[i]);
+  }
+
+  uint32_t limit = (minGrad * 3) >> 1;
+  uint32_t total = 0;
+  uint32_t count = 0;
+  for (int i = 0; i<7; ++i)
+    if (grad[i] <= limit)
+    {
+      total += est[i];
+      count += 2;
+    }
+  RAW(row, col) = constain32((total + (count >> 1)) / count, lower, upper);
+}
+
 void LibRaw::phase_one_flat_field(int is_float, int nc)
 {
   ushort head[8];
@@ -88,7 +199,10 @@ void LibRaw::phase_one_flat_field(int is_float, int nc)
 int LibRaw::phase_one_correct()
 {
   unsigned entries, tag, data, save, col, row, type;
-  int len, i, j, k, cip, val[4], dev[4], sum, max;
+  int len, i, j, k, cip, sum;
+#if 0
+  int val[4], dev[4], max;
+#endif
   int head[9], diff, mindiff = INT_MAX, off_412 = 0;
   /* static */ const signed char dir[12][2] = {
       {-1, -1}, {-1, 1}, {1, -1},  {1, 1},  {-2, 0}, {0, -2},
@@ -96,6 +210,7 @@ int LibRaw::phase_one_correct()
   float poly[8], num, cfrac, frac, mult[2], *yval[2] = {NULL, NULL};
   ushort *xval[2];
   int qmult_applied = 0, qlin_applied = 0;
+  std::vector<unsigned> badCols;
 
   if (!meta_length)
     return 0;
@@ -116,37 +231,7 @@ int LibRaw::phase_one_correct()
       data = get4();
       save = ftell(ifp);
       fseek(ifp, meta_offset + data, SEEK_SET);
-      if (tag == 0x0419)
-      { /* Polynomial curve */
-        for (get4(), i = 0; i < 8; i++)
-          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
-        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;
-        for (i = 0; i < 0x10000; i++)
-        {
-          num = (poly[5] * i + poly[3]) * i + poly[1];
-          curve[i] = LIM(num, 0, 65535);
-        }
-        goto apply; /* apply to right half */
-      }
-      else if (tag == 0x041a)
-      { /* Polynomial curve */
-        for (i = 0; i < 4; i++)
-          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
-        for (i = 0; i < 0x10000; i++)
-        {
-          for (num = 0, j = 4; j--;)
-            num = num * i + poly[j];
-          curve[i] = LIM(num + i, 0, 65535);
-        }
-      apply: /* apply to whole image */
-        for (row = 0; row < raw_height; row++)
-        {
-          checkCancel();
-          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)
-            RAW(row, col) = curve[RAW(row, col)];
-        }
-      }
-      else if (tag == 0x0400)
+      if (tag == 0x0400)
       { /* Sensor defects */
         while ((len -= 8) >= 0)
         {
@@ -157,8 +242,15 @@ int LibRaw::phase_one_correct()
           if (col >= raw_width)
             continue;
           if (type == 131 || type == 137) /* Bad column */
+#if 0
+            // Original code by Dave Coffin - it works better by
+            // not employing special logic for G1 channel below.
+            // Alternatively this column remap (including G1 channel
+            // logic) should be called prior to black subtraction
+            // unlike other corrections
             for (row = 0; row < raw_height; row++)
-              if (FC(row - top_margin, col - left_margin) == 1)
+            {
+              if (FC(row - top_margin, col - left_margin)==1)
               {
                 for (sum = i = 0; i < 4; i++)
                   sum += val[i] = p1raw(row + dir[i][0], col + dir[i][1]);
@@ -175,30 +267,68 @@ int LibRaw::phase_one_correct()
                 for (sum = 0, i = 8; i < 12; i++)
                   sum += p1raw(row + dir[i][0], col + dir[i][1]);
                 RAW(row, col) =
-                    0.5 + sum * 0.0732233 +
-                    (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;
+                  0.5 + sum * 0.0732233 +
+                  (p1raw(row, col - 2) + p1raw(row, col + 2)) * 0.3535534;
               }
+            }
+#else
+            // accumulae bad columns to be sorted later
+            badCols.push_back(col);
+#endif
           else if (type == 129)
           { /* Bad pixel */
             if (row >= raw_height)
               continue;
             j = (FC(row - top_margin, col - left_margin) != 1) * 4;
+            unsigned count = 0;
             for (sum = 0, i = j; i < j + 8; i++)
-              sum += p1raw(row + dir[i][0], col + dir[i][1]);
-            RAW(row, col) = (sum + 4) >> 3;
+              sum += p1rawc(row + dir[i][0], col + dir[i][1], count);
+            if (count)
+              RAW(row, col) = (sum + (count >> 1)) / count;
           }
         }
       }
+      else if (tag == 0x0419)
+      { /* Polynomial curve - output calibraion */
+        for (get4(), i = 0; i < 8; i++)
+          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+        poly[3] += (ph1.tag_210 - poly[7]) * poly[6] + 1;
+        for (i = 0; i < 0x10000; i++)
+        {
+          num = (poly[5] * i + poly[3]) * i + poly[1];
+          curve[i] = LIM(num, 0, 65535);
+        }
+        goto apply; /* apply to right half */
+      }
+      else if (tag == 0x041a)
+      { /* Polynomial curve */
+        for (i = 0; i < 4; i++)
+          poly[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+        for (i = 0; i < 0x10000; i++)
+        {
+          for (num = 0, j = 4; j--;)
+            num = num * i + poly[j];
+          curve[i] = LIM(num + i, 0, 65535);
+        }
+      apply: /* apply to whole image */
+        for (row = 0; row < raw_height; row++)
+        {
+          checkCancel();
+          for (col = (tag & 1) * ph1.split_col; col < raw_width; col++)
+            RAW(row, col) = curve[RAW(row, col)];
+        }
+      }
       else if (tag == 0x0401)
-      { /* All-color flat fields */
+      { /* All-color flat fields - luma calibration*/
         phase_one_flat_field(1, 2);
       }
       else if (tag == 0x0416 || tag == 0x0410)
       {
+        // 0x410 - luma calibration
         phase_one_flat_field(0, 2);
       }
       else if (tag == 0x040b)
-      { /* Red+blue flat field */
+      { /* Red+blue flat field - croma calibration */
         phase_one_flat_field(0, 4);
       }
       else if (tag == 0x0412)
@@ -255,7 +385,7 @@ int LibRaw::phase_one_correct()
         qlin_applied = 1;
       }
       else if (tag == 0x041e && !qmult_applied)
-      { /* Quadrant multipliers */
+      { /* Quadrant multipliers - output calibraion */
         float qmult[2][2] = {{1, 1}, {1, 1}};
         get4();
         get4();
@@ -289,7 +419,7 @@ int LibRaw::phase_one_correct()
         qmult_applied = 1;
       }
       else if (tag == 0x0431 && !qmult_applied)
-      { /* Quadrant combined */
+      { /* Quadrant combined - four tile gain calibration */
         ushort lc[2][2][7], ref[7];
         int qr, qc;
         for (i = 0; i < 7; i++)
@@ -326,6 +456,21 @@ int LibRaw::phase_one_correct()
       }
       fseek(ifp, save, SEEK_SET);
     }
+    if (!badCols.empty())
+    {
+      qsort(badCols.data(), badCols.size(), sizeof(unsigned), unsigned_cmp);
+      bool prevIsolated = true;
+      for (i = 0; i < (int)badCols.size(); ++i)
+      {
+        bool nextIsolated = i == ((int)(badCols.size()-1)) || badCols[i+1]>badCols[i]+4;
+        for (row = 0; row < raw_height; ++row)
+          if (prevIsolated && nextIsolated)
+            phase_one_fix_pixel_grad(row,badCols[i]);
+          else
+            phase_one_fix_col_pixel_avg(row,badCols[i]);
+        prevIsolated = nextIsolated;
+      }
+    }
     if (off_412)
     {
       fseek(ifp, off_412, SEEK_SET);
@@ -540,7 +685,8 @@ void LibRaw::phase_one_load_raw_c()
 void LibRaw::hasselblad_load_raw()
 {
   struct jhead jh;
-  int shot, row, col, *back[5], len[2], diff[12], pred, sh, f, c;
+  int shot, row, col, *back[5]={0,0,0,0,0},
+ 	 len[2], diff[12], pred, sh, f, c;
   unsigned s;
   unsigned upix, urow, ucol;
   ushort *ip;
@@ -609,11 +755,13 @@ void LibRaw::hasselblad_load_raw()
   }
   catch (...)
   {
-    free(back[4]);
+    if(back[4])
+    	free(back[4]);
     ljpeg_end(&jh);
     throw;
   }
-  free(back[4]);
+  if(back[4])
+    free(back[4]);
   ljpeg_end(&jh);
   if (image)
     mix_green = 1;
diff --git a/src/decoders/unpack.cpp b/src/decoders/unpack.cpp
index fcdbbfec..acc6a584 100644
--- a/src/decoders/unpack.cpp
+++ b/src/decoders/unpack.cpp
@@ -25,7 +25,7 @@ int LibRaw::unpack(void)
       return LIBRAW_INPUT_CLOSED;
 
     RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW, 0, 2);
-    if (O.shot_select >= P1.raw_count)
+    if (imgdata.rawparams.shot_select >= P1.raw_count)
       return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;
 
     if (!load_raw)
@@ -137,6 +137,10 @@ int LibRaw::unpack(void)
            !strncasecmp(imgdata.idata.model, "COOLPIX P1000", 13)))
         rawspeed_enabled = 0;
 
+      if (load_raw == &LibRaw::nikon_load_raw && makeIs(LIBRAW_CAMERAMAKER_Nikon) &&
+          !strcasecmp(imgdata.idata.model, "D6"))
+        rawspeed_enabled = 0;
+
 	if (load_raw == &LibRaw::lossless_jpeg_load_raw &&
 		MN.canon.RecordMode && makeIs(LIBRAW_CAMERAMAKER_Kodak) &&
 		/* Not normalized models here, it is intentional */
@@ -187,7 +191,7 @@ int LibRaw::unpack(void)
       }
       if (decoder_info.decoder_flags & LIBRAW_DECODER_SINAR4SHOT)
       {
-        if (imgdata.params.shot_select) // single image extract
+        if (imgdata.rawparams.shot_select) // single image extract
         {
           if (INT64(rwidth) * INT64(rheight + 8) *
                   sizeof(imgdata.rawdata.raw_image[0]) >
@@ -296,7 +300,7 @@ int LibRaw::unpack(void)
         // x3f foveon decoder only: do nothing
       }
       else if (decoder_info.decoder_flags & LIBRAW_DECODER_SINAR4SHOT &&
-               imgdata.params.shot_select == 0)
+               imgdata.rawparams.shot_select == 0)
       {
         imgdata.rawdata.raw_alloc = imgdata.image;
         imgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;
diff --git a/src/decoders/unpack_thumb.cpp b/src/decoders/unpack_thumb.cpp
index 2b7ed328..4626ee17 100644
--- a/src/decoders/unpack_thumb.cpp
+++ b/src/decoders/unpack_thumb.cpp
@@ -35,14 +35,14 @@ int LibRaw::unpack_thumb(void)
 
 #define THUMB_SIZE_CHECKT(A) \
   do { \
-    if (INT64(A) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \
-    if (INT64(A) > 0 &&  INT64(A) < 64ULL)        return LIBRAW_NO_THUMBNAIL; \
+    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \
+    if (INT64(A) > 0 &&  INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \
   } while (0)
 
 #define THUMB_SIZE_CHECKTNZ(A) \
   do { \
-    if (INT64(A) > 1024ULL * 1024ULL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \
-    if (INT64(A) < 64ULL)        return LIBRAW_NO_THUMBNAIL; \
+    if (INT64(A) > 1024LL * 1024LL * LIBRAW_MAX_THUMBNAIL_MB) return LIBRAW_UNSUPPORTED_THUMBNAIL; \
+    if (INT64(A) < 64LL)        return LIBRAW_NO_THUMBNAIL; \
   } while (0)
 
 
@@ -61,7 +61,12 @@ int LibRaw::unpack_thumb(void)
     int t_bytesps = (libraw_internal_data.unpacker_data.thumb_misc & 31) / 8;
 
     if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&
-                         load_raw == &LibRaw::broadcom_load_raw) // RPi
+                         load_raw == &LibRaw::broadcom_load_raw)  // RPi
+#ifdef USE_6BY9RPI
+        && !(imgdata.thumbnail.tlength > 0 && libraw_internal_data.unpacker_data.load_flags & 0x4000
+            && (load_raw == &LibRaw::rpi_load_raw8 || load_raw == &LibRaw::nokia_load_raw ||
+           load_raw == &LibRaw::rpi_load_raw12 || load_raw == &LibRaw::rpi_load_raw14))
+#endif
     )
     {
       return LIBRAW_NO_THUMBNAIL;
diff --git a/src/demosaic/xtrans_demosaic.cpp b/src/demosaic/xtrans_demosaic.cpp
index f0a2eb73..6e17364c 100644
--- a/src/demosaic/xtrans_demosaic.cpp
+++ b/src/demosaic/xtrans_demosaic.cpp
@@ -34,7 +34,7 @@ void LibRaw::xtrans_interpolate(int passes)
                      dir[4] = {1, LIBRAW_AHD_TILE, LIBRAW_AHD_TILE + 1,
                                LIBRAW_AHD_TILE - 1};
   short allhex[3][3][2][8];
-  ushort sgrow, sgcol;
+  ushort sgrow = 0, sgcol = 0;
 
   if (width < LIBRAW_AHD_TILE || height < LIBRAW_AHD_TILE)
     throw LIBRAW_EXCEPTION_IO_CORRUPT; // too small image
diff --git a/src/integration/dngsdk_glue.cpp b/src/integration/dngsdk_glue.cpp
index 10c05551..ed9aab69 100644
--- a/src/integration/dngsdk_glue.cpp
+++ b/src/integration/dngsdk_glue.cpp
@@ -83,6 +83,10 @@ int LibRaw::valid_for_dngsdk()
   if (!imgdata.idata.dng_version)
     return 0;
 
+  // All DNG larger than 2GB - to DNG SDK
+  if (libraw_internal_data.internal_data.input->size() > 2147483647ULL)
+      return 1;
+
   if (!strcasecmp(imgdata.idata.make, "Blackmagic") 
       && (libraw_internal_data.unpacker_data.tiff_compress == 7)
       && (libraw_internal_data.unpacker_data.tiff_bps > 8)
diff --git a/src/metadata/canon.cpp b/src/metadata/canon.cpp
index df6a4678..a8c86696 100644
--- a/src/metadata/canon.cpp
+++ b/src/metadata/canon.cpp
@@ -15,11 +15,20 @@
 #include "../../internal/dcraw_defs.h"
 #include "../../internal/libraw_cameraids.h"
 
+libraw_area_t LibRaw::get_CanonArea() {
+  libraw_area_t la = {};
+  la.l = get2();
+  la.t = get2();
+  la.r = get2();
+  la.b = get2();
+  return la;
+}
+
 float LibRaw::_CanonConvertAperture(ushort in)
 {
   if ((in == (ushort)0xffe0) || (in == (ushort)0x7fff))
     return 0.0f;
-  return LibRaw::libraw_powf64l(2.0, in / 64.0);
+  return LibRaw::libraw_powf64l(2.f, float(in) / 64.f);
 }
 
 static float _CanonConvertEV(short in)
@@ -85,21 +94,23 @@ void LibRaw::setCanonBodyFeatures(unsigned long long id)
     ilm.CameraFormat = LIBRAW_FORMAT_FF;
     ilm.CameraMount = LIBRAW_MOUNT_Canon_EF;
   }
-  else if ((id == CanonID_EOS_M)         ||
-           (id == CanonID_EOS_M2)        ||
-           (id == CanonID_EOS_M3)        ||
-           (id == CanonID_EOS_M10)       ||
-           (id == CanonID_EOS_M5)        ||
-           (id == CanonID_EOS_M50)       ||
-           (id == CanonID_EOS_M6)        ||
-           (id == CanonID_EOS_M100)      ||
-           (id == CanonID_EOS_M6_Mark_II))
+  else if ((id == CanonID_EOS_M)             ||
+           (id == CanonID_EOS_M2)            ||
+           (id == CanonID_EOS_M3)            ||
+           (id == CanonID_EOS_M5)            ||
+           (id == CanonID_EOS_M10)           ||
+           (id == CanonID_EOS_M50)           ||
+           (id == CanonID_EOS_M50_Mark_II)   ||
+           (id == CanonID_EOS_M6)            ||
+           (id == CanonID_EOS_M6_Mark_II)    ||
+           (id == CanonID_EOS_M100))
   {
     ilm.CameraFormat = LIBRAW_FORMAT_APSC;
     ilm.CameraMount = LIBRAW_MOUNT_Canon_EF_M;
   }
   else if ((id == CanonID_EOS_R)  ||
            (id == CanonID_EOS_RP) ||
+           (id == CanonID_EOS_R3) ||
            (id == CanonID_EOS_R6) ||
            (id == CanonID_EOS_R5))
   {
@@ -115,51 +126,56 @@ void LibRaw::setCanonBodyFeatures(unsigned long long id)
   }
 }
 
+int CanonCameraInfo_checkFirmwareRecordLocation (uchar *offset) {
+// firmware record location allows
+// to determine the subversion of the CameraInfo table
+// and to adjust offsets accordingly 
+  if (isdigit(*offset)   && 
+      isdigit(*offset+2) &&
+      isdigit(*offset+4) &&
+      (*(offset+1) == '.') &&
+      (*(offset+3) == '.') &&
+      (*(offset+5) == 0)) return 1;
+  else return 0; // error
+}
+
 void LibRaw::processCanonCameraInfo(unsigned long long id, uchar *CameraInfo,
                                     unsigned maxlen, unsigned type, unsigned dng_writer)
 {
   ushort iCanonLensID = 0, iCanonMaxFocal = 0, iCanonMinFocal = 0,
          iCanonLens = 0, iCanonCurFocal = 0, iCanonFocalType = 0,
+         iMakernotesFlip = 0,
          iHTP = 0, iALO = 0;
+  short SubVersion_offset = 0;
+  ushort SubVersion = 0, mgck = 0;
 
   if (maxlen < 16)
     return; // too short
 
- if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED) &&
-     (sget2(CameraInfo) == 0xaaaa) && (dng_writer == nonDNG)) { // CameraOrientation
-    int c, i;
-    for (c = i = 2; (ushort)c != 0xbbbb && i < (int)maxlen; i++)
-      c = c << 8 | CameraInfo[i];
-    while (i < int(maxlen - 5))
-      if ((sget4(CameraInfo+i) == 257) && ((c = CameraInfo[i+8]) < 3)) {
-        imCanon.MakernotesFlip = "065"[c] - '0';
-        break;
-      } else i+=4;
-  }
-
+  mgck = sget2(CameraInfo);
   CameraInfo[0] = 0;
   CameraInfo[1] = 0;
   if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG)) {
     if ((maxlen == 94)  || (maxlen == 138) || (maxlen == 148) ||
         (maxlen == 156) || (maxlen == 162) || (maxlen == 167) ||
         (maxlen == 171) || (maxlen == 264) || (maxlen > 400))
-      imCommon.CameraTemperature = sget4(CameraInfo + ((maxlen - 3) << 2));
+      imCommon.CameraTemperature = float(sget4(CameraInfo + ((maxlen - 3) << 2)));
     else if (maxlen == 72)
-      imCommon.CameraTemperature = sget4(CameraInfo + ((maxlen - 1) << 2));
+      imCommon.CameraTemperature = float(sget4(CameraInfo + ((maxlen - 1) << 2)));
     else if ((maxlen == 85) || (maxlen == 93))
-      imCommon.CameraTemperature = sget4(CameraInfo + ((maxlen - 2) << 2));
+      imCommon.CameraTemperature = float(sget4(CameraInfo + ((maxlen - 2) << 2)));
     else if ((maxlen == 96) || (maxlen == 104))
-      imCommon.CameraTemperature = sget4(CameraInfo + ((maxlen - 4) << 2));
+      imCommon.CameraTemperature = float(sget4(CameraInfo + ((maxlen - 4) << 2)));
   }
 
   switch (id)
   {
   case CanonID_EOS_1D:
   case CanonID_EOS_1Ds:
-    iCanonCurFocal = 10;
-    iCanonLensID = 13;
-    iCanonMinFocal = 14;
-    iCanonMaxFocal = 16;
+    iCanonCurFocal  =  0x0a;
+    iCanonLensID    =  0x0d;
+    iCanonMinFocal  =  0x0e;
+    iCanonMaxFocal  =  0x10;
     if (!ilm.CurFocal)
       ilm.CurFocal = sget2(CameraInfo + iCanonCurFocal);
     if (!ilm.MinFocal)
@@ -168,146 +184,293 @@ void LibRaw::processCanonCameraInfo(unsigned long long id, uchar *CameraInfo,
       ilm.MaxFocal = sget2(CameraInfo + iCanonMaxFocal);
     imCommon.CameraTemperature = 0.0f;
     break;
+
   case CanonID_EOS_1D_Mark_II:
   case CanonID_EOS_1Ds_Mark_II:
-    iCanonCurFocal = 9;
-    iCanonLensID = 12;
-    iCanonMinFocal = 17;
-    iCanonMaxFocal = 19;
-    iCanonFocalType = 45;
+    iCanonCurFocal  =  0x09;
+    iCanonLensID    =  0x0c;
+    iCanonMinFocal  =  0x11;
+    iCanonMaxFocal  =  0x13;
+    iCanonFocalType =  0x2d;
     break;
+
   case CanonID_EOS_1D_Mark_II_N:
-    iCanonCurFocal = 9;
-    iCanonLensID = 12;
-    iCanonMinFocal = 17;
-    iCanonMaxFocal = 19;
+    iCanonCurFocal  =  0x09;
+    iCanonLensID    =  0x0c;
+    iCanonMinFocal  =  0x11;
+    iCanonMaxFocal  =  0x13;
     break;
+
   case CanonID_EOS_1D_Mark_III:
   case CanonID_EOS_1Ds_Mark_III:
-    iCanonCurFocal = 29;
-    iCanonLensID = 273;
-    iCanonMinFocal = 275;
-    iCanonMaxFocal = 277;
+    iCanonCurFocal  =  0x1d;
+    iMakernotesFlip =  0x30;
+    iCanonLensID    = 0x111;
+    iCanonMinFocal  = 0x113;
+    iCanonMaxFocal  = 0x115;
     break;
+
   case CanonID_EOS_1D_Mark_IV:
-    iHTP = 7;
-    iCanonCurFocal = 30;
-    iCanonLensID = 335;
-    iCanonMinFocal = 337;
-    iCanonMaxFocal = 339;
+    if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x1e8))
+      SubVersion = 1;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x1ed))
+      SubVersion = 2;
+// printf ("==>> CanonID_EOS_1D_Mark_IV, SubVersion: %d\n", SubVersion);
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x35;
+
+    if (!SubVersion)
+      break;
+    else if (SubVersion < 2)
+      SubVersion_offset += -1;
+
+    iCanonLensID    = 0x14f+SubVersion_offset;
+    iCanonMinFocal  = 0x151+SubVersion_offset;
+    iCanonMaxFocal  = 0x153+SubVersion_offset;
     break;
+
   case CanonID_EOS_1D_X:
-    iCanonCurFocal = 35;
-    iCanonLensID = 423;
-    iCanonMinFocal = 425;
-    iCanonMaxFocal = 427;
+    if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x271))
+      SubVersion = 1;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x279))
+      SubVersion = 2;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x280))
+      SubVersion = 3;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x285))
+      SubVersion = 4;
+// printf ("==>> CanonID_EOS_1D_X, SubVersion: %d\n", SubVersion);
+
+    if (SubVersion < 3)
+      SubVersion_offset += -3;
+
+    iCanonCurFocal  =  0x23+SubVersion_offset;
+    iMakernotesFlip =  0x7d+SubVersion_offset;
+
+    if (SubVersion < 3)
+      SubVersion_offset += -4;
+    else if (SubVersion == 4)
+      SubVersion_offset += 5;
+
+    iCanonLensID    = 0x1a7+SubVersion_offset;
+    iCanonMinFocal  = 0x1a9+SubVersion_offset;
+    iCanonMaxFocal  = 0x1ab+SubVersion_offset;
     break;
+
   case CanonID_EOS_5D:
-    iCanonCurFocal = 40;
-    if (!sget2Rev(CameraInfo + 12))
-      iCanonLensID = 151;
-    else
-      iCanonLensID = 12;
-    iCanonMinFocal = 147;
-    iCanonMaxFocal = 149;
+    iMakernotesFlip =  0x27;
+    iCanonCurFocal  =  0x28;
+    iCanonLensID    =  0x0c;
+    if (!sget2Rev(CameraInfo + iCanonLensID))
+      iCanonLensID  =  0x97;
+    iCanonMinFocal  =  0x93;
+    iCanonMaxFocal  =  0x95;
     break;
+
   case CanonID_EOS_5D_Mark_II:
-    iHTP = 7;
-    iALO = 191;
-    iCanonCurFocal = 30;
-    iCanonLensID = 230;
-    iCanonMinFocal = 232;
-    iCanonMaxFocal = 234;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x31;
+    iALO            =  0xbf;
+    iCanonLensID    =  0xe6;
+    iCanonMinFocal  =  0xe8;
+    iCanonMaxFocal  =  0xea;
     break;
+
   case CanonID_EOS_5D_Mark_III:
-    iCanonCurFocal = 35;
-    iCanonLensID = 339;
-    iCanonMinFocal = 341;
-    iCanonMaxFocal = 343;
+    if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x22c))
+      SubVersion = 1;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x22d))
+      SubVersion = 2;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x23c))
+      SubVersion = 3;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x242))
+      SubVersion = 4;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x247))
+      SubVersion = 5;
+// printf ("==>> CanonID_EOS_5D_Mark_III, SubVersion: %d\n", SubVersion);
+
+    if (!SubVersion)
+      break;
+    else if (SubVersion < 3)
+      SubVersion_offset += -1;
+
+    iCanonCurFocal  =  0x23+SubVersion_offset;
+
+    if (SubVersion == 1)
+      SubVersion_offset += -3;
+    else if (SubVersion == 2)
+      SubVersion_offset += -2;
+    else if (SubVersion >= 4)
+      SubVersion_offset += 6;
+
+    iMakernotesFlip =  0x7d+SubVersion_offset;
+
+    if (SubVersion < 3)
+      SubVersion_offset += -4;
+    else if (SubVersion > 4)
+      SubVersion_offset += 5;
+
+    iCanonLensID    = 0x153+SubVersion_offset;
+    iCanonMinFocal  = 0x155+SubVersion_offset;
+    iCanonMaxFocal  = 0x157+SubVersion_offset;
     break;
+
   case CanonID_EOS_6D:
-    iCanonCurFocal = 35;
-    iCanonLensID = 353;
-    iCanonMinFocal = 355;
-    iCanonMaxFocal = 357;
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x83;
+    iCanonLensID    = 0x161;
+    iCanonMinFocal  = 0x163;
+    iCanonMaxFocal  = 0x165;
     break;
+
   case CanonID_EOS_7D:
-    iHTP = 7;
-    iCanonCurFocal = 30;
-    iCanonLensID = 274;
-    iCanonMinFocal = 276;
-    iCanonMaxFocal = 278;
+    if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x1a8))
+      SubVersion = 1;
+    else if (CanonCameraInfo_checkFirmwareRecordLocation(CameraInfo + 0x1ac))
+      SubVersion = 2;
+// printf ("==>> CanonID_EOS_7D, SubVersion: %d\n", SubVersion);
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+
+    if (!SubVersion)
+      break;
+    else if (SubVersion < 2)
+      SubVersion_offset += -4;
+
+    iMakernotesFlip =  0x35+SubVersion_offset;
+    iCanonLensID    = 0x112+SubVersion_offset;
+    iCanonMinFocal  = 0x114+SubVersion_offset;
+    iCanonMaxFocal  = 0x116+SubVersion_offset;
     break;
+
   case CanonID_EOS_40D:
-    iCanonCurFocal = 29;
-    iCanonLensID = 214;
-    iCanonMinFocal = 216;
-    iCanonMaxFocal = 218;
-    iCanonLens = 2347;
+    iCanonCurFocal  =  0x1d;
+    iMakernotesFlip =  0x30;
+    iCanonLensID    =  0xd6;
+    iCanonMinFocal  =  0xd8;
+    iCanonMaxFocal  =  0xda;
+    iCanonLens      = 0x92b;
     break;
+
   case CanonID_EOS_50D:
-    iHTP = 7;
-    iALO = 191;
-    iCanonCurFocal = 30;
-    iCanonLensID = 234;
-    iCanonMinFocal = 236;
-    iCanonMaxFocal = 238;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x31;
+    iALO            =  0xbf;
+    iCanonLensID    =  0xea;
+    iCanonMinFocal  =  0xec;
+    iCanonMaxFocal  =  0xee;
     break;
+
   case CanonID_EOS_60D:
-    iCanonCurFocal = 30;
-    iCanonLensID = 232;
-    iCanonMinFocal = 234;
-    iCanonMaxFocal = 236;
+  case CanonID_EOS_1200D:
+    iCanonCurFocal  =  0x1e;
+    if (id == CanonID_EOS_60D)
+      iMakernotesFlip =  0x36;
+    else
+      iMakernotesFlip =  0x3a;
+    iCanonLensID    =  0xe8;
+    iCanonMinFocal  =  0xea;
+    iCanonMaxFocal  =  0xec;
     break;
+
   case CanonID_EOS_70D:
-    iCanonCurFocal = 35;
-    iCanonLensID = 358;
-    iCanonMinFocal = 360;
-    iCanonMaxFocal = 362;
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x84;
+    iCanonLensID    = 0x166;
+    iCanonMinFocal  = 0x168;
+    iCanonMaxFocal  = 0x16a;
     break;
+
+  case CanonID_EOS_80D:
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x96;
+    iCanonLensID    = 0x189;
+    iCanonMinFocal  = 0x18b;
+    iCanonMaxFocal  = 0x18d;
+    break;
+
   case CanonID_EOS_450D:
-    iCanonCurFocal = 29;
-    iCanonLensID = 222;
-    iCanonLens = 2355;
+    iCanonCurFocal  =  0x1d;
+    iMakernotesFlip =  0x30;
+    iCanonLensID    =  0xde;
+    iCanonLens      = 0x933;
     break;
+
   case CanonID_EOS_500D:
-    iHTP = 7;
-    iALO = 190;
-    iCanonCurFocal = 30;
-    iCanonLensID = 246;
-    iCanonMinFocal = 248;
-    iCanonMaxFocal = 250;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x31;
+    iALO            =  0xbe;
+    iCanonLensID    =  0xf6;
+    iCanonMinFocal  =  0xf8;
+    iCanonMaxFocal  =  0xfa;
     break;
+
   case CanonID_EOS_550D:
-    iHTP = 7;
-    iCanonCurFocal = 30;
-    iCanonLensID = 255;
-    iCanonMinFocal = 257;
-    iCanonMaxFocal = 259;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x35;
+    iCanonLensID    =  0xff;
+    iCanonMinFocal  = 0x101;
+    iCanonMaxFocal  = 0x103;
     break;
+
   case CanonID_EOS_600D:
   case CanonID_EOS_1100D:
-    iHTP = 7;
-    iCanonCurFocal = 30;
-    iCanonLensID = 234;
-    iCanonMinFocal = 236;
-    iCanonMaxFocal = 238;
+    iHTP            =  0x07;
+    iCanonCurFocal  =  0x1e;
+    iMakernotesFlip =  0x38;
+    iCanonLensID    =  0xea;
+    iCanonMinFocal  =  0xec;
+    iCanonMaxFocal  =  0xee;
     break;
+
   case CanonID_EOS_650D:
   case CanonID_EOS_700D:
-    iCanonCurFocal = 35;
-    iCanonLensID = 295;
-    iCanonMinFocal = 297;
-    iCanonMaxFocal = 299;
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x7d;
+    iCanonLensID    = 0x127;
+    iCanonMinFocal  = 0x129;
+    iCanonMaxFocal  = 0x12b;
+    break;
+
+  case CanonID_EOS_750D:
+  case CanonID_EOS_760D:
+    iCanonCurFocal  =  0x23;
+    iMakernotesFlip =  0x96;
+    iCanonLensID    = 0x184;
+    iCanonMinFocal  = 0x186;
+    iCanonMaxFocal  = 0x188;
     break;
+
   case CanonID_EOS_1000D:
-    iCanonCurFocal = 29;
-    iCanonLensID = 226;
-    iCanonMinFocal = 228;
-    iCanonMaxFocal = 230;
-    iCanonLens = 2359;
+    iCanonCurFocal  =  0x1d;
+    iMakernotesFlip =  0x30;
+    iCanonLensID    =  0xe2;
+    iCanonMinFocal  =  0xe4;
+    iCanonMaxFocal  =  0xe6;
+    iCanonLens      = 0x937;
     break;
   }
+
+  if (iMakernotesFlip && (CameraInfo[iMakernotesFlip] < 3)) {
+    imCanon.MakernotesFlip = "065"[CameraInfo[iMakernotesFlip]] - '0';
+// printf ("==>> iMakernotesFlip: 0x%x, flip: %d\n", iMakernotesFlip, imCanon.MakernotesFlip);
+  } else if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED) &&
+     (mgck == 0xaaaa) && (dng_writer == nonDNG)) { // CameraOrientation
+    int c, i;
+    for (i = 2; (sget2(CameraInfo+i) != 0xbbbb) && i < (int)maxlen; i++);
+    i+=2;
+    while (i < int(maxlen - 5))
+      if ((sget4(CameraInfo+i) == 257) && ((c = CameraInfo[i+8]) < 3)) {
+        imCanon.MakernotesFlip = "065"[c] - '0';
+// printf ("==>> MakernotesFlip offset: 0x%x, flip: %d\n", i+8, imCanon.MakernotesFlip);
+        break;
+      } else i+=4;
+  }
+
   if (iHTP)
   {
     imCanon.HighlightTonePriority = CameraInfo[iHTP];
@@ -333,25 +496,25 @@ void LibRaw::processCanonCameraInfo(unsigned long long id, uchar *CameraInfo,
     if (!ilm.FocalType) // zero means 'prime' here, replacing with standard '1'
       ilm.FocalType = LIBRAW_FT_PRIME_LENS;
   }
-  if (!ilm.CurFocal)
+  if (!ilm.CurFocal && iCanonCurFocal)
   {
     if (iCanonCurFocal >= maxlen)
       return; // broken;
     ilm.CurFocal = sget2Rev(CameraInfo + iCanonCurFocal);
   }
-  if (!ilm.LensID)
+  if (!ilm.LensID && iCanonLensID)
   {
     if (iCanonLensID >= maxlen)
       return; // broken;
     ilm.LensID = sget2Rev(CameraInfo + iCanonLensID);
   }
-  if (!ilm.MinFocal)
+  if (!ilm.MinFocal && iCanonMinFocal)
   {
     if (iCanonMinFocal >= maxlen)
       return; // broken;
     ilm.MinFocal = sget2Rev(CameraInfo + iCanonMinFocal);
   }
-  if (!ilm.MaxFocal)
+  if (!ilm.MaxFocal && iCanonMaxFocal)
   {
     if (iCanonMaxFocal >= maxlen)
       return; // broken;
@@ -566,6 +729,17 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
   get2();                                                    \
   FORC4 icWBC[LIBRAW_WBI_Measured][RGGB_2_RGBG(c)] = get2();
 
+#define sRAW_WB(offset)                                      \
+  fseek(ifp, save1 + (offset << 1), SEEK_SET);               \
+  FORC4 {                                                    \
+    sraw_mul[RGGB_2_RGBG(c)] = get2();                       \
+    if ((float)sraw_mul[RGGB_2_RGBG(c)] > sraw_mul_max) {    \
+      sraw_mul_max = (float)sraw_mul[RGGB_2_RGBG(c)];        \
+    }                                                        \
+  }                                                          \
+  sraw_mul_max /= 1024.f;                                    \
+  FORC4 sraw_mul[c] = (ushort)((float)sraw_mul[c] * sraw_mul_max);
+
 #define CR3_ColorData(offset)                                \
   fseek(ifp, save1 + ((offset+0x0041) << 1), SEEK_SET);      \
   Canon_WBpresets(2, 12);                                    \
@@ -595,13 +769,13 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
       imCanon.ISOgain[0] = get2();
       imCanon.ISOgain[1] = get2();
       if (imCanon.ISOgain[1] != 0x7fff) {
-        imCommon.real_ISO = int(100.0 * libraw_powf64l(2.0, double(imCanon.ISOgain[0]+imCanon.ISOgain[1]) / 32.0 - 5.0));
+        imCommon.real_ISO = floorf(100.f * libraw_powf64l(2.f, float(imCanon.ISOgain[0]+imCanon.ISOgain[1]) / 32.f - 5.f));
         if (!iso_speed || (iso_speed == 65535))
           iso_speed = imCommon.real_ISO;
       }
       get4();
       if (((i = get2()) != 0xffff) && !shutter) {
-        shutter = libraw_powf64l(2.0, (short)i / -32.0);
+        shutter = libraw_powf64l(2.f, float((short)i) / -32.0f);
       }
       imCanon.wbi = (get2(), get2());
       shot_order = (get2(), get2());
@@ -655,18 +829,18 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
   } else if ((tag == 0x0029) && (dng_writer == nonDNG)) { // PowerShot G9
     int Got_AsShotWB = 0;
     fseek(ifp, 8, SEEK_CUR);
-    for (int linenum = 0; linenum < Canon_G9_linenums_2_StdWBi.size(); linenum++) {
+    for (unsigned linenum = 0; linenum < Canon_G9_linenums_2_StdWBi.size(); linenum++) {
       if (Canon_G9_linenums_2_StdWBi[linenum] != LIBRAW_WBI_Unknown ) {
         FORC4 icWBC[Canon_G9_linenums_2_StdWBi[linenum]][GRBG_2_RGBG(c)] = get4();
         if (Canon_wbi2std[imCanon.wbi] == Canon_G9_linenums_2_StdWBi[linenum]) {
-          FORC4 cam_mul[c] = icWBC[Canon_G9_linenums_2_StdWBi[linenum]][c];
+          FORC4 cam_mul[c] = float(icWBC[Canon_G9_linenums_2_StdWBi[linenum]][c]);
           Got_AsShotWB = 1;
         }
       }
       fseek(ifp, 16, SEEK_CUR);
     }
     if (!Got_AsShotWB)
-      FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_Auto][c];
+      FORC4 cam_mul[c] = float(icWBC[LIBRAW_WBI_Auto][c]);
 
   } else if ((tag == 0x0081) && (dng_writer == nonDNG)) { // -1D, -1Ds
     data_offset = get4();
@@ -749,35 +923,35 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
     case 0:
     case 12: /* APS-H crop */
     case 13: /* APS-C crop */
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
       break;
     case 1:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
       break;
     case 2:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_4to3;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_4to3;
       break;
     case 7:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
       break;
     case 8:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_5to4;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_5to4;
       break;
     default:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_OTHER;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_OTHER;
       break;
     }
-    imgdata.sizes.raw_inset_crop.cwidth = get4();
-    imgdata.sizes.raw_inset_crop.cheight = get4();
-    imgdata.sizes.raw_inset_crop.cleft = get4();
-    imgdata.sizes.raw_inset_crop.ctop = get4();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get4();
+    imgdata.sizes.raw_inset_crops[0].cheight = get4();
+    imgdata.sizes.raw_inset_crops[0].cleft = get4();
+    imgdata.sizes.raw_inset_crops[0].ctop = get4();
 
   } else if ((tag == 0x00a4) && (dng_writer == nonDNG)) { // -1D, -1Ds
     fseek(ifp, imCanon.wbi * 48, SEEK_CUR);
     FORC3 cam_mul[c] = get2();
 
   } else if (tag == 0x00a9) {
-    long int save1 = ftell(ifp);
+    INT64 save1 = ftell(ifp);
     fseek(ifp, (0x1 << 1), SEEK_CUR);
     FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][RGGB_2_RGBG(c)] = get2();
     Canon_WBpresets(0, 0);
@@ -797,26 +971,22 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
       break;
     }
   }
-  else if (tag == 0x00e0)
-  { // SensorInfo
-    imCanon.SensorWidth = (get2(), get2());
+  else if (tag == 0x00e0) // SensorInfo
+  {
+    imCanon.SensorWidth  = (get2(), get2());
     imCanon.SensorHeight = get2();
-    imCanon.SensorLeftBorder = (get2(), get2(), get2());
-    imCanon.SensorTopBorder = get2();
-    imCanon.SensorRightBorder = get2();
-    imCanon.SensorBottomBorder = get2();
-    imCanon.BlackMaskLeftBorder = get2();
-    imCanon.BlackMaskTopBorder = get2();
-    imCanon.BlackMaskRightBorder = get2();
-    imCanon.BlackMaskBottomBorder = get2();
+    fseek(ifp, 4, SEEK_CUR);
+    imCanon.DefaultCropAbsolute = get_CanonArea();
+    imCanon.LeftOpticalBlack    = get_CanonArea();
   }
   else if (tag == 0x4001 && len > 500)
   {
+    float sraw_mul_max = 0.f;
     int bls = 0;
-    long int offsetChannelBlackLevel = 0L;
-    long int offsetChannelBlackLevel2 = 0L;
-    long int offsetWhiteLevels = 0L;
-    long int save1 = ftell(ifp);
+    INT64 offsetChannelBlackLevel = 0L;
+    INT64 offsetChannelBlackLevel2 = 0L;
+    INT64 offsetWhiteLevels = 0L;
+    INT64 save1 = ftell(ifp);
 
     switch (len)
     {
@@ -892,9 +1062,7 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
     case 1346: // 1100D, 60D; ColorDataSubVer: 9
       imCanon.ColorDataVer = 4;
       AsShot_Auto_MeasuredWB(0x003f);
-
-      fseek(ifp, save1 + (0x004e << 1), SEEK_SET);
-      FORC4 sraw_mul[RGGB_2_RGBG(c)] = get2();
+      sRAW_WB(0x004e);
       fseek(ifp, save1 + (0x0053 << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x00a8 << 1), SEEK_SET);
@@ -982,9 +1150,7 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
     case 1275: // 1200D; ColorDataSubVer: 10
       imCanon.ColorDataVer = 6;
       AsShot_Auto_MeasuredWB(0x003f);
-
-      fseek(ifp, save1 + (0x0062 << 1), SEEK_SET);
-      FORC4 sraw_mul[RGGB_2_RGBG(c)] = get2();
+      sRAW_WB(0x0062);
       fseek(ifp, save1 + (0x0067 << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x00bc << 1), SEEK_SET);
@@ -999,9 +1165,7 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
     case 1506: // 750D, 760D, 7D Mark II; ColorDataSubVer: 11
       imCanon.ColorDataVer = 7;
       AsShot_Auto_MeasuredWB(0x003f);
-
-      fseek(ifp, save1 + (0x007b << 1), SEEK_SET);
-      FORC4 sraw_mul[RGGB_2_RGBG(c)] = get2();
+      sRAW_WB(0x007b);
       fseek(ifp, save1 + (0x0080 << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x00d5 << 1), SEEK_SET);
@@ -1025,9 +1189,7 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
     case 1602: // 200D, 6D Mark II, 77D, 800D; ColorDataSubVer: 15
       imCanon.ColorDataVer = 8;
       AsShot_Auto_MeasuredWB(0x003f);
-
-      fseek(ifp, save1 + (0x0080 << 1), SEEK_SET);
-      FORC4 sraw_mul[RGGB_2_RGBG(c)] = get2();
+      sRAW_WB(0x0080);
       fseek(ifp, save1 + (0x0085 << 1), SEEK_SET);
       Canon_WBpresets(2, 12);
       fseek(ifp, save1 + (0x0107 << 1), SEEK_SET);
@@ -1095,8 +1257,8 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
   } else if (tag == 0x4013) {
     get4();
     imCanon.AFMicroAdjMode = get4();
-    float a = get4();
-    float b = get4();
+    float a = float(get4());
+    float b = float(get4());
     if (fabsf(b) > 0.001f)
       imCanon.AFMicroAdjValue = a / b;
 
@@ -1124,5 +1286,6 @@ void LibRaw::parseCanonMakernotes(unsigned tag, unsigned type, unsigned len, uns
     FORC4 cam_mul[c] = 1024;
   }
 #undef CR3_ColorData
+#undef sRAW_WB
 #undef AsShot_Auto_MeasuredWB
 }
diff --git a/src/metadata/ciff.cpp b/src/metadata/ciff.cpp
index 3f3322da..2c59b11e 100644
--- a/src/metadata/ciff.cpp
+++ b/src/metadata/ciff.cpp
@@ -59,7 +59,8 @@ void LibRaw::ciff_block_1030()
  */
 void LibRaw::parse_ciff(int offset, int length, int depth)
 {
-  int tboff, nrecs, c, type, len, save, wbi = -1;
+  int nrecs, c, type, len, wbi = -1;
+  INT64 save, tboff;
   ushort key[] = {0x410, 0x45f3};
   ushort CanonColorInfo1_key;
   ushort Appendix_A = 0;
@@ -71,7 +72,7 @@ void LibRaw::parse_ciff(int offset, int length, int depth)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
   fseek(ifp, offset + length - 4, SEEK_SET);
-  tboff = get4() + offset;
+  tboff = INT64(get4()) + offset;
   fseek(ifp, tboff, SEEK_SET);
   nrecs = get2();
   if (nrecs < 1)
@@ -158,13 +159,13 @@ void LibRaw::parse_ciff(int offset, int length, int depth)
       iso_speed =
           libraw_powf64l(2.0f, (get2() + get2()) / 32.0f - 5.0f) * 100.0f;
       ilm.CurAp = aperture = _CanonConvertAperture((get2(), get2()));
-      shutter = libraw_powf64l(2.0, -((short)get2()) / 32.0);
+      shutter = libraw_powf64l(2.0f, -float((short)get2()) / 32.f);
       imCanon.wbi = wbi = (get2(), get2());
-      if (wbi >= Canon_wbi2std.size())
+      if (wbi >= (int)Canon_wbi2std.size())
         wbi = 0;
       fseek(ifp, 32, SEEK_CUR);
       if (shutter > 1e6)
-        shutter = get2() / 10.0;
+        shutter = float(get2()) / 10.f;
     }
     else if (type == 0x102c) // CanonColorInfo2 / Appendix A: Pro90IS, G1, G2, S30, S40
     {
@@ -206,17 +207,17 @@ void LibRaw::parse_ciff(int offset, int length, int depth)
       if (nWB >= 7)
         Canon_WBpresets(0, 0);
       else
-        FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_Auto][c];
+        FORC4 cam_mul[c] = float(icWBC[LIBRAW_WBI_Auto][c]);
       if (nWB == 7) // mostly Canon EOS D60 + some fw#s for 300D;
                     // check for 0x1668000 is unreliable
       {
         if ((wbi >= 0) && (wbi < 9) && (wbi != 6))
         {
-          FORC4 cam_mul[c] = icWBC[Canon_wbi2std[wbi]][c];
+          FORC4 cam_mul[c] = float(icWBC[Canon_wbi2std[wbi]][c]);
         }
         else
         {
-          FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_Auto][c];
+          FORC4 cam_mul[c] = float(icWBC[LIBRAW_WBI_Auto][c]);
         }
       }
       else if (nWB == 9) // Canon 10D, 300D
@@ -225,11 +226,11 @@ void LibRaw::parse_ciff(int offset, int length, int depth)
         FORC4 icWBC[LIBRAW_WBI_Kelvin][RGGB_2_RGBG(c)] = get2();
         if ((wbi >= 0) && (wbi < 10))
         {
-          FORC4 cam_mul[c] = icWBC[Canon_wbi2std[wbi]][c];
+          FORC4 cam_mul[c] = float(icWBC[Canon_wbi2std[wbi]][c]);
         }
         else
         {
-          FORC4 cam_mul[c] = icWBC[LIBRAW_WBI_Auto][c];
+          FORC4 cam_mul[c] = float(icWBC[LIBRAW_WBI_Auto][c]);
         }
       }
       FORC4
@@ -268,7 +269,7 @@ void LibRaw::parse_ciff(int offset, int length, int depth)
 
         ushort q;
         fseek(ifp, 4, SEEK_CUR);
-        for (int linenum = 0; linenum < Canon_D30_linenums_2_StdWBi.size(); linenum++) {
+        for (unsigned linenum = 0; linenum < Canon_D30_linenums_2_StdWBi.size(); linenum++) {
           if (Canon_D30_linenums_2_StdWBi[linenum] != LIBRAW_WBI_Unknown) {
             FORC4 {
               q = get2();
@@ -285,7 +286,7 @@ void LibRaw::parse_ciff(int offset, int length, int depth)
 
         FORC4 {
           q = get2();
-          cam_mul[RGGB_2_RGBG(c)] = 1024.0 / MAX(1, q);
+          cam_mul[RGGB_2_RGBG(c)] = 1024.f / float(MAX(1, q));
         }
         if (!wbi)
           cam_mul[0] = -1; // use my auto white balance
@@ -295,7 +296,7 @@ void LibRaw::parse_ciff(int offset, int length, int depth)
                Appendix_A)               // G2, S30, S40
       {
         libraw_static_table_t linenums_2_StdWBi;
-        int AsShotWB_linenum = Canon_wbi2std.size();
+        unsigned AsShotWB_linenum = Canon_wbi2std.size();
 
         CanonColorInfo1_key = get2();
         if ((CanonColorInfo1_key == key[0]) && (len == 2048)) { // Pro1
@@ -331,11 +332,11 @@ void LibRaw::parse_ciff(int offset, int length, int depth)
         }
 
         fseek (ifp, 78LL+WB_table_offset, SEEK_CUR);
-        for (int linenum = 0; linenum < linenums_2_StdWBi.size(); linenum++) {
+        for (unsigned linenum = 0; linenum < linenums_2_StdWBi.size(); linenum++) {
           if (linenums_2_StdWBi[linenum] != LIBRAW_WBI_Unknown) {
             FORC4 icWBC[linenums_2_StdWBi[linenum]][GRBG_2_RGBG(c)] = get2() ^ key[c & 1];
             if (UseWBfromTable_as_AsShot && (AsShotWB_linenum == linenum)) {
-              FORC4 cam_mul[c] = icWBC[linenums_2_StdWBi[linenum]][c];
+              FORC4 cam_mul[c] = float(icWBC[linenums_2_StdWBi[linenum]][c]);
               Got_AsShotWB = 1;
             }
           } else {
@@ -352,24 +353,19 @@ void LibRaw::parse_ciff(int offset, int length, int depth)
     }
     else if (type == 0x1031)
     {
-			raw_width = imCanon.SensorWidth = (get2(), get2());
+			raw_width  = imCanon.SensorWidth = (get2(), get2());
 			raw_height = imCanon.SensorHeight = get2();
-			imCanon.SensorLeftBorder = (get2(), get2(), get2());
-			imCanon.SensorTopBorder = get2();
-			imCanon.SensorRightBorder = get2();
-			imCanon.SensorBottomBorder = get2();
-			imCanon.BlackMaskLeftBorder = get2();
-			imCanon.BlackMaskTopBorder = get2();
-			imCanon.BlackMaskRightBorder = get2();
-			imCanon.BlackMaskBottomBorder = get2();
+			fseek(ifp, 4, SEEK_CUR);
+			imCanon.DefaultCropAbsolute = get_CanonArea();
+			imCanon.LeftOpticalBlack    = get_CanonArea();
     }
     else if (type == 0x501c)
     {
-      iso_speed = len & 0xffff;
+      iso_speed = float(len & 0xffff);
     }
     else if (type == 0x5029)
     {
-      ilm.CurFocal = len >> 16;
+      ilm.CurFocal = float( len >> 16);
       ilm.FocalType = len & 0xffff;
       if (ilm.FocalType == LIBRAW_FT_ZOOM_LENS)
       {
diff --git a/src/metadata/cr3_parser.cpp b/src/metadata/cr3_parser.cpp
index def45b02..bcf21908 100644
--- a/src/metadata/cr3_parser.cpp
+++ b/src/metadata/cr3_parser.cpp
@@ -15,6 +15,16 @@
 
 #include "../../internal/dcraw_defs.h"
 
+
+static libraw_area_t sget_CanonArea(uchar *s) {
+  libraw_area_t la = {};
+  la.l = s[0] << 8 | s[1];
+  la.t = s[2] << 8 | s[3];
+  la.r = s[4] << 8 | s[5];
+  la.b = s[6] << 8 | s[7];
+  return la;
+}
+
 void LibRaw::selectCRXTrack(short maxTrack)
 {
   if (maxTrack < 0)
@@ -63,6 +73,7 @@ void LibRaw::selectCRXTrack(short maxTrack)
     raw_width = d->f_width;
     raw_height = d->f_height;
     load_raw = &LibRaw::crxLoadRaw;
+    tiff_bps = d->nBits;
     switch (d->cfaLayout)
     {
     case 0:
@@ -94,11 +105,12 @@ void LibRaw::selectCRXTrack(short maxTrack)
   }
 }
 
-#define bad_hdr                                                                \
+#define bad_hdr()                                                              \
   (((order != 0x4d4d) && (order != 0x4949)) || (get2() != 0x002a) ||           \
    (get4() != 0x00000008))
-int LibRaw::parseCR3(unsigned long long oAtomList,
-                     unsigned long long szAtomList, short &nesting,
+
+int LibRaw::parseCR3(INT64 oAtomList,
+                     INT64 szAtomList, short &nesting,
                      char *AtomNameStack, short &nTrack, short &TrackType)
 {
   /*
@@ -207,14 +219,14 @@ int LibRaw::parseCR3(unsigned long long oAtomList,
 
   const char sHandlerType[5][5] = {"unk.", "soun", "vide", "hint", "meta"};
 
-  int c, err;
+  int c, err=0;
 
   ushort tL;                        // Atom length represented in 4 or 8 bytes
   char nmAtom[5];                   // Atom name
-  unsigned long long oAtom, szAtom; // Atom offset and Atom size
-  unsigned long long oAtomContent,
+  INT64 oAtom, szAtom; // Atom offset and Atom size
+  INT64 oAtomContent,
       szAtomContent; // offset and size of Atom content
-  unsigned long long lHdr;
+  INT64 lHdr;
 
   char UIID[16];
   uchar CMP1[36];
@@ -232,7 +244,7 @@ int LibRaw::parseCR3(unsigned long long oAtomList,
     return -14; // too deep nesting
   short s_order = order;
 
-  while ((oAtom + 8ULL) <= (oAtomList + szAtomList))
+  while ((oAtom + 8LL) <= (oAtomList + szAtomList))
   {
     lHdr = 0ULL;
     err = 0;
@@ -267,9 +279,9 @@ int LibRaw::parseCR3(unsigned long long oAtomList,
       oAtomContent = oAtom + 8ULL;
       szAtomContent = szAtom - 8ULL;
     }
-    else if (szAtom == 1ULL)
+    else if (szAtom == 1LL)
     {
-      if ((oAtom + 16ULL) > (oAtomList + szAtomList))
+      if ((oAtom + 16LL) > (oAtomList + szAtomList))
       {
         err = -3;
         goto fin;
@@ -290,20 +302,20 @@ int LibRaw::parseCR3(unsigned long long oAtomList,
 		INT64 tt = ftell(ifp);
 		lHdr = 16ULL;
 		fread(UIID, 1, lHdr, ifp);
-		if (!memcmp(UIID, UUID_XMP, 16) && szAtom > 24 && szAtom < 1024000ULL)
+		if (!memcmp(UIID, UUID_XMP, 16) && szAtom > 24LL && szAtom < 1024000LL)
 		{
-			xmpdata = (char *)malloc(xmplen = szAtom - 23);
+			xmpdata = (char *)malloc(xmplen = unsigned(szAtom - 23));
 			fread(xmpdata, szAtom - 24, 1, ifp);
 			xmpdata[szAtom - 24] = 0;
 		}
-		else if (!memcmp(UIID, UIID_CanonPreview, 16) && szAtom > 48 && szAtom < 100ULL * 1024000ULL)
+		else if (!memcmp(UIID, UIID_CanonPreview, 16) && szAtom > 48LL && szAtom < 100LL * 1024000LL)
 		{
 			// read next 48 bytes, check for 'PRVW'
 			unsigned char xdata[32];
 			fread(xdata, 32, 1, ifp);	
 			if (!memcmp(xdata + 12, "PRVW", 4))
 			{
-				thumb_length = szAtom - 56;
+				thumb_length = unsigned(szAtom - 56);
 				thumb_offset = ftell(ifp);
 			}
 		}
@@ -336,23 +348,27 @@ int LibRaw::parseCR3(unsigned long long oAtomList,
     {
       short q_order = order;
       order = get2();
-      if ((tL != 4) || bad_hdr)
+      if ((tL != 4) || bad_hdr())
       {
         err = -4;
         goto fin;
       }
+      if (!libraw_internal_data.unpacker_data.cr3_ifd0_length)
+        libraw_internal_data.unpacker_data.cr3_ifd0_length = unsigned(szAtomContent);
       parse_tiff_ifd(oAtomContent);
       order = q_order;
     }
-    else if (!strcmp(AtomNameStack, "moovuuidCMT2"))
-    {
-      short q_order = order;
-      order = get2();
-      if ((tL != 4) || bad_hdr)
-      {
-        err = -5;
-        goto fin;
-      }
+	else if (!strcmp(AtomNameStack, "moovuuidCMT2"))
+	{
+		short q_order = order;
+		order = get2();
+		if ((tL != 4) || bad_hdr())
+		{
+			err = -5;
+			goto fin;
+		}
+		if (!libraw_internal_data.unpacker_data.cr3_exif_length)
+			libraw_internal_data.unpacker_data.cr3_exif_length = unsigned(szAtomContent); 
       parse_exif(oAtomContent);
       order = q_order;
     }
@@ -360,7 +376,7 @@ int LibRaw::parseCR3(unsigned long long oAtomList,
     {
       short q_order = order;
       order = get2();
-      if ((tL != 4) || bad_hdr)
+      if ((tL != 4) || bad_hdr())
       {
         err = -6;
         goto fin;
@@ -373,7 +389,7 @@ int LibRaw::parseCR3(unsigned long long oAtomList,
     {
       short q_order = order;
       order = get2();
-      if ((tL != 4) || bad_hdr)
+      if ((tL != 4) || bad_hdr())
       {
         err = -6;
         goto fin;
@@ -451,10 +467,10 @@ int LibRaw::parseCR3(unsigned long long oAtomList,
         if (!strncmp((char *)CDI1+8, "IAD1", 4) && (sgetn(8, CDI1) == 0x38)) {
           // sensor area at CDI1+12, 4 16-bit values
           // Bayer pattern? - next 4 16-bit values
-          // image area, next 4 16-bit values
-          FORC4 imCanon.LeftOpticalBlack[c]  = sgetn(2, CDI1+12 + 3*4*2 +2*c);
-          FORC4 imCanon.UpperOpticalBlack[c] = sgetn(2, CDI1+12 + 4*4*2 +2*c);
-          FORC4 imCanon.ActiveArea[c]        = sgetn(2, CDI1+12 + 5*4*2 +2*c);
+          imCanon.RecommendedImageArea = sget_CanonArea(CDI1+12 + 2*4*2);
+          imCanon.LeftOpticalBlack     = sget_CanonArea(CDI1+12 + 3*4*2);
+          imCanon.UpperOpticalBlack    = sget_CanonArea(CDI1+12 + 4*4*2);
+          imCanon.ActiveArea           = sget_CanonArea(CDI1+12 + 5*4*2);
         }
       }
     }
@@ -541,7 +557,7 @@ int LibRaw::parseCR3(unsigned long long oAtomList,
                       SEEK_SET);
                 short q_order = order;
                 order = get2();
-                if (bad_hdr)
+                if (bad_hdr())
                 {
                   err = -13;
                   goto fin;
diff --git a/src/metadata/epson.cpp b/src/metadata/epson.cpp
index 74e12d7f..427d98e9 100644
--- a/src/metadata/epson.cpp
+++ b/src/metadata/epson.cpp
@@ -17,7 +17,7 @@
 void LibRaw::parseEpsonMakernote(int base, int uptag, unsigned dng_writer)
 {
 
-#define isRIC imgdata.sizes.raw_inset_crop
+#define isRIC imgdata.sizes.raw_inset_crops[0]
 
   unsigned entries, tag, type, len, save;
   short morder, sorder = order;
diff --git a/src/metadata/exif_gps.cpp b/src/metadata/exif_gps.cpp
index 56f19fdd..6ff514c6 100644
--- a/src/metadata/exif_gps.cpp
+++ b/src/metadata/exif_gps.cpp
@@ -66,6 +66,9 @@ void LibRaw::parse_exif(int base)
 
   unsigned kodak = !strncmp(make, "EASTMAN", 7) && tiff_nifds < 3;
 
+  if (!libraw_internal_data.unpacker_data.exif_offset)
+	  libraw_internal_data.unpacker_data.exif_offset = base;
+
   entries = get2();
   if (!strncmp(make, "Hasselblad", 10) && (tiff_nifds > 3) && (entries > 512))
     return;
@@ -211,10 +214,16 @@ void LibRaw::parse_exif(int base)
       focal_len = getreal(type);
       break;
     case 0x927c: // 37500
+#ifndef USE_6BY9RPI
       if (((make[0] == '\0') && !strncmp(model, "ov5647", 6)) ||
           (!strncmp(make, "RaspberryPi", 11) &&
            (!strncmp(model, "RP_OV5647", 9) ||
             !strncmp(model, "RP_imx219", 9))))
+#else
+      if (((make[0] == '\0') && !strncmp(model, "ov5647", 6)) ||
+          (!strncmp(make, "RaspberryPi", 11) &&
+              (!strncmp(model, "RP_", 3) || !strncmp(model,"imx477",6))))
+#endif
       {
         char mn_text[512];
         char *pos;
@@ -225,6 +234,10 @@ void LibRaw::parse_exif(int base)
         fgets(mn_text, MIN(len, 511), ifp);
         mn_text[511] = 0;
 
+        pos = strstr(mn_text, "ev=");
+        if (pos)
+          imCommon.ExposureCalibrationShift = atof(pos + 3);
+
         pos = strstr(mn_text, "gain_r=");
         if (pos)
           cam_mul[0] = atof(pos + 7);
@@ -255,13 +268,13 @@ void LibRaw::parse_exif(int base)
 #endif
             if (pos)
             {
-              for (l = 0; l < 4; l++)
+              for (l = 0; l < 3; l++) // skip last row
               {
                 num = 0.0;
                 for (c = 0; c < 3; c++)
                 {
-                  imgdata.color.ccm[l][c] = (float)atoi(pos);
-                  num += imgdata.color.ccm[l][c];
+                  cmatrix[l][c] = (float)atoi(pos);
+                  num += cmatrix[c][l];
 #ifdef LIBRAW_WIN32_CALLS
                   pos = strtok(NULL, ",");
 #else
@@ -271,7 +284,7 @@ void LibRaw::parse_exif(int base)
                     goto end; // broken
                 }
                 if (num > 0.01)
-                  FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;
+                    FORC3 cmatrix[l][c] = cmatrix[l][c] / num;
               }
             }
           }
diff --git a/src/metadata/fuji.cpp b/src/metadata/fuji.cpp
index 1feadcf4..45255add 100644
--- a/src/metadata/fuji.cpp
+++ b/src/metadata/fuji.cpp
@@ -53,7 +53,7 @@ int LibRaw::guess_RAFDataGeneration (uchar *RAFData_start) // returns offset to
    - same conditions as for RAFData gen. 3, but also adds WRTS in bytes 4..7
    - contains a table of 3+2*13 values; first 3 values look like WHW
    - H in WHW group has a different meaning if the shot is taken in crop 2 mode
-     GFX 100, GFX 50R, GFX 50S
+     GFX 100, GFX 100S, GFX 50R, GFX 50S, GFX 50S II
      X-E2S, X-E3, X-H1, X-S10
      X-T2, X-T3, X-T4, X-T20, X-T30
      X-Pro2, X-Pro3
@@ -95,6 +95,7 @@ int LibRaw::guess_RAFDataGeneration (uchar *RAFData_start) // returns offset to
     }
     imFuji.RAFDataVersion = b23;
   }
+
   return offsetWH_inRAFData;
 }
 
@@ -278,7 +279,7 @@ void LibRaw::parseAdobeRAFMakernote()
         for (int wb_ind = LIBRAW_WBI_Custom1; wb_ind < LIBRAW_WBI_Custom1+nWBs; wb_ind++) {
           FORC4 icWBC[wb_ind][GRGB_2_RGBG(c)] =
                   sget2(PrivateMknBuf + posWB + (c << 1));
-          if ((PrivateTagBytes >= (4+16*nWBs)) && average_WBData) {
+          if ((PrivateTagBytes >= unsigned(4+16*nWBs)) && average_WBData) {
             posWB += 8;
             FORC4 icWBC[wb_ind][GRGB_2_RGBG(c)] =
                     (icWBC[wb_ind][GRGB_2_RGBG(c)] +
@@ -321,7 +322,11 @@ void LibRaw::parseAdobeRAFMakernote()
         order = 0x4949;
         if (PrivateTagBytes != 4096) // not one of Fuji X-A3, X-A5, X-A7, X-A10, X-A20, X-T100, X-T200, XF10
         {
+          int is34 = 0;
           guess_RAFDataGeneration (PrivateMknBuf + posPrivateMknBuf);
+// printf ("RAFDataVersion: 0x%04x, RAFDataGeneration: %d\n",
+// imFuji.RAFDataVersion, imFuji.RAFDataGeneration);
+
           for (posWB = 0; posWB < (int)PrivateTagBytes - 16; posWB++)
           {
             if ((!memcmp(PrivateMknBuf + posWB, "TSNERDTS", 8) &&
@@ -338,9 +343,26 @@ void LibRaw::parseAdobeRAFMakernote()
               break;
             }
           }
+
+          if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3, GFX 100S
+              (imFuji.RAFDataVersion == 0x0261) || // X100V, GFX 50S II
+              (imFuji.RAFDataVersion == 0x0262) || // X-T4
+              (imFuji.RAFDataVersion == 0x0264) || // X-S10
+              (imFuji.RAFDataVersion == 0x0265) || // X-E4
+                !strcmp(model, "X-Pro3")     ||
+                !strcmp(model, "GFX 100S")   ||
+                !strcmp(model, "GFX100S")    ||
+                !strcmp(model, "GFX 50S II") ||
+                !strcmp(model, "GFX50S II")  ||
+                !strcmp(model, "X100V")      ||
+                !strcmp(model, "X-T4")       ||
+                !strcmp(model, "X-E4")       ||
+                !strcmp(model, "X-S10"))
+            is34 = 1;
+
           if (imFuji.RAFDataVersion == 0x4500) // X-E1, RAFData gen. 3
           {
-            wb_section_offset = 0x13ac;        // (fj<<1) - 0x3c
+            wb_section_offset = 0x13ac;
           }
           else if (imFuji.RAFDataVersion == 0x0146 || // X20
                    imFuji.RAFDataVersion == 0x0149 || // X100S
@@ -410,7 +432,7 @@ void LibRaw::parseAdobeRAFMakernote()
           {
             wb_section_offset = 0x2014;
           }
-          else if (imFuji.RAFDataVersion == 0x025f) // X-T30, GFX 50R, GFX 100
+          else if (imFuji.RAFDataVersion == 0x025f) // X-T30, GFX 50R, GFX 100 (? RAFDataVersion 0x045f)
           {
             if (!strcmp(model, "X-T30")) {
               if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20b8))
@@ -423,13 +445,19 @@ void LibRaw::parseAdobeRAFMakernote()
             else if (!strcmp(model, "GFX 100"))
               wb_section_offset = 0x20e4;
           }
-          else if (imFuji.RAFDataVersion == 0x0260) // X-Pro3
+          else if (imFuji.RAFDataVersion == 0x0260) // X-Pro3, GFX 100S
           {
-            wb_section_offset = 0x20e8;
+           if (!strcmp(model, "X-Pro3"))
+              wb_section_offset = 0x20e8;
+            else if (!strcmp(model, "GFX 100S") || !strcmp(model, "GFX100S"))
+              wb_section_offset = 0x2108;
           }
-          else if (imFuji.RAFDataVersion == 0x0261) // X100V
+          else if (imFuji.RAFDataVersion == 0x0261) // X100V, GFX 50S II
           {
-            wb_section_offset = 0x2078;
+            if (!strcmp(model, "X100V"))
+              wb_section_offset = 0x2078;
+            else if (!strcmp(model, "GFX 50S II") || !strcmp(model, "GFX50S II"))
+              wb_section_offset = 0x214c;
           }
           else if (imFuji.RAFDataVersion == 0x0262) // X-T4
           {
@@ -439,11 +467,16 @@ void LibRaw::parseAdobeRAFMakernote()
           {
             wb_section_offset = 0x21de;
           }
+          else if (imFuji.RAFDataVersion == 0x0265) // X-E4
+          {
+            wb_section_offset = 0x21cc;
+          }
           else if (imFuji.RAFDataVersion == 0x0355) // X-E2S
           {
             wb_section_offset = 0x1840;
           }
-            /* try for unknown RAF Data versions */
+
+/* try for unknown RAF Data versions */
           else if (!strcmp(model, "X-Pro2"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x135c))
@@ -488,6 +521,10 @@ void LibRaw::parseAdobeRAFMakernote()
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x1424))
               wb_section_offset = 0x1424;
           }
+          else if (!strcmp(model, "GFX 50S II") || !strcmp(model, "GFX50S II")) {
+            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x214c))
+              wb_section_offset = 0x214c;
+          }
           else if (!strcmp(model, "X30") ||
                    !strcmp(model, "X100T"))
           {
@@ -534,13 +571,15 @@ void LibRaw::parseAdobeRAFMakernote()
           }
           else if (!strcmp(model, "X100V"))
           {
-            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20e8))
+            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x2078))
               wb_section_offset = 0x2078;
           }
           else if (!strcmp(model, "X-T30"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20b8))
               wb_section_offset = 0x20b8;
+            else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20c8))
+              wb_section_offset = 0x20c8;
           }
           else if (!strcmp(model, "GFX 100"))
           {
@@ -552,17 +591,28 @@ void LibRaw::parseAdobeRAFMakernote()
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x20e8))
               wb_section_offset = 0x20e8;
           }
+          else if (!strcmp(model, "GFX100S") || !strcmp(model, "GFX 100S"))
+          {
+            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x2108))
+              wb_section_offset = 0x2108;
+          }
           else if (!strcmp(model, "X-T4"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x21c8))
               wb_section_offset = 0x21c8;
           }
+          else if (!strcmp(model, "X-E4"))
+          {
+            if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x21cc)) 
+              wb_section_offset = 0x21cc;
+          }
           else if (!strcmp(model, "X-S10"))
           {
             if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x21de))
               wb_section_offset = 0x21de;
           }
-            /* no RAF Data version for the models below */
+
+/* no RAF Data version for the models below */
           else if (!strcmp(model, "FinePix X100")) // X100 0 0x19f0 0x19e8
           {
             if (!strcmp(imFuji.RAFVersion, "0069"))
@@ -617,6 +667,7 @@ void LibRaw::parseAdobeRAFMakernote()
             else if (isWB(PrivateMknBuf + posPrivateMknBuf + 0x138c))
               wb_section_offset = 0x138c;
           }
+
           if (wb_section_offset &&
               isWB(PrivateMknBuf + posPrivateMknBuf + wb_section_offset))
           {
@@ -634,7 +685,7 @@ void LibRaw::parseAdobeRAFMakernote()
             }
 
             posWB = posPrivateMknBuf + wb_section_offset;
-            for (int wb_ind = 0; wb_ind < Fuji_wb_list1.size(); posWB += 6, wb_ind++)
+            for (int wb_ind = 0; wb_ind < (int)Fuji_wb_list1.size(); posWB += 6, wb_ind++)
             {
               icWBC[Fuji_wb_list1[wb_ind]][1] =
                   icWBC[Fuji_wb_list1[wb_ind]][3] =
@@ -645,10 +696,7 @@ void LibRaw::parseAdobeRAFMakernote()
                   sget2(PrivateMknBuf + posWB + 4);
             }
             int found = 0;
-            if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3
-                (imFuji.RAFDataVersion == 0x0261) || // X100V
-                (imFuji.RAFDataVersion == 0x0262) || // X-T4
-                (imFuji.RAFDataVersion == 0x0264))   // X-S10
+            if (is34)
               posWB += 0x30;
             posWB += 0xc0;
             ushort Gval = sget2(PrivateMknBuf + posWB);
@@ -657,10 +705,7 @@ void LibRaw::parseAdobeRAFMakernote()
             {
               if (sget2(PrivateMknBuf + posEndCCTsection) != Gval)
               {
-                if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3
-                    (imFuji.RAFDataVersion == 0x0261) || // X100V
-                    (imFuji.RAFDataVersion == 0x0262) || // X-T4
-                    (imFuji.RAFDataVersion == 0x0264))   // X-S10
+                if (is34)
                   wb_section_offset = posEndCCTsection - 34*3*2; // 34 records, 3 2-byte values in a record
                 else
                   wb_section_offset = posEndCCTsection - 31*3*2; // 31 records, 3 2-byte values in a record
@@ -711,7 +756,7 @@ void LibRaw::parseAdobeRAFMakernote()
             }
             if (nWB != 0x46)
             {
-              for (pWB = 1; pWB < Fuji_wb_list2.size(); pWB += 2)
+              for (pWB = 1; pWB < (int)Fuji_wb_list2.size(); pWB += 2)
               {
                 if (Fuji_wb_list2[pWB] == nWB)
                 {
@@ -889,10 +934,23 @@ void LibRaw::parseFujiMakernotes(unsigned tag, unsigned type, unsigned len,
     case 0x1050:
       imFuji.ShutterType = get2();
       break;
+    case 0x1100:
+      imFuji.AutoBracketing = get2(); // AutoBracketing = 6 for pixel shift mode 
+      break;
+    case 0x1101:
+      imFuji.SequenceNumber = get2();
+      break;
     case 0x1103:
       imgdata.shootinginfo.DriveMode = get2();
       imFuji.DriveMode = imgdata.shootinginfo.DriveMode & 0xff;
       break;
+    case 0x1105:
+      imFuji.SeriesLength = get2();
+      break;
+    case 0x1106:
+      imFuji.PixelShiftOffset[0] = getreal(type);
+      imFuji.PixelShiftOffset[1] = getreal(type);
+      break;
     case 0x1301:
       imFuji.FocusWarning = get2();
       break;
@@ -930,6 +988,9 @@ void LibRaw::parseFujiMakernotes(unsigned tag, unsigned type, unsigned len,
       imgdata.shootinginfo.ImageStabilization =
           (imFuji.ImageStabilization[0] << 9) + imFuji.ImageStabilization[1];
       break;
+    case 0x1438:
+      imFuji.ImageCount = get2();
+      break;
     case 0x1431:
       imFuji.Rating = get4();
       break;
@@ -946,6 +1007,45 @@ void LibRaw::parseFujiMakernotes(unsigned tag, unsigned type, unsigned len,
   return;
 }
 
+void LibRaw::parse_fuji_thumbnail(int offset)
+{
+    uchar xmpmarker[] = "http://ns.adobe.com/xap/1.0/";
+    uchar buf[sizeof(xmpmarker)+1];
+    int xmpsz = sizeof(xmpmarker); // we do not
+
+    INT64 pos = ftell(ifp);
+    fseek(ifp, offset, SEEK_SET);
+    ushort s_order = order;
+    order = 0x4a4a; // JPEG is always in MM order
+
+    if (get2() == 0xFFD8)
+    {
+        while (1)
+        {
+          ushort tag = get2();
+          if (tag != 0xFFE1 && tag != 0xFFE2) // allow APP1/APP2 only
+            break;
+          INT64 tpos = ftell(ifp);
+          int len = get2();
+          if (len > xmpsz + 2)
+          {
+              if ((fread(buf, 1, xmpsz, ifp) == xmpsz) && !memcmp(buf, xmpmarker, xmpsz)) // got it
+              {
+                  xmplen = len - xmpsz - 2;
+                  xmpdata = (char*) malloc(xmplen+1);
+                  fread(xmpdata, 1, xmplen, ifp);
+                  xmpdata[xmplen] = 0;
+                  break;
+              }
+          }
+          fseek(ifp, tpos + len, SEEK_SET);
+        }
+    }
+
+    order = s_order;
+    fseek(ifp, pos, SEEK_SET);
+}
+
 void LibRaw::parse_fuji(int offset)
 {
   unsigned entries, tag, len, save, c;
@@ -1002,26 +1102,26 @@ void LibRaw::parse_fuji(int offset)
     }
     else if ((tag == 0x0110) && raw_inset_present) // RawImageCropTopLeft
     {
-      imgdata.sizes.raw_inset_crop.ctop = get2();
-      imgdata.sizes.raw_inset_crop.cleft = get2();
+      imgdata.sizes.raw_inset_crops[0].ctop = get2();
+      imgdata.sizes.raw_inset_crops[0].cleft = get2();
     }
     else if ((tag == 0x0111) && raw_inset_present) // RawImageCroppedSize
     {
-      imgdata.sizes.raw_inset_crop.cheight = get2();
-      imgdata.sizes.raw_inset_crop.cwidth = get2();
+      imgdata.sizes.raw_inset_crops[0].cheight = get2();
+      imgdata.sizes.raw_inset_crops[0].cwidth = get2();
     }
     else if ((tag == 0x0115) && raw_inset_present) // RawImageAspectRatio
     {
       int a = get2();
       int b = get2();
       if (a * b == 6)
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
       else if (a * b == 12)
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_4to3;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_4to3;
       else if (a * b == 144)
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
       else if (a * b == 1)
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
     }
     else if (tag == 0x0121) // RawImageSize
     {
@@ -1127,7 +1227,7 @@ void LibRaw::parse_fuji(int offset)
       nWBs = MIN(nWBs, 6);
       for (int wb_ind = LIBRAW_WBI_Custom1; wb_ind < LIBRAW_WBI_Custom1+nWBs; wb_ind++) {
         FORC4 icWBC[wb_ind][GRGB_2_RGBG(c)] = get2();
-        if ((len >= (4+16*nWBs)) && average_WBData) {
+        if ((len >= unsigned(4+16*nWBs)) && average_WBData) {
           FORC4 icWBC[wb_ind][GRGB_2_RGBG(c)] =
                   (icWBC[wb_ind][GRGB_2_RGBG(c)] +get2()) /2;
         }
@@ -1152,17 +1252,17 @@ void LibRaw::parse_fuji(int offset)
         offsetWH_inRAFData = guess_RAFDataGeneration(RAFDataHeader);
         fseek(ifp, offsetWH_inRAFData-int(sizeof RAFDataHeader), SEEK_CUR);
         for (int i=0;
-             i<((sizeof imFuji.RAFData_ImageSizeTable) / (sizeof imFuji.RAFData_ImageSizeTable[0]));
+             i< (int)((sizeof imFuji.RAFData_ImageSizeTable) / (sizeof imFuji.RAFData_ImageSizeTable[0]));
              i++) {
           imFuji.RAFData_ImageSizeTable[i] = get4();
         }
 
 //         if ((width > raw_width)
-//             || (raw_inset_present && (width < imgdata.sizes.raw_inset_crop.cwidth))
+//             || (raw_inset_present && (width < imgdata.sizes.raw_inset_crops[0].cwidth))
 //         )
 //           width = raw_width;
 //         if ((height > raw_height)
-//             || (raw_inset_present && (height < imgdata.sizes.raw_inset_crop.cheight))
+//             || (raw_inset_present && (height < imgdata.sizes.raw_inset_crops[0].cheight))
 //         )
 //           height = raw_height;
 //
@@ -1191,7 +1291,7 @@ void LibRaw::parse_fuji(int offset)
           }
           if (nWB != 70)
           {
-            for (int pWB = 1; pWB < Fuji_wb_list2.size(); pWB += 2)
+            for (int pWB = 1; pWB < (int)Fuji_wb_list2.size(); pWB += 2)
             {
               if (Fuji_wb_list2[pWB] == nWB)
               {
diff --git a/src/metadata/hasselblad_model.cpp b/src/metadata/hasselblad_model.cpp
index f2055024..d61e23a6 100644
--- a/src/metadata/hasselblad_model.cpp
+++ b/src/metadata/hasselblad_model.cpp
@@ -146,7 +146,7 @@ static const char *Hasselblad_SensorEnclosures[] = {
     if ((ps = strrchr(imgdata.color.LocalizedCameraModel, '-')))
       c = ps-imgdata.color.LocalizedCameraModel;
     else c = strlen(imgdata.color.LocalizedCameraModel);
-    int cc = MIN(c, sizeof(tmp_model)-1);
+    int cc = MIN(c, (int)sizeof(tmp_model)-1);
     memcpy(tmp_model, imgdata.color.LocalizedCameraModel,cc);
     tmp_model[cc] = 0;
     if (strcasestr(imgdata.color.UniqueCameraModel, "coated")) {
@@ -161,7 +161,7 @@ static const char *Hasselblad_SensorEnclosures[] = {
       c = ps-imgdata.color.UniqueCameraModel;
     }
     else c = strlen(imgdata.color.UniqueCameraModel);
-    int cc = MIN(c, sizeof(tmp_model)-1);
+    int cc = MIN(c, (int)sizeof(tmp_model)-1);
     memcpy(tmp_model, imgdata.color.UniqueCameraModel,cc);
     tmp_model[cc] = 0;
   }
@@ -522,10 +522,11 @@ static const char *Hasselblad_SensorEnclosures[] = {
           ilm.LensID = LIBRAW_MOUNT_Hasselblad_XCD*100000000ULL +
                        35*10000ULL + 75*10;
         }
-        else
+        else {
           ilm.FocalType = LIBRAW_FT_PRIME_LENS;
           ilm.LensID = LIBRAW_MOUNT_Hasselblad_XCD*100000000ULL +
                        ilm.LensID*10000ULL + ilm.LensID*10;
+        }
       }
     }
   }
diff --git a/src/metadata/identify.cpp b/src/metadata/identify.cpp
index e3bc3d97..68ad488e 100644
--- a/src/metadata/identify.cpp
+++ b/src/metadata/identify.cpp
@@ -102,6 +102,7 @@ static const struct
     {LIBRAW_CAMERAMAKER_VIVO,           "Vivo"},
     {LIBRAW_CAMERAMAKER_HMD_Global,     "HMD Global"},
     {LIBRAW_CAMERAMAKER_HUAWEI,         "Huawei"},
+    {LIBRAW_CAMERAMAKER_RaspberryPi,    "RaspberryPi"},
 };
 // clang-format on
 
@@ -180,9 +181,10 @@ void LibRaw::identify()
 {
   // clang-format off
   static const ushort canon[][11] = {
-      // raw_width, raw_height, left_margin, top_margin, width_decrement,
-      // height_decrement, mask01, mask03, mask11,
-	  // mask13, CFA_filters.
+      // raw_width, raw_height, left_margin, top_margin,
+      // width_decrement, height_decrement,
+      // mask01, mask03, mask11, mask13,
+      // CFA_filters.
 	  { 1944, 1416, 0, 0, 48, 0 }, // 00 "PowerShot Pro90 IS"
 	  { 2144, 1560, 4, 8, 52, 2, 0, 0, 0, 25 }, // 01 "PowerShot S30", "PowerShot G1"
 	  { 2224, 1456, 48, 6, 0, 2 }, // 02 "EOS D30"
@@ -403,6 +405,7 @@ void LibRaw::identify()
 
   char head[64] = {0}, *cp;
   int hlen, fsize, flen, zero_fsize = 1, i, c;
+  INT64 fsize64;
   struct jhead jh;
 
   unsigned camera_count =
@@ -484,6 +487,10 @@ void LibRaw::identify()
       libraw_internal_data.unpacker_data.posRAFData = 0;
 
   fseek(ifp, 0, SEEK_END);
+  fsize64 = ftell(ifp);
+  if(fsize64 > LIBRAW_MAX_NONDNG_RAW_FILE_SIZE && fsize64 > LIBRAW_MAX_DNG_RAW_FILE_SIZE)
+      throw LIBRAW_EXCEPTION_TOOBIG;
+
   flen = fsize = ftell(ifp);
   if ((cp = (char *)memmem(head, 32, (char *)"MMMM", 4)) ||
       (cp = (char *)memmem(head, 32, (char *)"IIII", 4)))
@@ -565,6 +572,7 @@ void LibRaw::identify()
     fseek(ifp, 100 + 28 * (shot_select > 0), SEEK_SET);
     parse_tiff(data_offset = get4());
     parse_tiff(thumb_offset + 12);
+    parse_fuji_thumbnail(thumb_offset);
     apply_tiff();
   }
   else if (!memcmp(head, "RIFF", 4))
@@ -703,6 +711,17 @@ void LibRaw::identify()
       selectCRXTrack(nTrack);
   }
 
+  if (dng_version)
+  {
+      if (fsize64 > LIBRAW_MAX_DNG_RAW_FILE_SIZE)
+          throw LIBRAW_EXCEPTION_TOOBIG;
+  }
+  else
+  {
+    if (fsize64 > LIBRAW_MAX_NONDNG_RAW_FILE_SIZE)
+      throw LIBRAW_EXCEPTION_TOOBIG;
+  }
+
   if (make[0] == 0)
     for (zero_fsize = i = 0; i < (int)camera_count; i++)
       if (fsize == (int)table[i].fsize)
@@ -763,18 +782,19 @@ void LibRaw::identify()
       }
   if (zero_fsize)
     fsize = 0;
-  if (make[0] == 0)
+  if (make[0] == 0 && fsize64 < 25000000LL)
     parse_smal(0, flen);
   if (make[0] == 0)
   {
     parse_jpeg(0);
 #ifdef USE_6BY9RPI
-	if (!(strncmp(model, "ov", 2) && strncmp(model, "RP_", 3))) {
+	if (!(strncmp(model, "ov", 2) && strncmp(model, "RP_", 3) && strncmp(model, "imx477", 6))) {
 		//Assume that this isn't a raw unless the header can be found
 		is_raw = 0;
 
-		if (!strncasecmp(model, "RP_testc",8) ||
-		    !strncasecmp(model, "RP_imx477",9)) {
+		if (!strncasecmp(model, "RP_testc",8) 
+            || !strncasecmp(model, "imx477", 6) //  from PyDNG
+		    || !strncasecmp(model, "RP_imx477",9)) {
 			const long offsets[] = {
 				//IMX477 offsets
 				3375104,  //2028x1080 12bit
@@ -788,7 +808,8 @@ void LibRaw::identify()
 				if(!fseek (ifp, -offsets[offset_idx], SEEK_END) &&
 				   fread (head, 1, 32, ifp) && !strncmp(head,"BRCM", 4)) {
 					fseek(ifp, -32, SEEK_CUR);
-					strcpy (make, "SonyRPF");
+					strcpy (make, "RaspberryPi");
+                    strcpy(model, "RP_imx477"); // Force single model
 					black = (offset_idx == 3) ? 64 : 256;
 					parse_raspberrypi();
 					break;
@@ -812,7 +833,8 @@ void LibRaw::identify()
 					fread(head, 1, 32, ifp) && !strncmp(head, "BRCM", 4)) {
 
 					fseek(ifp, -32, SEEK_CUR);
-					strcpy(make, "SonyRPF");
+					strcpy(make, "RaspberryPi");
+                    black = 66;
 					parse_raspberrypi();
 					break;
 				}
@@ -832,11 +854,13 @@ void LibRaw::identify()
 				if (!fseek(ifp, -offsets[offset_idx], SEEK_END) &&
 					fread(head, 1, 32, ifp) && !strncmp(head, "BRCM", 4)) {
 					fseek(ifp, -32, SEEK_CUR);
-					strcpy(make, "OmniVision");
-					width = raw_width;
+					strcpy(make, "RaspberryPi");
+                    strcpy(model, "ov5647"); // Force single model
+                    width = raw_width;
 					//Defaults
 					raw_width = 2611;
 					filters = 0x16161616;
+                    black = 16;
 					parse_raspberrypi();
 					break;
 				}
@@ -907,7 +931,7 @@ void LibRaw::identify()
   }
 
   for (i = 0; i < int(sizeof CorpTable / sizeof *CorpTable); i++) {
-    if (maker_index == CorpTable[i].CorpId) {
+    if (maker_index == (unsigned)CorpTable[i].CorpId) {
       strcpy(make, CorpTable[i].CorpName);
       break;
     }
@@ -982,10 +1006,12 @@ void LibRaw::identify()
     }
     GetNormalizedModel();
     if (makeIs(LIBRAW_CAMERAMAKER_Leica)) {
-		  if (!strcmp(model, "SL2")) {
-        height -= 3;
-      }
+		  if (!strcmp(model, "SL2")) 
+              height -= 3;
+          if (!strncasecmp(model, "Q2 MONO",7))
+              height -= 18;
     }
+
     else if (makeIs(LIBRAW_CAMERAMAKER_Olympus) &&
         (OlyID == OlyID_STYLUS_1) && // don't use normalized_model below, it is 'Stylus 1'
         (strchr(model+6, 's') ||
@@ -1031,13 +1057,13 @@ void LibRaw::identify()
         mask[0][3] = 1;
         mask[0][1] = 2;
 
-        if(imCanon.SensorWidth == raw_width
-            && imCanon.SensorHeight == raw_height)
+        if ((imCanon.SensorWidth == raw_width) &&
+            (imCanon.SensorHeight == raw_height))
         {
-            left_margin = (imCanon.SensorLeftBorder+1) & 0xfffe; // round to 2
-            width = imCanon.SensorRightBorder - left_margin;
-            top_margin = (imCanon.SensorTopBorder +1)  & 0xfffe;
-            height = imCanon.SensorBottomBorder - top_margin;
+            left_margin = (imCanon.DefaultCropAbsolute.l+1) & 0xfffe; // round to 2
+            width = imCanon.DefaultCropAbsolute.r - left_margin;
+            top_margin = (imCanon.DefaultCropAbsolute.t +1)  & 0xfffe;
+            height = imCanon.DefaultCropAbsolute.b - top_margin;
         }
     }
   }
@@ -1272,15 +1298,20 @@ void LibRaw::identify()
 void LibRaw::identify_process_dng_fields()
 {
 	if (!dng_version) return;
+
+	// Cleanup inset_crops if set by makernotes parser
+	imgdata.sizes.raw_inset_crops[0].cleft = imgdata.sizes.raw_inset_crops[0].ctop =
+        imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[1].ctop = 0xffff;
+    imgdata.sizes.raw_inset_crops[0].cwidth = imgdata.sizes.raw_inset_crops[0].cheight =
+        imgdata.sizes.raw_inset_crops[1].cwidth = imgdata.sizes.raw_inset_crops[1].cheight = 0;
+
+
 	int c;
 	{
 		/* copy DNG data from per-IFD field to color.dng */
 		int iifd = find_ifd_by_offset(data_offset);
 		int pifd = find_ifd_by_offset(thumb_offset);
 
-#define CFAROUND(value, filters)                                               \
-  filters ? (filters >= 1000 ? ((value + 1) / 2) * 2 : ((value + 5) / 6) * 6)  \
-          : value
 
 #define IFDCOLORINDEX(ifd, subset, bit)                                        \
   (tiff_ifd[ifd].dng_color[subset].parsedfields & bit)                         \
@@ -1378,34 +1409,50 @@ void LibRaw::identify_process_dng_fields()
 					|| !strcmp(normalized_model, "S5Pro")
 					|| !strcmp(normalized_model, "S2Pro"));
 
-			if (!noFujiDNGCrop &&
-				(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP))
+			if (!noFujiDNGCrop) // Promote DNG Crops to raw_inset_crops
 			{
 				sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPORIGIN);
 				int sidx2 = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPSIZE);
-				if (sidx >= 0 && sidx == sidx2 &&
-					tiff_ifd[sidx].dng_levels.default_crop[2] > 0 &&
-					tiff_ifd[sidx].dng_levels.default_crop[3] > 0)
-				{
-					int lm = tiff_ifd[sidx].dng_levels.default_crop[0];
-					int lmm = CFAROUND(lm, filters);
-					int tm = tiff_ifd[sidx].dng_levels.default_crop[1];
-					int tmm = CFAROUND(tm, filters);
-					int ww = tiff_ifd[sidx].dng_levels.default_crop[2];
-					int hh = tiff_ifd[sidx].dng_levels.default_crop[3];
-					if (lmm > lm)
-						ww -= (lmm - lm);
-					if (tmm > tm)
-						hh -= (tmm - tm);
-					if (left_margin + lm + ww <= raw_width &&
-						top_margin + tm + hh <= raw_height)
-					{
-						left_margin += lmm;
-						top_margin += tmm;
-						width = ww;
-						height = hh;
-					}
-				}
+                if (sidx >= 0 && sidx == sidx2 &&
+                    tiff_ifd[sidx].dng_levels.default_crop[2] > 0 &&
+                    tiff_ifd[sidx].dng_levels.default_crop[3] > 0)
+                {
+                    int lm = tiff_ifd[sidx].dng_levels.default_crop[0];
+                    int tm = tiff_ifd[sidx].dng_levels.default_crop[1];
+                    int ww = tiff_ifd[sidx].dng_levels.default_crop[2];
+                    int hh = tiff_ifd[sidx].dng_levels.default_crop[3];
+                    if ((lm + ww < int(raw_width) + int(left_margin))
+                        && (tm + hh < int(raw_height) + int(top_margin))) // Crop data is correct
+                    {
+                        imgdata.sizes.raw_inset_crops[0].cleft = left_margin + lm;
+                        imgdata.sizes.raw_inset_crops[0].cwidth = ww;
+                        imgdata.sizes.raw_inset_crops[0].ctop = top_margin + tm;
+                        imgdata.sizes.raw_inset_crops[0].cheight = hh;
+
+                        int sidx3 = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_USERCROP);
+                        if (sidx3 >= 0 && sidx3 == sidx) // No need to check values range, it is checked at parse
+                        {
+                            int dt = int(imgdata.sizes.raw_inset_crops[0].cheight * tiff_ifd[sidx].dng_levels.user_crop[0]);
+                            int dl = int(imgdata.sizes.raw_inset_crops[0].cwidth * tiff_ifd[sidx].dng_levels.user_crop[1]);
+                            int db = int(imgdata.sizes.raw_inset_crops[0].cheight * tiff_ifd[sidx].dng_levels.user_crop[2]);
+                            int dr = int(imgdata.sizes.raw_inset_crops[0].cwidth * tiff_ifd[sidx].dng_levels.user_crop[3]);
+
+                            int dh = db - dt;
+                            int dw = dr - dl;
+
+                            if (dh > 0 && dw > 0
+                                && dh < imgdata.sizes.raw_inset_crops[0].cheight // No need to repeat crop for 0,0,1,1
+                                && dw < imgdata.sizes.raw_inset_crops[0].cwidth)
+                            {
+                                imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[0].cleft + dl;
+                                imgdata.sizes.raw_inset_crops[1].cwidth = dw;
+                                imgdata.sizes.raw_inset_crops[1].ctop = imgdata.sizes.raw_inset_crops[0].ctop + dt;
+                                imgdata.sizes.raw_inset_crops[1].cheight = dh;
+                            }
+                        }
+
+                    }
+                }
 			}
 			if (!(imgdata.color.dng_color[0].parsedfields &
 				LIBRAW_DNGFM_FORWARDMATRIX)) // Not set already (Leica makernotes)
@@ -1631,7 +1678,7 @@ void LibRaw::identify_finetune_pentax()
 {
     if (dng_version && data_offset)
     {
-        for(int i = 0; i < tiff_nifds; i++)
+        for(int i = 0; i < (int)tiff_nifds; i++)
             if (tiff_ifd[i].offset == data_offset)
             {
                 if (tiff_ifd[i].phint == 34892) return; // Linear DNG made from Pentax source
@@ -1692,7 +1739,14 @@ void LibRaw::identify_finetune_pentax()
 			left_margin = 4;
 			width = 6040;
 		}
-		if ((width == 6112) && (unique_id == PentaxID_KP))
+        if ((width == 6304) && (unique_id == PentaxID_K_3_III)) // From DNG ActiveArea
+        {
+          left_margin = 26;
+          width = 6224;
+          top_margin = 34;
+          height = 4160;
+        }
+        if ((width == 6112) && (unique_id == PentaxID_KP))
 		{
 			// From DNG, maybe too strict
 			left_margin = 54;
@@ -2293,6 +2347,11 @@ void LibRaw::identify_finetune_dcr(char head[64], int fsize, int flen)
 			  left_margin = 0;
 			  top_margin = 0;
         break;
+      case 8472:                // GFX 50S II
+        left_margin = 0;
+			  top_margin  = 0;
+			  width = raw_width - 192;
+        break;
       case 9696:                // GFX 100; FF crop
       case 11808:               // GFX 100; no crop
 			  left_margin = 0;
@@ -2314,7 +2373,7 @@ void LibRaw::identify_finetune_dcr(char head[64], int fsize, int flen)
                                 // HS20EXR, HS30EXR, HS33EXR, HS50EXR
         if ((width = raw_width - 66))
           left_margin = 34;
-        if (imgdata.sizes.raw_inset_crop.cleft == 8) // HS50EXR, F900EXR
+        if (imgdata.sizes.raw_inset_crops[0].cleft == 8) // HS50EXR, F900EXR
         {
 			    left_margin = 0;
 			    width += 2;
@@ -2332,7 +2391,7 @@ void LibRaw::identify_finetune_dcr(char head[64], int fsize, int flen)
 //         raw_width = 688;
 //         raw_height = 30848;
 
-        left_margin = 32; // imgdata.sizes.raw_inset_crop.cleft
+        left_margin = 32; // imgdata.sizes.raw_inset_crops[0].cleft
         top_margin = 8;
         width = raw_width - 2*left_margin;
         height = raw_height - 2*top_margin;
@@ -2823,6 +2882,27 @@ void LibRaw::identify_finetune_dcr(char head[64], int fsize, int flen)
 			width -= 32;
 
 		}
+        else if(unique_id == SonyID_ILCE_1)
+        {
+          if (raw_width == 8704 && raw_height == 6144) // ILCE-1 FF@Compressed
+          {
+            width = 8660;
+            height = 5784;
+          }
+          else if (raw_width == 8672) // FF uncompressed/lossy
+          {
+            width -= 12;
+          }
+          else if (raw_width == 6144 && raw_height == 4096) // APSC/Lossless
+          {
+            width = 5636;
+            height = 3768;
+          }
+          else if (raw_width == 5664) // APS-C/Uncompressed or lossy
+          {
+              width -= 28;
+          }
+        }
 		else if (!strcmp(model, "DSLR-A100")) {
 			if (width == 3880) {
 				height--;
diff --git a/src/metadata/kodak.cpp b/src/metadata/kodak.cpp
index fec43ff0..1193eac3 100644
--- a/src/metadata/kodak.cpp
+++ b/src/metadata/kodak.cpp
@@ -116,13 +116,13 @@ void LibRaw::parse_kodak_ifd(int base)
       fseek(ifp, savepos, SEEK_SET);
     }
     if (tag == 0x03eb) // 1003
-      imgdata.sizes.raw_inset_crop.cleft = get2();
+      imgdata.sizes.raw_inset_crops[0].cleft = get2();
     else if (tag == 0x03ec) // 1004
-      imgdata.sizes.raw_inset_crop.ctop = get2();
+      imgdata.sizes.raw_inset_crops[0].ctop = get2();
     else if (tag == 0x03ed) // 1005
-      imgdata.sizes.raw_inset_crop.cwidth = get2();
+      imgdata.sizes.raw_inset_crops[0].cwidth = get2();
     else if (tag == 0x03ee) // 1006
-      imgdata.sizes.raw_inset_crop.cheight = get2();
+      imgdata.sizes.raw_inset_crops[0].cheight = get2();
     else if (tag == 0x03ef) // 1007
     {
       if (!strcmp(model, "EOS D2000C"))
@@ -326,13 +326,13 @@ void LibRaw::parse_kodak_ifd(int base)
       Kodak_KDC_WBtags(LIBRAW_WBI_Shade, wbi);
 
     else if (tag == 0xfa31) // 64049
-      imgdata.sizes.raw_inset_crop.cwidth = get2();
+      imgdata.sizes.raw_inset_crops[0].cwidth = get2();
     else if (tag == 0xfa32) // 64050
-      imgdata.sizes.raw_inset_crop.cheight = get2();
+      imgdata.sizes.raw_inset_crops[0].cheight = get2();
     else if (tag == 0xfa3e) // 64062
-      imgdata.sizes.raw_inset_crop.cleft = get2();
+      imgdata.sizes.raw_inset_crops[0].cleft = get2();
     else if (tag == 0xfa3f) // 64063
-      imgdata.sizes.raw_inset_crop.ctop = get2();
+      imgdata.sizes.raw_inset_crops[0].ctop = get2();
 
     else if (((tag == 0x07e4) || (tag == 0xfb01)) &&
              (len == 9)) // 2020 or 64257
diff --git a/src/metadata/makernotes.cpp b/src/metadata/makernotes.cpp
index db21cd88..f4bb2cc7 100644
--- a/src/metadata/makernotes.cpp
+++ b/src/metadata/makernotes.cpp
@@ -124,13 +124,14 @@ void LibRaw::parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)
     order = get2();
     if (buf[0] == 'O')
       get2();
+    else if (buf[0] == 'P')
+      is_PentaxRicohMakernotes = 1;
   }
   else if (is_PentaxRicohMakernotes && (dng_writer == CameraDNG))
   {
     base = ftell(ifp) - 10;
     fseek(ifp, -4, SEEK_CUR);
     order = get2();
-    is_PentaxRicohMakernotes = 1;
   }
   else if (!strncmp(buf, "SONY", 4) ||
            !strcmp(buf, "Panasonic"))
@@ -245,7 +246,7 @@ void LibRaw::parse_makernote_0xc634(int base, int uptag, unsigned dng_writer)
         imHassy.SensorCode = getint(type);
       } else if ((tag == 0x0015) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_ASCII)) {
         stmread (imHassy.SensorUnitConnector, len, ifp);
-        for (int i=0; i<len; i++) {
+        for (int i=0; i<(int)len; i++) {
           if(!isalnum(imHassy.SensorUnitConnector[i]) &&
              (imHassy.SensorUnitConnector[i]!=' ')    &&
              (imHassy.SensorUnitConnector[i]!='/')    &&
@@ -384,7 +385,7 @@ void LibRaw::parse_makernote(int base, int uptag)
   unsigned i, wb[4] = {0, 0, 0, 0};
   short morder, sorder = order;
 
-  uchar *CanonCameraInfo;
+  uchar *CanonCameraInfo = 0;;
   unsigned lenCanonCameraInfo = 0;
   unsigned typeCanonCameraInfo = 0;
   imCanon.wbi = 0;
@@ -576,7 +577,8 @@ void LibRaw::parse_makernote(int base, int uptag)
         {
           processCanonCameraInfo(unique_id, CanonCameraInfo, lenCanonCameraInfo,
                                  typeCanonCameraInfo, nonDNG);
-          free(CanonCameraInfo);
+	  if(CanonCameraInfo)
+            free(CanonCameraInfo);
           CanonCameraInfo = 0;
           lenCanonCameraInfo = 0;
         }
diff --git a/src/metadata/mediumformat.cpp b/src/metadata/mediumformat.cpp
index e1bb5028..3ef2c045 100644
--- a/src/metadata/mediumformat.cpp
+++ b/src/metadata/mediumformat.cpp
@@ -20,7 +20,8 @@
 
 void LibRaw::parse_phase_one(int base)
 {
-  unsigned entries, tag, type, len, data, save, i, c;
+  unsigned entries, tag, type, len, data, i, c;
+  INT64 save;
   float romm_cam[3][3];
   char *cp;
 
@@ -76,13 +77,13 @@ void LibRaw::parse_phase_one(int base)
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
         ilm.CurAp = libraw_powf64l(2.0f, (int_to_float(data) / 2.0f));
       else
-        ilm.CurAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));
+        ilm.CurAp = libraw_powf64l(2.0f, float(getreal(type) / 2.0f));
       break;
     case 0x0403:
       if (tagtypeIs(LIBRAW_EXIFTAG_TYPE_LONG))
         ilm.CurFocal = int_to_float(data);
       else
-        ilm.CurFocal = getreal(type);
+        ilm.CurFocal = (float)getreal(type);
       break;
     case 0x0410:
       stmread(ilm.body, len, ifp);
@@ -101,7 +102,7 @@ void LibRaw::parse_phase_one(int base)
       }
       else
       {
-        ilm.MaxAp4CurFocal = libraw_powf64l(2.0f, (getreal(type) / 2.0f));
+        ilm.MaxAp4CurFocal = libraw_powf64l(2.0f, float(getreal(type) / 2.0f));
       }
       break;
     case 0x0415:
@@ -111,7 +112,7 @@ void LibRaw::parse_phase_one(int base)
       }
       else
       {
-        ilm.MinAp4CurFocal = libraw_powf64l(2.0f, (getreal(type) / 2.0f));
+        ilm.MinAp4CurFocal = libraw_powf64l(2.0f, float(getreal(type) / 2.0f));
       }
       break;
     case 0x0416:
@@ -121,7 +122,7 @@ void LibRaw::parse_phase_one(int base)
       }
       else
       {
-        ilm.MinFocal = getreal(type);
+        ilm.MinFocal = (float)getreal(type);
       }
       if (ilm.MinFocal > 1000.0f)
       {
@@ -135,7 +136,7 @@ void LibRaw::parse_phase_one(int base)
       }
       else
       {
-        ilm.MaxFocal = getreal(type);
+        ilm.MaxFocal = (float)getreal(type);
       }
       break;
 
@@ -145,11 +146,11 @@ void LibRaw::parse_phase_one(int base)
     case 0x0106:
       for (i = 0; i < 9; i++)
         imgdata.color.P1_color[0].romm_cam[i] = ((float *)romm_cam)[i] =
-            getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+            (float)getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
       romm_coeff(romm_cam);
       break;
     case 0x0107:
-      FORC3 cam_mul[c] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+      FORC3 cam_mul[c] = (float)getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
       break;
     case 0x0108:
       raw_width = data;
@@ -180,7 +181,7 @@ void LibRaw::parse_phase_one(int base)
       meta_length = len;
       break;
     case 0x0112:
-      ph1.key_off = save - 4;
+      ph1.key_off = int(save - 4);
       break;
     case 0x0210:
       ph1.tag_210 = int_to_float(data);
@@ -209,7 +210,7 @@ void LibRaw::parse_phase_one(int base)
       break;
     case 0x0226:
       for (i = 0; i < 9; i++)
-        imgdata.color.P1_color[1].romm_cam[i] = getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
+        imgdata.color.P1_color[1].romm_cam[i] = (float)getreal(LIBRAW_EXIFTAG_TYPE_FLOAT);
       break;
     case 0x0301:
       model[63] = 0;
@@ -323,10 +324,11 @@ void LibRaw::parse_phase_one(int base)
   }
 }
 
-void LibRaw::parse_mos(int offset)
+void LibRaw::parse_mos(INT64 offset)
 {
   char data[40];
-  int from, i, c, neut[4], planes = 0, frot = 0;
+  int i, c, neut[4], planes = 0, frot = 0;
+  INT64 from;
   unsigned skip;
   static const char *mod[] = {
       /* DM22, DM28, DM40, DM56 are somewhere here too */
diff --git a/src/metadata/misc_parsers.cpp b/src/metadata/misc_parsers.cpp
index 57a22c2c..964bdd95 100644
--- a/src/metadata/misc_parsers.cpp
+++ b/src/metadata/misc_parsers.cpp
@@ -348,10 +348,10 @@ void LibRaw::parse_rollei()
       }
     if (!strcmp(line, "CUTRECT")) {
       sscanf(val, "%hu %hu %hu %hu",
-             &imgdata.sizes.raw_inset_crop.cleft,
-             &imgdata.sizes.raw_inset_crop.ctop,
-             &imgdata.sizes.raw_inset_crop.cwidth,
-             &imgdata.sizes.raw_inset_crop.cheight);
+             &imgdata.sizes.raw_inset_crops[0].cleft,
+             &imgdata.sizes.raw_inset_crops[0].ctop,
+             &imgdata.sizes.raw_inset_crops[0].cwidth,
+             &imgdata.sizes.raw_inset_crops[0].cheight);
     }
   } while (strncmp(line, "EOHD", 4));
   data_offset = thumb_offset + thumb_width * thumb_height * 2;
@@ -600,6 +600,14 @@ void LibRaw::parse_raspberrypi()
 	struct brcm_raw_header header;
 	uint8_t brcm_tag[4];
 
+    if (ftell(ifp) > 22LL) // 22 bytes is minimum jpeg size
+    {
+        thumb_length = ftell(ifp);
+        thumb_offset = 0;
+        thumb_width = thumb_height = 0;
+        load_flags |= 0x4000; // flag: we have JPEG from beginning to meta_offset
+    }
+
 	// Sanity check that the caller has found a BRCM header
 	if (!fread(brcm_tag, 1, sizeof(brcm_tag), ifp) ||
 		memcmp(brcm_tag, "BRCM", sizeof(brcm_tag)))
diff --git a/src/metadata/nikon.cpp b/src/metadata/nikon.cpp
index a637ec24..b46c4d96 100644
--- a/src/metadata/nikon.cpp
+++ b/src/metadata/nikon.cpp
@@ -14,6 +14,13 @@
 
 #include "../../internal/dcraw_defs.h"
 
+// void hexDump(char *title, void *addr, int len);
+
+unsigned sget4_order (short _order, uchar *s);
+double sget_fixed32u (short _order, uchar *s);
+double AngleConversion_a (short _order, uchar *s);
+double AngleConversion (short _order, uchar *s);
+
 static const uchar xlat[2][256] = {
     {0xc1, 0xbf, 0x6d, 0x0d, 0x59, 0xc5, 0x13, 0x9d, 0x83, 0x61, 0x6b, 0x4f,
      0xc7, 0x7f, 0x3d, 0x3d, 0x53, 0x59, 0xe3, 0xc7, 0xe9, 0x2f, 0x95, 0xa7,
@@ -60,12 +67,10 @@ static const uchar xlat[2][256] = {
      0xc6, 0x67, 0x4a, 0xf5, 0xa5, 0x12, 0x65, 0x7e, 0xb0, 0xdf, 0xaf, 0x4e,
      0xb3, 0x61, 0x7f, 0x2f} };
 
-
-
 void LibRaw::processNikonLensData(uchar *LensData, unsigned len)
 {
 
-  ushort i;
+  ushort i=0;
   if (imgdata.lens.nikon.LensType & 0x80) {
     strcpy (ilm.LensFeatures_pre, "AF-P");
   } else if (!(imgdata.lens.nikon.LensType & 0x01)) {
@@ -122,7 +127,7 @@ void LibRaw::processNikonLensData(uchar *LensData, unsigned len)
     case 16:
       i = 8;
       break;
-    case 58: // "Z 6", "Z 7", "Z 50", D780, "Z 5"
+    case 58: // "Z 6", "Z 6 II", "Z 7", "Z 7 II", "Z 50", D780, "Z 5", "Z fc"
       if (model[6] == 'Z')
         ilm.CameraMount = LIBRAW_MOUNT_Nikon_Z;
       if (imNikon.HighSpeedCropFormat != 12)
@@ -138,10 +143,11 @@ void LibRaw::processNikonLensData(uchar *LensData, unsigned len)
           case 11: case 12:
             ilm.LensFormat = LIBRAW_FORMAT_APSC;
             break;
-          case 1:  case 2:  case 4:  case 8:
-          case 9:  case 13: case 14: case 15:
+          case  1: case  2: case  4: case  8:
+          case  9: case 13: case 14: case 15:
           case 16: case 17: case 18: case 21:
-          case 22: case 23:
+          case 22: case 23: case 24: case 27:
+          case 29:
             ilm.LensFormat = LIBRAW_FORMAT_FF;
             break;
         }
@@ -240,13 +246,20 @@ void LibRaw::parseNikonMakernote(int base, int uptag, unsigned dng_writer)
   unsigned offset = 0, entries, tag, type, len, save;
 
   unsigned c, i;
-  uchar *LensData_buf;
+  unsigned LensData_len = 0;
+  uchar *LensData_buf=0;
   uchar ColorBalanceData_buf[324];
   int ColorBalanceData_ready = 0;
   uchar ci, cj, ck;
   unsigned serial = 0;
   unsigned custom_serial = 0;
-  unsigned LensData_len = 0;
+
+  unsigned ShotInfo_len = 0;
+  uchar *ShotInfo_buf=0;
+
+/* for dump:
+uchar *cj_block, *ck_block;
+*/
 
   short morder, sorder = order;
   char buf[10];
@@ -452,27 +465,27 @@ void LibRaw::parseNikonMakernote(int base, int uptag, unsigned dng_writer)
       case 1:
       case 2:
       case 4:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
         break;
       case 11:
         ilm.CameraFormat = LIBRAW_FORMAT_FF;
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
         break;
       case 12:
         ilm.CameraFormat = LIBRAW_FORMAT_APSC;
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
         break;
       case 3:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_5to4;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_5to4;
         break;
       case 6:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
         break;
       case 17:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
         break;
       default:
-        imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_OTHER;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_OTHER;
         break;
       }
     }
@@ -544,10 +557,10 @@ void LibRaw::parseNikonMakernote(int base, int uptag, unsigned dng_writer)
     }
     else if (tag == 0x0045)
     { /* upper left pixel (x,y), size (width,height) */
-      imgdata.sizes.raw_inset_crop.cleft = get2();
-      imgdata.sizes.raw_inset_crop.ctop = get2();
-      imgdata.sizes.raw_inset_crop.cwidth = get2();
-      imgdata.sizes.raw_inset_crop.cheight = get2();
+      imgdata.sizes.raw_inset_crops[0].cleft = get2();
+      imgdata.sizes.raw_inset_crops[0].ctop = get2();
+      imgdata.sizes.raw_inset_crops[0].cwidth = get2();
+      imgdata.sizes.raw_inset_crops[0].cheight = get2();
     }
     else if (tag == 0x0082)
     { // lens attachment
@@ -591,6 +604,20 @@ void LibRaw::parseNikonMakernote(int base, int uptag, unsigned dng_writer)
     {
       meta_offset = ftell(ifp);
     }
+    else if ((tag == 0x0091) && (len > 4))
+    {
+      ShotInfo_len = len;
+      ShotInfo_buf = (uchar *)malloc(ShotInfo_len);
+
+/* for dump:
+cj_block = (uchar *)malloc(ShotInfo_len);
+ck_block = (uchar *)malloc(ShotInfo_len);
+*/
+
+      fread(ShotInfo_buf, ShotInfo_len, 1, ifp);
+      FORC4 imNikon.ShotInfoVersion =
+          imNikon.ShotInfoVersion * 10 + ShotInfo_buf[c] - '0';
+    }
     else if (tag == 0x0093)
     {
       imNikon.NEFCompression = i = get2();
@@ -756,6 +783,89 @@ void LibRaw::parseNikonMakernote(int base, int uptag, unsigned dng_writer)
         LensData_len = 0;
         free(LensData_buf);
       }
+      if (ShotInfo_len && (imNikon.ShotInfoVersion >= 208)) {
+        unsigned RotationOffset = 0,
+                 OrientationOffset = 0;
+
+        cj = xlat[1][imNikon.key];
+        ck = 0x60;
+        for (i = 4; i < ShotInfo_len; i++) {
+          ShotInfo_buf[i] ^= (cj += ci * ck++);
+
+/* for dump:
+cj_block[i-4] = cj;
+ck_block[i-4] = ck-1;
+*/
+        }
+/* for dump:
+printf ("==>> ci: 0x%02x, cj at start: 0x%02x\n",
+ci, xlat[1][imNikon.key]);
+hexDump("ck array:", ck_block, ShotInfo_len-4);
+hexDump("cj array:", cj_block, ShotInfo_len-4);
+free(cj_block);
+free(ck_block);
+*/
+
+        switch (imNikon.ShotInfoVersion) {
+        case 208: // ShotInfoD80, Rotation
+          RotationOffset = 590;
+          if (RotationOffset<ShotInfo_len) {
+            imNikon.MakernotesFlip = *(ShotInfo_buf+RotationOffset) & 0x07;
+          }
+          break;
+
+        case 231: // ShotInfoD4S, Rotation, Roll/Pitch/Yaw
+          OrientationOffset  = 0x350b;
+          RotationOffset     = 0x3693;
+          if (RotationOffset<ShotInfo_len) {
+            imNikon.MakernotesFlip = (*(ShotInfo_buf+RotationOffset)>>4) & 0x03;
+          }
+          break;
+
+        case 233: // ShotInfoD810, Roll/Pitch/Yaw
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0x84);
+          break;
+
+        case 238: // D5,   ShotInfoD500, Rotation, Roll/Pitch/Yaw
+        case 239: // D500, ShotInfoD500, Rotation, Roll/Pitch/Yaw
+          RotationOffset = sget4_order(morder, ShotInfo_buf+0x10) + 0xca;
+          if (RotationOffset > 0xca) {
+            RotationOffset -= 0xb0;
+          }
+          if (RotationOffset<ShotInfo_len) {
+            imNikon.MakernotesFlip = *(ShotInfo_buf+RotationOffset) & 0x03;
+          }
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0xa0);
+          break;
+
+        case 243: // ShotInfoD850, Roll/Pitch/Yaw
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0xa0);
+          break;
+
+        case 246: // ShotInfoD6, Roll/Pitch/Yaw
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0x9c);
+          break;
+
+        case 800: // Z 6, Z 7,     ShotInfoZ7_2, Roll/Pitch/Yaw
+        case 803: // Z 6_2, Z 7_2, ShotInfoZ7_2, Roll/Pitch/Yaw
+          OrientationOffset = sget4_order(morder, ShotInfo_buf+0x98);
+          break;
+//        case 804: // Z fc
+//          break;
+        }
+        if (OrientationOffset && ((OrientationOffset+12)<ShotInfo_len)) {
+          if (imNikon.ShotInfoVersion == 231) // ShotInfoD4S
+            imNikon.RollAngle = AngleConversion_a(morder, ShotInfo_buf+OrientationOffset);
+          else
+            imNikon.RollAngle = AngleConversion(morder, ShotInfo_buf+OrientationOffset);
+          imNikon.PitchAngle  = AngleConversion (morder, ShotInfo_buf+OrientationOffset+4);
+          imNikon.YawAngle    = AngleConversion (morder, ShotInfo_buf+OrientationOffset+8);
+        }
+        if ((RotationOffset) && (imNikon.MakernotesFlip < 4))
+          imNikon.MakernotesFlip = "0863"[imNikon.MakernotesFlip] - '0';
+        ShotInfo_len = 0;
+        free(ShotInfo_buf);
+      }     
     }
     else if (tag == 0x00a8)
     { // contains flash data
@@ -855,3 +965,78 @@ void LibRaw::parseNikonMakernote(int base, int uptag, unsigned dng_writer)
 quit:
   order = sorder;
 }
+
+unsigned sget4_order (short _order, uchar *s) {
+  unsigned v;
+  if (_order == 0x4949)
+    v= s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;
+  else
+    v= s[0] << 24 | s[1] << 16 | s[2] << 8 | s[3];
+  return v;
+}
+
+double sget_fixed32u (short _order, uchar *s) {
+  unsigned v = sget4_order (_order, s);
+  return ((double)v / 6.5536 + 0.5) / 10000.0;
+}
+
+double AngleConversion_a (short _order, uchar *s) {
+  double v = sget_fixed32u(_order, s);
+  if (v < 180.0) return -v;
+  return 360.0-v;
+}
+
+double AngleConversion (short _order, uchar *s) {
+  double v = sget_fixed32u(_order, s);
+  if (v <= 180.0) return v;
+  return v-360.0;
+}
+
+/* ========= */
+/*
+void hexDump(char *title, void *addr, int len) 
+{
+    int i;
+    unsigned char buff[17];
+    unsigned char *pc = (unsigned char*)addr;
+
+    // Output description if given.
+    if (title != NULL)
+        printf ("%s:\n", title);
+
+    // Process every byte in the data.
+    for (i = 0; i < len; i++) {
+        // Multiple of 16 means new line (with line offset).
+
+        if ((i % 16) == 0) {
+            // Just don't print ASCII for the zeroth line.
+            if (i != 0)
+                printf("  %s\n", buff);
+
+            // Output the offset.
+            printf("  %04x ", i);
+        }
+
+        // Now the hex code for the specific character.
+        printf(" %02x", pc[i]);
+
+        // And store a printable ASCII character for later.
+        if ((pc[i] < 0x20) || (pc[i] > 0x7e)) {
+            buff[i % 16] = '.';
+        } else {
+            buff[i % 16] = pc[i];
+        }
+
+        buff[(i % 16) + 1] = '\0';
+    }
+
+    // Pad out last line if not exactly 16 characters.
+    while ((i % 16) != 0) {
+        printf("   ");
+        i++;
+    }
+
+    // And print the final ASCII bit.
+    printf("  %s\n", buff);
+}
+*/
diff --git a/src/metadata/normalize_model.cpp b/src/metadata/normalize_model.cpp
index dd6c5754..e3de0dbb 100644
--- a/src/metadata/normalize_model.cpp
+++ b/src/metadata/normalize_model.cpp
@@ -99,7 +99,9 @@ void LibRaw::GetNormalizedModel()
       { CanonID_EOS_850D,          "EOS 850D"},  // EOS Rebel T8i / X10i
       { CanonID_EOS_250D,          "EOS 250D"}, // Rebel SL3 / 200D II / Kiss X10
       { CanonID_EOS_90D,           "EOS 90D"},
+      { CanonID_EOS_R3,            "EOS R3"},
       { CanonID_EOS_R6,            "EOS R6"},
+      { CanonID_EOS_M50_Mark_II,   "EOS M50 Mark II"}, // M50m2, Kiss M2
     },
 #if 0
     olyque[] = {
@@ -184,6 +186,7 @@ void LibRaw::GetNormalizedModel()
       { OlyID_E_M1_Mark_III,   "E-M1 Mark III"},
       { OlyID_E_M1_Mark_III,   "E-M1MarkIII"},
       { OlyID_E_M1_Mark_III,   "E-M1_M3"},
+      { OlyID_E_P7             "E-P7"},
       { OlyID_C_3030Z,         "C-3030Z"},
       { OlyID_C_3030Z,         "C3030Z"},
       { OlyID_C_5050Z,         "C-5050Z"},
@@ -226,19 +229,19 @@ void LibRaw::GetNormalizedModel()
       { PentaxID_staristDL,    "*ist DL"},
       { PentaxID_staristDS2,   "*istDS2"},
       { PentaxID_staristDS2,   "*ist DS2"},
-      { PentaxID_GX_1S,        "GX-1S"},       // Samsung
+      { PentaxID_GX_1S,        "GX-1S"},        // Samsung
       { PentaxID_staristDL2,   "*istDL2"},
       { PentaxID_staristDL2,   "*ist DL2"},
-      { PentaxID_GX_1L,        "GX-1L"},       // Samsung
+      { PentaxID_GX_1L,        "GX-1L"},        // Samsung
       { PentaxID_K100D,        "K100D"},
       { PentaxID_K110D,        "K110D"},
       { PentaxID_K100D_Super,  "K100D Super"},
       { PentaxID_K10D,         "K10D"},
-      { PentaxID_GX10,         "GX10"},        // Samsung
-      { PentaxID_GX10,         "GX-10"},       // Samsung
+      { PentaxID_GX10,         "GX10"},         // Samsung
+      { PentaxID_GX10,         "GX-10"},        // Samsung
       { PentaxID_K20D,         "K20D"},
-      { PentaxID_GX20,         "GX20"},        // Samsung
-      { PentaxID_GX20,         "GX-20"},       // Samsung
+      { PentaxID_GX20,         "GX20"},         // Samsung
+      { PentaxID_GX20,         "GX-20"},        // Samsung
       { PentaxID_K200D,        "K200D"},
       { PentaxID_K2000,        "K2000"},
       { PentaxID_K_m,          "K-m"},
@@ -260,14 +263,16 @@ void LibRaw::GetNormalizedModel()
       { PentaxID_K_500,        "K-500"},
       { PentaxID_645Z,         "645Z"},
       { PentaxID_K_S1,         "K-S1"},
-      { PentaxID_K_S2,         "K-S2"},        // Ricoh
+      { PentaxID_K_S2,         "K-S2"},         // Ricoh
       { PentaxID_Q_S1,         "Q-S1"},
-      { PentaxID_K_1,          "K-1"},         // Ricoh
-      { PentaxID_K_3_II,       "K-3 II"},      // Ricoh
-      { PentaxID_GR_III,       "GR III"},      // Ricoh
-      { PentaxID_K_70,         "K-70"},        // Ricoh
-      { PentaxID_KP,           "KP"},          // Ricoh
-      { PentaxID_K_1_Mark_II,  "K-1 Mark II"}, // Ricoh
+      { PentaxID_K_1,          "K-1"},          // Ricoh
+      { PentaxID_K_3_II,       "K-3 II"},       // Ricoh
+      { PentaxID_GR_III,       "GR III"},       // Ricoh
+      { PentaxID_K_70,         "K-70"},         // Ricoh
+      { PentaxID_KP,           "KP"},           // Ricoh
+      { PentaxID_K_1_Mark_II,  "K-1 Mark II"},  // Ricoh
+      { PentaxID_K_3_III,      "K-3 Mark III"}, // Ricoh
+      { PentaxID_GR_IIIx,      "GR IIIx"},
     },
 #endif
     sonique[] = {
@@ -356,7 +361,12 @@ void LibRaw::GetNormalizedModel()
       { SonyID_ILCE_6100,      "ILCE-6100"},
       { SonyID_ZV_1,           "ZV-1"},
       { SonyID_ILCE_7C,        "ILCE-7C"},
+      { SonyID_ZV_E10,         "ZV-E10"},
       { SonyID_ILCE_7SM3,      "ILCE-7SM3"},
+      { SonyID_ILCE_1,         "ILCE-1"},
+      { SonyID_ILME_FX3,       "ILME-FX3"},
+      { SonyID_ILCE_7RM3A,     "ILCE-7RM3A"},
+      { SonyID_ILCE_7RM4A,     "ILCE-7RM4A"},
     };
 
   static const char *orig;
@@ -376,6 +386,8 @@ void LibRaw::GetNormalizedModel()
     "@S9100", "S9600",
     "@S200EXR", "S205EXR",
     "@X-T1 IR", "X-T1IR",
+    "@GFX 100S", "GFX100S",
+    "@GFX 50S II", "GFX50S II"
   };
 
   static const char kodakalias[][16] = {
@@ -581,7 +593,7 @@ void LibRaw::GetNormalizedModel()
     }
 #ifdef USE_6BY9RPI
 	else if(strcasestr(make,"RaspberryPi"))
-		setMakeFromIndex(LIBRAW_CAMERAMAKER_Broadcom);
+		setMakeFromIndex(LIBRAW_CAMERAMAKER_RaspberryPi);
 #endif
   }
   else if (makeIs(LIBRAW_CAMERAMAKER_Hasselblad) && is_Sony)
@@ -889,7 +901,6 @@ void LibRaw::GetNormalizedModel()
       }
     }
   } else if (makeIs(LIBRAW_CAMERAMAKER_Pentax)) {
-
     if (!unique_id) {
       if (!strcmp(model, "Optio S")) {
         ilm.CamID = unique_id = PentaxID_Optio_S;
diff --git a/src/metadata/olympus.cpp b/src/metadata/olympus.cpp
index e04b705a..5456ceb2 100644
--- a/src/metadata/olympus.cpp
+++ b/src/metadata/olympus.cpp
@@ -250,9 +250,23 @@ void LibRaw::parseOlympus_CameraSettings(int base, unsigned tag, unsigned type,
       imOly.DriveMode[c] = get2();
     }
     break;
+  case 0x0601:
+  	imOly.Panorama_mode = get2();
+  	imOly.Panorama_frameNum = get2();
+  	break;
   case 0x0604:
     imgdata.shootinginfo.ImageStabilization = get4();
     break;
+  case 0x0804:
+    imOly.StackedImage[0] = get4();
+    imOly.StackedImage[1] = get4();
+    if (imOly.StackedImage[0] == 3) {
+      imOly.isLiveND = 1;
+      imOly.LiveNDfactor = imOly.StackedImage[1];
+    } else {
+      imOly.isLiveND = 0;
+    }
+    break;
   }
 
   return;
@@ -373,19 +387,19 @@ void LibRaw::parseOlympus_ImageProcessing(unsigned tag, unsigned type,
   }
   else if ((tag == 0x0612) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cleft = get2();
+    imgdata.sizes.raw_inset_crops[0].cleft = get2();
   }
   else if ((tag == 0x0613) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.ctop = get2();
+    imgdata.sizes.raw_inset_crops[0].ctop = get2();
   }
   else if ((tag == 0x0614) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cwidth = get2();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get2();
   }
   else if ((tag == 0x0615) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cheight = get2();
+    imgdata.sizes.raw_inset_crops[0].cheight = get2();
   }
   else if ((tag == 0x0805) && (len == 2))
   {
@@ -404,37 +418,38 @@ void LibRaw::parseOlympus_ImageProcessing(unsigned tag, unsigned type,
     case 0x0101:
     case 0x0901:
     case 0x0909:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_4to3;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_4to3;
       break;
     case 0x0104:
     case 0x0401:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
       break;
     case 0x0201:
     case 0x0202:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
       break;
     case 0x0301:
     case 0x0303:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
       break;
     case 0x0404:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_6to6;
+//      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_6to6;
+        imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
       break;
     case 0x0505:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_5to4;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_5to4;
       break;
     case 0x0606:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_7to6;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_7to6;
       break;
     case 0x0707:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_6to5;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_6to5;
       break;
     case 0x0808:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_7to5;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_7to5;
       break;
     default:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_OTHER;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_OTHER;
       break;
     }
   }
@@ -514,19 +529,19 @@ void LibRaw::parseOlympus_RawInfo(unsigned tag, unsigned type, unsigned len,
   }
   else if ((tag == 0x0612) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cleft = get2();
+    imgdata.sizes.raw_inset_crops[0].cleft = get2();
   }
   else if ((tag == 0x0613) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.ctop = get2();
+    imgdata.sizes.raw_inset_crops[0].ctop = get2();
   }
   else if ((tag == 0x0614) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cwidth = get2();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get2();
   }
   else if ((tag == 0x0615) && (dng_writer == nonDNG))
   {
-    imgdata.sizes.raw_inset_crop.cheight = get2();
+    imgdata.sizes.raw_inset_crops[0].cheight = get2();
   }
   return;
 }
@@ -535,7 +550,7 @@ void LibRaw::parseOlympus_RawInfo(unsigned tag, unsigned type, unsigned len,
 void LibRaw::parseOlympusMakernotes (int base, unsigned tag, unsigned type, unsigned len, unsigned dng_writer) {
 
   int c;
-  unsigned a, b;
+  unsigned a;
   if ((tag >= 0x20100000) && (tag <= 0x2010ffff)) {
         parseOlympus_Equipment((tag & 0x0000ffff), type, len, dng_writer);
 
@@ -655,7 +670,7 @@ void LibRaw::parseOlympusMakernotes (int base, unsigned tag, unsigned type, unsi
 			  break;
 			case 0x20500305:
 			  a = get4();
-			  b = get4();
+			  /*b = */ get4(); // b is not used, so removed
 			  if (a >= 0x7f000000) imOly.FocusDistance = -1.0; // infinity
 			  else imOly.FocusDistance = (double) a / 1000.0;  // convert to meters
 			  break;
diff --git a/src/metadata/pentax.cpp b/src/metadata/pentax.cpp
index 9ba2365b..559b3570 100644
--- a/src/metadata/pentax.cpp
+++ b/src/metadata/pentax.cpp
@@ -53,6 +53,7 @@ void LibRaw::setPentaxBodyFeatures(unsigned long long id)
   case PentaxID_K_S1:
   case PentaxID_K_S2:
   case PentaxID_K_3_II:
+  case PentaxID_K_3_III:
   case PentaxID_K_70:
   case PentaxID_KP:
     ilm.CameraMount = LIBRAW_MOUNT_Pentax_K;
@@ -85,6 +86,7 @@ void LibRaw::setPentaxBodyFeatures(unsigned long long id)
     ilm.FocalType = LIBRAW_FT_ZOOM_LENS;
     break;
   case PentaxID_GR_III:
+  case PentaxID_GR_IIIx:
     ilm.CameraMount = LIBRAW_MOUNT_FixedLens;
     ilm.LensMount = LIBRAW_MOUNT_FixedLens;
     ilm.CameraFormat = LIBRAW_FORMAT_APSC;
@@ -326,20 +328,25 @@ void LibRaw::parsePentaxMakernotes(int base, unsigned tag, unsigned type,
   }
   else if (tag == 0x0038)
   {
-    imgdata.sizes.raw_inset_crop.cleft = get2();
-    imgdata.sizes.raw_inset_crop.ctop = get2();
+    imgdata.sizes.raw_inset_crops[0].cleft = get2();
+    imgdata.sizes.raw_inset_crops[0].ctop = get2();
   }
   else if (tag == 0x0039)
   {
-    imgdata.sizes.raw_inset_crop.cwidth = get2();
-    imgdata.sizes.raw_inset_crop.cheight = get2();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get2();
+    imgdata.sizes.raw_inset_crops[0].cheight = get2();
   }
   else if (tag == 0x003c)
   {
-    if ((len == 4) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED))
+    if ((len == 4) && tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED)) {
       imPentax.AFPointsInFocus = get4() & 0x7ff;
-      if (!imPentax.AFPointsInFocus) imPentax.AFPointsInFocus = 0xffffffff;
-      else imPentax.AFPointsInFocus_version = 1;
+      if (!imPentax.AFPointsInFocus) {
+        imPentax.AFPointsInFocus = 0xffffffff;
+      }
+      else {
+        imPentax.AFPointsInFocus_version = 1;
+      }
+    }
   }
   else if (tag == 0x003f)
   {
@@ -378,16 +385,16 @@ void LibRaw::parsePentaxMakernotes(int base, unsigned tag, unsigned type,
     switch (a)
     {
     case 0:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_4to3;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_4to3;
       break;
     case 1:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_3to2;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_3to2;
       break;
     case 2:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_16to9;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_16to9;
       break;
     case 3:
-      imgdata.sizes.raw_inset_crop.aspect = LIBRAW_IMAGE_ASPECT_1to1;
+      imgdata.sizes.raw_aspect = LIBRAW_IMAGE_ASPECT_1to1;
       break;
     }
   }
@@ -434,6 +441,12 @@ void LibRaw::parsePentaxMakernotes(int base, unsigned tag, unsigned type,
   {
     FORC4 icWBC[Pentax_wb_list1[tag - 0x020d]][RGGB_2_RGBG(c)] = get2();
   }
+  else if ((tag == 0x021d) && (len == 18) &&
+           tagtypeIs(LIBRAW_EXIFTAG_TYPE_UNDEFINED) && (dng_writer == nonDNG))
+  {
+    for (int i = 0; i < 3; i++)
+      FORC3 cmatrix[i][c] = ((short)get2()) / 8192.0;
+  }
   else if (tag == 0x021f)
   {
     if ((unique_id != PentaxID_K_1)    &&
@@ -476,10 +489,10 @@ void LibRaw::parsePentaxMakernotes(int base, unsigned tag, unsigned type,
   {
     int wb_ind;
     getc(ifp);
-    for (int wb_cnt = 0; wb_cnt < Pentax_wb_list2.size(); wb_cnt++)
+    for (int wb_cnt = 0; wb_cnt < (int)Pentax_wb_list2.size(); wb_cnt++)
     {
       wb_ind = getc(ifp);
-      if (wb_ind >= 0 && wb_ind < Pentax_wb_list2.size() )
+      if (wb_ind >= 0 && wb_ind < (int)Pentax_wb_list2.size() )
         FORC4 icWBC[Pentax_wb_list2[wb_ind]][RGGB_2_RGBG(c)] = get2();
     }
   }
diff --git a/src/metadata/sony.cpp b/src/metadata/sony.cpp
index 7621a618..8366813b 100644
--- a/src/metadata/sony.cpp
+++ b/src/metadata/sony.cpp
@@ -132,7 +132,7 @@ void LibRaw::setSonyBodyFeatures(unsigned long long id)
     scf[1]  camera format
     scf[2]  camera mount: Minolta A, Sony E, fixed,
     scf[3]  camera type: DSLR, NEX, SLT, ILCE, ILCA, DSC
-    scf[4]  lens mount
+    scf[4]  lens mount, LIBRAW_MOUNT_FixedLens or LIBRAW_MOUNT_Unknown
     scf[5]  tag 0x2010 group (0 if not used)
     scf[6]  offset of Sony ISO in 0x2010 table, 0xffff if not valid
     scf[7]  offset of ShutterCount3 in 0x9050 table, 0xffff if not valid
@@ -141,177 +141,189 @@ void LibRaw::setSonyBodyFeatures(unsigned long long id)
     scf[10] offset of ReleaseMode2 in 0x2010 table, 0xffff if not valid
     */
   } SonyCamFeatures[] = {
-      {SonyID_DSLR_A100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A900, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A700, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A200, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A350, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A900, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A380, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A330, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A230, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A290, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A850, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A850, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A550, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A500, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A450, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_NEX_5, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_NEX_3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_SLT_A33, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_SLT_A55, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A560, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_DSLR_A580, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, 0,
-       0, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_NEX_C3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_SLT_A35, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 0,
-       0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
-      {SonyID_SLT_A65, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 2,
-       0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
-      {SonyID_SLT_A77, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 2,
-       0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
-      {SonyID_NEX_5N, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 1,
-       0x113e, 0x01bd, 0x1174, 0x1175, 0x112c},
-      {SonyID_NEX_7, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 2,
-       0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
-      {SonyID_NEX_VG20, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 2,
-       0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
-      {SonyID_SLT_A37, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 3,
-       0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
-      {SonyID_SLT_A57, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 3,
-       0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
-      {SonyID_NEX_F3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 3,
-       0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
-      {SonyID_SLT_A99, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_6, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_5R, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_DSC_RX100, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 5, 0x1254, 0xffff, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_DSC_RX1, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 5, 0x1258, 0xffff, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_VG900, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_VG30, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_ILCE_3000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 5,
-       0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_SLT_A58, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, 0, 5,
-       0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_NEX_3N, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_ILCE_7, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_NEX_5T, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, 0, 5,
-       0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_DSC_RX100M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 6, 0x113c, 0xffff, 0x1064, 0x1065, 0x1018},
-      {SonyID_DSC_RX10, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 7, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX1R, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 5, 0x1258, 0xffff, 0x11ac, 0x11ad, 0x1160},
-      {SonyID_ILCE_7R, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_6000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_5000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0x01aa, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX100M3, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 7, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7S, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCA_77M2, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0,
-       7, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_5100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX100M4, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX10M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX1RM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_QX1, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 7,
-       0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7RM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8,
-       0x0346, 0x01cb, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7SM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8,
-       0x0346, 0x01cb, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCA_68, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0,
-       7, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCA_99M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, 0, 8,
-       0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX10M3, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX100M5, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_6300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8,
-       0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_9, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_6500, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 8,
-       0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
-      {SonyID_ILCE_7RM3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_7M3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_RX0, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 8, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
-      {SonyID_DSC_RX10M4, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_RX100M6, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_HX99, LIBRAW_FORMAT_1div2p3INCH, LIBRAW_MOUNT_FixedLens,
-       LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b,
-       0x024c, 0x0208},
-      {SonyID_DSC_RX100M5A, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_6400, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_RX0M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_DSC_RX100M7, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_7RM4, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_9M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_6600, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_6100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ZV_1, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC,
-       LIBRAW_MOUNT_FixedLens, 9, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_7C, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
-      {SonyID_ILCE_7SM3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, 0, 9,
-       0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSLR_A100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A900, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A700, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A200, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A350, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A900, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A380, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A330, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A230, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A290, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A850, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A850, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A550, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A500, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A450, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_NEX_5, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_NEX_3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_SLT_A33, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_SLT_A55, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A560, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_DSLR_A580, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_DSLR, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_NEX_C3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_SLT_A35, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_SLT_A65, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010b, 0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
+      {SonyID_SLT_A77, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010b, 0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
+      {SonyID_NEX_5N, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010a, 0x113e, 0x01bd, 0x1174, 0x1175, 0x112c},
+      {SonyID_NEX_7, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010b, 0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
+      {SonyID_NEX_VG20, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010b, 0x1218, 0x01bd, 0x1178, 0x1179, 0x112c},
+      {SonyID_SLT_A37, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010c, 0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
+      {SonyID_SLT_A57, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010c, 0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
+      {SonyID_NEX_F3, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010c, 0x11f4, 0x01bd, 0x1154, 0x1155, 0x1108},
+      {SonyID_SLT_A99, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_6, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_5R, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_DSC_RX100, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0xffff, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_DSC_RX1, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010e, 0x1258, 0xffff, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_VG900, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_VG30, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_ILCE_3000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_SLT_A58, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_SLT, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_NEX_3N, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1280, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_ILCE_7, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_NEX_5T, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_NEX, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010e, 0x1254, 0x01aa, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_DSC_RX100M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010f, 0x113c, 0xffff, 0x1064, 0x1065, 0x1018},
+      {SonyID_DSC_RX10, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX1R, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010e, 0x1258, 0xffff, 0x11ac, 0x11ad, 0x1160},
+      {SonyID_ILCE_7R, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_6000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_5000, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01aa, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX100M3, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7S, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCA_77M2, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_5100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX100M4, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX10M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX1RM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_QX1, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7RM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cb, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7SM2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cb, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCA_68, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010g, 0x0344, 0x01a0, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCA_99M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Minolta_A, LIBRAW_SONY_ILCA, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX10M3, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX100M5, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_6300, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_9, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_6500, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0x01cd, 0x025c, 0x025d, 0x0210},
+      {SonyID_ILCE_7RM3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_7M3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX0, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010h, 0x0346, 0xffff, 0x025c, 0x025d, 0x0210},
+      {SonyID_DSC_RX10M4, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX100M6, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_HX99, LIBRAW_FORMAT_1div2p3INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX100M5A, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_6400, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX0M2, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_DSC_RX100M7, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_7RM4, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_9M2, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_6600, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_6100, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ZV_1, LIBRAW_FORMAT_1INCH, LIBRAW_MOUNT_FixedLens, LIBRAW_SONY_DSC, LIBRAW_MOUNT_FixedLens,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0xffff, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_7C, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+
+// a la SonyID_ILCE_6100
+      {SonyID_ZV_E10, LIBRAW_FORMAT_APSC, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+
+      {SonyID_ILCE_7SM3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_ILCE_1, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_ILME_FX3, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010None, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff},
+      {SonyID_ILCE_7RM3A, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
+      {SonyID_ILCE_7RM4A, LIBRAW_FORMAT_FF, LIBRAW_MOUNT_Sony_E, LIBRAW_SONY_ILCE, LIBRAW_MOUNT_Unknown,
+       LIBRAW_SONY_Tag2010i, 0x0320, 0x019f, 0x024b, 0x024c, 0x0208},
   };
   ilm.CamID = id;
 
@@ -319,10 +331,12 @@ void LibRaw::setSonyBodyFeatures(unsigned long long id)
   {
     ilm.CameraMount = ilm.LensMount = LIBRAW_MOUNT_FixedLens;
     imSony.CameraType = LIBRAW_SONY_DSC;
+    imSony.group2010 = LIBRAW_SONY_Tag2010None;
+    imSony.group9050 = LIBRAW_SONY_Tag9050None;
     return;
   }
 
-  for (int i = 0; i < (sizeof SonyCamFeatures / sizeof *SonyCamFeatures); i++) {
+  for (unsigned i = 0; i < (sizeof SonyCamFeatures / sizeof *SonyCamFeatures); i++) {
     if (SonyCamFeatures[i].scf[0] == id) {
       ilm.CameraFormat = SonyCamFeatures[i].scf[1];
       ilm.CameraMount = SonyCamFeatures[i].scf[2];
@@ -339,6 +353,40 @@ void LibRaw::setSonyBodyFeatures(unsigned long long id)
     }
   }
 
+  switch (id) {
+  case SonyID_ILCE_6100:
+  case SonyID_ILCE_6300:
+  case SonyID_ILCE_6400:
+  case SonyID_ILCE_6500:
+  case SonyID_ILCE_6600:
+  case SonyID_ILCE_7C:
+  case SonyID_ILCE_7M3:
+  case SonyID_ILCE_7RM2:
+  case SonyID_ILCE_7RM3A:
+  case SonyID_ILCE_7RM3:
+  case SonyID_ILCE_7RM4:
+  case SonyID_ILCE_7RM4A:
+  case SonyID_ILCE_7SM2:
+  case SonyID_ILCE_9:
+  case SonyID_ILCE_9M2:
+  case SonyID_ILCA_99M2:
+  case SonyID_ZV_E10:
+    imSony.group9050 = LIBRAW_SONY_Tag9050b;
+    break;
+  case SonyID_ILCE_7SM3:
+  case SonyID_ILCE_1:
+  case SonyID_ILME_FX3:
+    imSony.group9050 = LIBRAW_SONY_Tag9050c;
+    break;
+  default:
+    if ((imSony.CameraType != LIBRAW_SONY_DSC) &&
+        (imSony.CameraType != LIBRAW_SONY_DSLR))
+      imSony.group9050 = LIBRAW_SONY_Tag9050a;
+    else
+      imSony.group9050 = LIBRAW_SONY_Tag9050None;
+    break;
+  }
+
   char *sbstr = strstr(software, " v");
   if (sbstr != NULL)
   {
@@ -370,6 +418,12 @@ void LibRaw::setSonyBodyFeatures(unsigned long long id)
         imSony.ImageCount3_offset = 0x01b6;
     }
   }
+
+  if ((id == SonyID_ILCE_7SM3) &&
+      !strcmp(model, "MODEL-NAME")) {
+    imSony.group9050 = LIBRAW_SONY_Tag9050a;
+  }
+
 }
 
 void LibRaw::parseSonyLensType2(uchar a, uchar b)
@@ -385,11 +439,12 @@ void LibRaw::parseSonyLensType2(uchar a, uchar b)
       ilm.AdapterID = lid2;
       switch (lid2)
       {
-      case 1: // Sony LA-EA1 or Sigma MC-11 Adapter
-      case 2: // Sony LA-EA2
-      case 3: // Sony LA-EA3
-      case 6: // Sony LA-EA4
-      case 7: // Sony LA-EA5
+      case     1: // Sony LA-EA1 or Sigma MC-11 Adapter
+      case     2: // Sony LA-EA2
+      case     3: // Sony LA-EA3
+      case     6: // Sony LA-EA4
+      case     7: // Sony LA-EA5
+      case 24593: // LA-EA4r MonsterAdapter, id = 0x6011
         ilm.LensMount = LIBRAW_MOUNT_Minolta_A;
         break;
       case  44: // Metabones Canon EF Smart Adapter
@@ -517,8 +572,8 @@ void LibRaw::process_Sony_0x0116(uchar *buf, ushort len, unsigned long long id)
 
 void LibRaw::process_Sony_0x2010(uchar *buf, ushort len)
 {
-  if (!imSony.group2010)
-    return;
+
+  if (imSony.group2010 == LIBRAW_SONY_Tag2010None) return;
 
   if ((imSony.real_iso_offset != 0xffff) &&
       (len >= (imSony.real_iso_offset + 2)) && (imCommon.real_ISO < 0.1f))
@@ -554,25 +609,15 @@ void LibRaw::process_Sony_0x9050(uchar *buf, ushort len, unsigned long long id)
   uchar s[4];
   int c;
 
-  if ((id == SonyID_ILCE_7SM3) &&
-      strcmp(model, "MODEL-NAME")) // ? check the firmware version instead ?
-  {
-    if (len <= 0x8d)
-      return;
-    unsigned long long b88 = SonySubstitution[buf[0x88]];
-    unsigned long long b89 = SonySubstitution[buf[0x89]];
-    unsigned long long b8a = SonySubstitution[buf[0x8a]];
-    unsigned long long b8b = SonySubstitution[buf[0x8b]];
-    unsigned long long b8c = SonySubstitution[buf[0x8c]];
-    unsigned long long b8d = SonySubstitution[buf[0x8d]];
-    sprintf(imgdata.shootinginfo.InternalBodySerial, "%06llx",
-            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) +
-                b8d);
-    return;
-  }
+  if ((imSony.group9050 == LIBRAW_SONY_Tag9050None) &&
+      (imSony.CameraType != LIBRAW_SONY_DSC) &&
+      (imSony.CameraType != LIBRAW_SONY_DSLR))
+    imSony.group9050 = LIBRAW_SONY_Tag9050a;
+
+  if (imSony.group9050 == LIBRAW_SONY_Tag9050None) return;
 
   if ((ilm.CameraMount != LIBRAW_MOUNT_Sony_E) &&
-      (ilm.CameraMount != LIBRAW_MOUNT_FixedLens))
+      (imSony.CameraType != LIBRAW_SONY_DSC))
   {
     if (len < 2)
       return;
@@ -589,23 +634,9 @@ void LibRaw::process_Sony_0x9050(uchar *buf, ushort len, unsigned long long id)
              10.0f) / 10.0f;
   }
 
-  if ((id == SonyID_ILCE_6100) ||
-      (id == SonyID_ILCE_6300) ||
-      (id == SonyID_ILCE_6400) ||
-      (id == SonyID_ILCE_6500) ||
-      (id == SonyID_ILCE_6600) ||
-      (id == SonyID_ILCE_7C)   ||
-      (id == SonyID_ILCE_7M3)  ||
-      (id == SonyID_ILCE_7RM2) ||
-      (id == SonyID_ILCE_7RM3) ||
-      (id == SonyID_ILCE_7RM4) ||
-      (id == SonyID_ILCE_7SM2) ||
-      (id == SonyID_ILCE_9)    ||
-      (id == SonyID_ILCE_9M2)  ||
-      (id == SonyID_ILCA_99M2)) // 9050 ver.b
-  {
-    if (len <= 0x8d)
-      return;
+  if ((imSony.group9050 == LIBRAW_SONY_Tag9050b) ||
+      (imSony.group9050 == LIBRAW_SONY_Tag9050c)) {
+    if (len <= 0x8d) return;
     unsigned long long b88 = SonySubstitution[buf[0x88]];
     unsigned long long b89 = SonySubstitution[buf[0x89]];
     unsigned long long b8a = SonySubstitution[buf[0x8a]];
@@ -613,37 +644,34 @@ void LibRaw::process_Sony_0x9050(uchar *buf, ushort len, unsigned long long id)
     unsigned long long b8c = SonySubstitution[buf[0x8c]];
     unsigned long long b8d = SonySubstitution[buf[0x8d]];
     sprintf(imgdata.shootinginfo.InternalBodySerial, "%06llx",
-            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) +
-                b8d);
-  }
-  else if ((ilm.CameraMount == LIBRAW_MOUNT_Sony_E) &&
-           (id != SonyID_NEX_5N) &&
-           (id != SonyID_NEX_7)  &&
-           (id != SonyID_NEX_VG20)) // other 9050 versions
-  {
-    if (len <= 0x7f)
-      return;
-    unsigned b7c = SonySubstitution[buf[0x7c]];
-    unsigned b7d = SonySubstitution[buf[0x7d]];
-    unsigned b7e = SonySubstitution[buf[0x7e]];
-    unsigned b7f = SonySubstitution[buf[0x7f]];
-    sprintf(imgdata.shootinginfo.InternalBodySerial, "%04x",
-            (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);
-  }
-  else if (ilm.CameraMount == LIBRAW_MOUNT_Minolta_A)
-  {
-    if (len <= 0xf4)
-      return;
-    unsigned long long bf0 = SonySubstitution[buf[0xf0]];
-    unsigned long long bf1 = SonySubstitution[buf[0xf1]];
-    unsigned long long bf2 = SonySubstitution[buf[0xf2]];
-    unsigned long long bf3 = SonySubstitution[buf[0xf3]];
-    unsigned long long bf4 = SonySubstitution[buf[0xf4]];
-    sprintf(imgdata.shootinginfo.InternalBodySerial, "%05llx",
-            (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);
-  }
-
-  if (ilm.CameraMount != LIBRAW_MOUNT_FixedLens)
+            (b88 << 40) + (b89 << 32) + (b8a << 24) + (b8b << 16) + (b8c << 8) + b8d);
+
+  } else if (imSony.group9050 == LIBRAW_SONY_Tag9050a) {
+      if ((ilm.CameraMount == LIBRAW_MOUNT_Sony_E) &&
+             (id != SonyID_NEX_5N) &&
+             (id != SonyID_NEX_7)  &&
+             (id != SonyID_NEX_VG20)) {
+      if (len <= 0x7f) return;
+      unsigned b7c = SonySubstitution[buf[0x7c]];
+      unsigned b7d = SonySubstitution[buf[0x7d]];
+      unsigned b7e = SonySubstitution[buf[0x7e]];
+      unsigned b7f = SonySubstitution[buf[0x7f]];
+      sprintf(imgdata.shootinginfo.InternalBodySerial, "%04x",
+              (b7c << 24) + (b7d << 16) + (b7e << 8) + b7f);
+
+    } else if (ilm.CameraMount == LIBRAW_MOUNT_Minolta_A) {
+      if (len <= 0xf4) return;
+      unsigned long long bf0 = SonySubstitution[buf[0xf0]];
+      unsigned long long bf1 = SonySubstitution[buf[0xf1]];
+      unsigned long long bf2 = SonySubstitution[buf[0xf2]];
+      unsigned long long bf3 = SonySubstitution[buf[0xf3]];
+      unsigned long long bf4 = SonySubstitution[buf[0xf4]];
+      sprintf(imgdata.shootinginfo.InternalBodySerial, "%05llx",
+              (bf0 << 32) + (bf1 << 24) + (bf2 << 16) + (bf3 << 8) + bf4);
+    }
+  }
+
+  if (imSony.CameraType != LIBRAW_SONY_DSC)
   {
     if (len <= 0x106)
       return;
@@ -748,38 +776,21 @@ void LibRaw::process_Sony_0x9400(uchar *buf, ushort len, unsigned long long id)
   if (((bufx == 0x23) ||
        (bufx == 0x24) ||
        (bufx == 0x26) ||
-       (bufx == 0x28)) &&
+       (bufx == 0x28) ||
+       (bufx == 0x31)) &&
       (len >= 0x1f)) // 0x9400 'c' version
   {
+    imSony.Sony0x9400_version = 0xc;
+    imSony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x09]];
 
-    if ((id == SonyID_ILCE_6100)    ||
-        (id == SonyID_ILCE_6400)    ||
-        (id == SonyID_ILCE_6600)    ||
-        (id == SonyID_ILCE_7M3)     ||
-        (id == SonyID_ILCE_7RM3)    ||
-        (id == SonyID_ILCE_7RM4)    ||
-        (id == SonyID_ILCE_9)       ||
-        (id == SonyID_ILCE_9M2)     ||
-        (id == SonyID_DSC_RX10M4)   ||
-        (id == SonyID_DSC_RX100M5A) ||
-        (id == SonyID_DSC_RX100M6)  ||
-        (id == SonyID_DSC_RX100M7)  ||
-        (id == SonyID_DSC_HX99)     ||
-        (id == SonyID_DSC_RX0M2)    ||
-        (id == SonyID_ZV_1))
-    {
-      imSony.ShotNumberSincePowerUp = SonySubstitution[buf[0x0a]];
-    }
-    else
-    {
+    if ((imSony.group2010 == LIBRAW_SONY_Tag2010g) ||
+        (imSony.group2010 == LIBRAW_SONY_Tag2010h)) {
       FORC4 s[c] = SonySubstitution[buf[0x0a + c]];
       imSony.ShotNumberSincePowerUp = sget4(s);
+    } else {
+      imSony.ShotNumberSincePowerUp = SonySubstitution[buf[0x0a]];
     }
 
-    imSony.Sony0x9400_version = 0xc;
-
-    imSony.Sony0x9400_ReleaseMode2 = SonySubstitution[buf[0x09]];
-
     FORC4 s[c] = SonySubstitution[buf[0x12 + c]];
     imSony.Sony0x9400_SequenceImageNumber = sget4(s);
 
@@ -947,7 +958,7 @@ void LibRaw::process_Sony_0x940e(uchar *buf, ushort len, unsigned long long id)
     imCommon.afdata[imCommon.afcount].AFInfoData_order = order;
     imCommon.afdata[imCommon.afcount].AFInfoData_length = len;
     imCommon.afdata[imCommon.afcount].AFInfoData = (uchar *)malloc(imCommon.afdata[imCommon.afcount].AFInfoData_length);
-    FORC(imCommon.afdata[imCommon.afcount].AFInfoData_length)
+    FORC((int)imCommon.afdata[imCommon.afcount].AFInfoData_length)
       imCommon.afdata[imCommon.afcount].AFInfoData[c] = SonySubstitution[buf[c]];
     imCommon.afcount++;
   }
@@ -1612,13 +1623,7 @@ void LibRaw::parseSonyMakernotes(
   else if (tag == 0x201b)
   {
     if ((imSony.CameraType != LIBRAW_SONY_DSC) ||
-        (ilm.CamID == SonyID_DSC_RX10M4)   ||
-        (ilm.CamID == SonyID_DSC_RX100M6)  ||
-        (ilm.CamID == SonyID_DSC_RX100M5A) ||
-        (ilm.CamID == SonyID_DSC_RX0M2)    ||
-        (ilm.CamID == SonyID_DSC_HX99)     ||
-        (ilm.CamID == SonyID_DSC_RX100M7)  ||
-        (ilm.CamID == SonyID_ZV_1))
+        (imSony.group2010 == LIBRAW_SONY_Tag2010i))
     {
       short t = (short)fgetc(ifp);
       if (imgdata.shootinginfo.FocusMode != t)
@@ -1668,13 +1673,7 @@ void LibRaw::parseSonyMakernotes(
   else if (tag == 0x2021) // AFTracking
   {
     if ((imSony.CameraType != LIBRAW_SONY_DSC) ||
-        (ilm.CamID == SonyID_DSC_RX10M4)   ||
-        (ilm.CamID == SonyID_DSC_RX100M6)  ||
-        (ilm.CamID == SonyID_DSC_RX100M5A) ||
-        (ilm.CamID == SonyID_DSC_RX0M2)    ||
-        (ilm.CamID == SonyID_DSC_HX99)     ||
-        (ilm.CamID == SonyID_DSC_RX100M7)  ||
-        (ilm.CamID == SonyID_ZV_1))
+        (imSony.group2010 == LIBRAW_SONY_Tag2010i))
     {
       imSony.AFTracking = fgetc(ifp);
     }
@@ -1944,11 +1943,11 @@ void LibRaw::parseSonyMakernotes(
     }
     free(table_buf);
   }
-  else if ((tag == 0xb02b) && !imgdata.sizes.raw_inset_crop.cwidth &&
+  else if ((tag == 0xb02b) && !imgdata.sizes.raw_inset_crops[0].cwidth &&
            (len == 2))
   {
-    imgdata.sizes.raw_inset_crop.cheight = get4();
-    imgdata.sizes.raw_inset_crop.cwidth = get4();
+    imgdata.sizes.raw_inset_crops[0].cheight = get4();
+    imgdata.sizes.raw_inset_crops[0].cwidth = get4();
   }
   else if (tag == 0xb041)
   {
@@ -2187,7 +2186,7 @@ void LibRaw::parseSonySRF(unsigned len)
                                           un-encrypted metadata field after SRF0 */
 
       unsigned i, nWB;
-      unsigned MasterKey, SRF2Key;
+      unsigned MasterKey, SRF2Key=0;
       INT64 srf_offset, tag_offset, tag_dataoffset;
       int tag_dataunitlen;
       //uchar *srf_buf;
diff --git a/src/metadata/tiff.cpp b/src/metadata/tiff.cpp
index d55fdc94..edb30a62 100644
--- a/src/metadata/tiff.cpp
+++ b/src/metadata/tiff.cpp
@@ -39,6 +39,10 @@ int LibRaw::parse_tiff_ifd(int base)
   for (j = 0; j < 4; j++)
     for (i = 0; i < 4; i++)
       cc[j][i] = i == j;
+
+  if (!libraw_internal_data.unpacker_data.ifd0_offset)
+    libraw_internal_data.unpacker_data.ifd0_offset = base;
+
   entries = get2();
   if (entries > 512)
     return 1;
@@ -103,21 +107,31 @@ int LibRaw::parse_tiff_ifd(int base)
           fseek(ifp, tiff_ifd[ifd].offset, SEEK_SET);
           if (ljpeg_start(&jh, 1))
           {
-            tiff_ifd[ifd].comp = 6;
-            tiff_ifd[ifd].t_width = jh.wide;
-            tiff_ifd[ifd].t_height = jh.high;
-            tiff_ifd[ifd].bps = jh.bits;
-            tiff_ifd[ifd].samples = jh.clrs;
-            if (!(jh.sraw || (jh.clrs & 1)))
-              tiff_ifd[ifd].t_width *= jh.clrs;
-            if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)
+            if (!dng_version && !strcasecmp(make, "SONY") && tiff_ifd[ifd].phint == 32803 &&
+                tiff_ifd[ifd].comp == 7) // Sony/lossless compressed IFD
             {
-              tiff_ifd[ifd].t_width /= 2;
-              tiff_ifd[ifd].t_height *= 2;
+              tiff_ifd[ifd].comp = 6;
+              tiff_ifd[ifd].bps = jh.bits;
+              tiff_ifd[ifd].samples = 1;
+            }
+            else
+            {
+              tiff_ifd[ifd].comp = 6;
+              tiff_ifd[ifd].bps = jh.bits;
+              tiff_ifd[ifd].t_width = jh.wide;
+              tiff_ifd[ifd].t_height = jh.high;
+              tiff_ifd[ifd].samples = jh.clrs;
+              if (!(jh.sraw || (jh.clrs & 1)))
+                tiff_ifd[ifd].t_width *= jh.clrs;
+              if ((tiff_ifd[ifd].t_width > 4 * tiff_ifd[ifd].t_height) & ~jh.clrs)
+              {
+                tiff_ifd[ifd].t_width /= 2;
+                tiff_ifd[ifd].t_height *= 2;
+              }
+              i = order;
+              parse_tiff(tiff_ifd[ifd].offset + 12);
+              order = i;
             }
-            i = order;
-            parse_tiff(tiff_ifd[ifd].offset + 12);
-            order = i;
           }
         }
         break;
@@ -128,7 +142,7 @@ int LibRaw::parse_tiff_ifd(int base)
       switch (tag)
       {
       case 0x0004: /*   4, SensorTopBorder */
-        imgdata.sizes.raw_inset_crop.ctop = get2();
+        imgdata.sizes.raw_inset_crops[0].ctop = get2();
         break;
       case 0x000a: /*  10, BitsPerSample */
         pana_bpp = get2();
@@ -140,6 +154,10 @@ int LibRaw::parse_tiff_ifd(int base)
       case 0x000f: /*  15, LinearityLimitGreen */
       case 0x0010: /*  16, LinearityLimitBlue */
         imgdata.color.linear_max[tag - 14] = get2();
+        if (imgdata.color.linear_max[tag - 14] == 16383)
+            imgdata.color.linear_max[tag - 14] -= 64;
+        if (imgdata.color.linear_max[tag - 14] == 4095)
+          imgdata.color.linear_max[tag - 14] -= 16;
         if (tag == 0x000f) // 15, LinearityLimitGreen
           imgdata.color.linear_max[3] = imgdata.color.linear_max[1];
         break;
@@ -184,18 +202,18 @@ int LibRaw::parse_tiff_ifd(int base)
         pana_encoding = get2();
         break;
       case 0x002f: /*  47, CropTop */
-        imgdata.sizes.raw_inset_crop.ctop = get2();
+        imgdata.sizes.raw_inset_crops[0].ctop = get2();
         break;
       case 0x0030: /*  48, CropLeft */
-        imgdata.sizes.raw_inset_crop.cleft = get2();
+        imgdata.sizes.raw_inset_crops[0].cleft = get2();
         break;
       case 0x0031: /*  49, CropBottom */
-        imgdata.sizes.raw_inset_crop.cheight =
-            get2() - imgdata.sizes.raw_inset_crop.ctop;
+        imgdata.sizes.raw_inset_crops[0].cheight =
+            get2() - imgdata.sizes.raw_inset_crops[0].ctop;
         break;
       case 0x0032: /*  50, CropRight */
-        imgdata.sizes.raw_inset_crop.cwidth =
-            get2() - imgdata.sizes.raw_inset_crop.cleft;
+        imgdata.sizes.raw_inset_crops[0].cwidth =
+            get2() - imgdata.sizes.raw_inset_crops[0].cleft;
         break;
       case 0x0037: /*  55, ISO if  ISO in 0x8827 & ISO in 0x0017 == 65535 */
         if (iso_speed == 65535)
@@ -297,18 +315,18 @@ int LibRaw::parse_tiff_ifd(int base)
         break;
       case 0x0005: /*   5, SensorLeftBorder */
         width = get2();
-        imgdata.sizes.raw_inset_crop.cleft = width;
+        imgdata.sizes.raw_inset_crops[0].cleft = width;
         break;
       case 0x0006: /*   6, SensorBottomBorder */
         height = get2();
-        imgdata.sizes.raw_inset_crop.cheight =
-            height - imgdata.sizes.raw_inset_crop.ctop;
+        imgdata.sizes.raw_inset_crops[0].cheight =
+            height - imgdata.sizes.raw_inset_crops[0].ctop;
         break;
       case 0x0007: /*   7, SensorRightBorder */
         i = get2();
         width += i;
-        imgdata.sizes.raw_inset_crop.cwidth =
-            i - imgdata.sizes.raw_inset_crop.cleft;
+        imgdata.sizes.raw_inset_crops[0].cwidth =
+            i - imgdata.sizes.raw_inset_crops[0].cleft;
         break;
       case 0x0009: /*   9, CFAPattern */
         if ((i = get2()))
@@ -418,7 +436,8 @@ int LibRaw::parse_tiff_ifd(int base)
       break;
     case 0x0102: /* 258, BitsPerSample */
     case 0xf003: /* 61443, Fuji RAF 0xf003 */
-      tiff_ifd[ifd].samples = len & 7;
+      if(!tiff_ifd[ifd].samples || tag != 0x0102) // ??? already set by tag 0x115
+        tiff_ifd[ifd].samples = len & 7;
       tiff_ifd[ifd].bps = getint(type);
       if (tiff_bps < (unsigned)tiff_ifd[ifd].bps)
         tiff_bps = tiff_ifd[ifd].bps;
@@ -984,18 +1003,37 @@ int LibRaw::parse_tiff_ifd(int base)
                 break;
               }
             }
-            int fj;
+            int fj; // 31? (fj<<1)-0x3c : 34? (fj<<1)-0x4e : undef
+            int is34 = 0;
+            if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3, GFX 100S
+                (imFuji.RAFDataVersion == 0x0261) || // X100V, GFX 50S II
+                (imFuji.RAFDataVersion == 0x0262) || // X-T4
+                (imFuji.RAFDataVersion == 0x0264) || // X-S10
+                (imFuji.RAFDataVersion == 0x0265) || // X-E4
+                !strcmp(model, "X-Pro3")     ||
+                !strcmp(model, "GFX 100S")   ||
+                !strcmp(model, "GFX100S")    ||
+                !strcmp(model, "GFX 50S II") ||
+                !strcmp(model, "GFX50S II")  ||
+                !strcmp(model, "X100V")      ||
+                !strcmp(model, "X-T4")       ||
+                !strcmp(model, "X-E4")       ||
+                !strcmp(model, "X-S10"))
+// is34 cameras have 34 CCT values instead of 31, manual still claims 2500 to 10000 K
+// aligned 3000 K to Incandescent, as it is usual w/ other Fujifilm cameras
+              is34 = 1;
+
             for (int fi = 0;
-                 fi < int(libraw_internal_data.unpacker_data.lenRAFData - 3); fi++)
-            { // looking for Tungsten WB
+                 fi < int(libraw_internal_data.unpacker_data.lenRAFData - 3); fi++) // looking for Tungsten WB
+            {
               if ((fwb[0] == rafdata[fi]) && (fwb[1] == rafdata[fi + 1]) &&
-                  (fwb[2] == rafdata[fi + 2]))
-              { // found Tungsten WB
+                  (fwb[2] == rafdata[fi + 2])) // found Tungsten WB
+              {
                 if (rafdata[fi - 15] !=
                     fwb[0]) // 15 is offset of Tungsten WB from the first
                             // preset, Fine Weather WB
                   continue;
-                for (int wb_ind = 0, ofst = fi - 15; wb_ind < Fuji_wb_list1.size();
+                for (int wb_ind = 0, ofst = fi - 15; wb_ind < (int)Fuji_wb_list1.size();
                      wb_ind++, ofst += 3)
                 {
                   icWBC[Fuji_wb_list1[wb_ind]][1] =
@@ -1004,10 +1042,7 @@ int LibRaw::parse_tiff_ifd(int base)
                   icWBC[Fuji_wb_list1[wb_ind]][2] = rafdata[ofst + 2];
                 }
 
-                if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3
-                    (imFuji.RAFDataVersion == 0x0261) || // X100V
-                    (imFuji.RAFDataVersion == 0x0262) || // X-T4
-                    (imFuji.RAFDataVersion == 0x0264))   // X-S10
+                if (is34)
                   fi += 24;
                 fi += 96;
                 for (fj = fi; fj < (fi + 15); fj += 3) // looking for the end of the WB table
@@ -1015,13 +1050,9 @@ int LibRaw::parse_tiff_ifd(int base)
                   if (rafdata[fj] != rafdata[fi])
                   {
                     fj -= 93;
-// X-Pro3 has 34 CCT values instead of 31, manual still clames 2500 to 10000 K
-// aligned 3000 K to Incandescent, as it is usual w/ other Fujifilm cameras
-                    if ((imFuji.RAFDataVersion == 0x0260) || // X-Pro3
-                        (imFuji.RAFDataVersion == 0x0261) || // X100V
-                        (imFuji.RAFDataVersion == 0x0262) || // X-T4
-                        (imFuji.RAFDataVersion == 0x0264))   // X-S10
+                    if (is34)
                       fj -= 9;
+// printf ("wb start in DNG: 0x%04x\n", fj*2-0x4e);
                     for (int iCCT = 0, ofst = fj; iCCT < 31;
                          iCCT++, ofst += 3)
                     {
@@ -1158,9 +1189,9 @@ int LibRaw::parse_tiff_ifd(int base)
         tiff_ifd[ifd].dng_levels.default_crop[1] = getreal(type);
         if (!strncasecmp(make, "SONY", 4))
         {
-          imgdata.sizes.raw_inset_crop.cleft =
+          imgdata.sizes.raw_inset_crops[0].cleft =
               tiff_ifd[ifd].dng_levels.default_crop[0];
-          imgdata.sizes.raw_inset_crop.ctop =
+          imgdata.sizes.raw_inset_crops[0].ctop =
               tiff_ifd[ifd].dng_levels.default_crop[1];
         }
       }
@@ -1174,27 +1205,47 @@ int LibRaw::parse_tiff_ifd(int base)
         tiff_ifd[ifd].dng_levels.default_crop[3] = getreal(type);
         if (!strncasecmp(make, "SONY", 4))
         {
-          imgdata.sizes.raw_inset_crop.cwidth =
+          imgdata.sizes.raw_inset_crops[0].cwidth =
               tiff_ifd[ifd].dng_levels.default_crop[2];
-          imgdata.sizes.raw_inset_crop.cheight =
+          imgdata.sizes.raw_inset_crops[0].cheight =
               tiff_ifd[ifd].dng_levels.default_crop[3];
         }
       }
       break;
 
+    case 0xc7b5: /* 51125 DefaultUserCrop */
+      if (len == 4)
+      {
+          int cnt = 0;
+          FORC4
+          {
+              float v = getreal(type);
+              if (v >= 0.f && v <= 1.f)
+              {
+                  tiff_ifd[ifd].dng_levels.user_crop[c] = v;
+                  cnt++;
+              }
+          }
+          if(cnt == 4 // valid values
+              && tiff_ifd[ifd].dng_levels.user_crop[0] < tiff_ifd[ifd].dng_levels.user_crop[2] // top < bottom
+              && tiff_ifd[ifd].dng_levels.user_crop[1] < tiff_ifd[ifd].dng_levels.user_crop[3] // left < right
+              )
+            tiff_ifd[ifd].dng_levels.parsedfields |= LIBRAW_DNGFM_USERCROP;
+      }
+      break;
     case 0x74c7:
       if ((len == 2) && !strncasecmp(make, "SONY", 4))
       {
-        imgdata.sizes.raw_inset_crop.cleft = get4();
-        imgdata.sizes.raw_inset_crop.ctop = get4();
+        imgdata.sizes.raw_inset_crops[0].cleft = get4();
+        imgdata.sizes.raw_inset_crops[0].ctop = get4();
       }
       break;
 
     case 0x74c8:
       if ((len == 2) && !strncasecmp(make, "SONY", 4))
       {
-        imgdata.sizes.raw_inset_crop.cwidth = get4();
-        imgdata.sizes.raw_inset_crop.cheight = get4();
+        imgdata.sizes.raw_inset_crops[0].cwidth = get4();
+        imgdata.sizes.raw_inset_crops[0].cheight = get4();
       }
       break;
 
@@ -1664,7 +1715,7 @@ void LibRaw::apply_tiff()
                 if (tiff_ifd[i].dng_levels.dng_whitelevel[0] > 0)
                 {
                     for(int c = 0,j=1; c < 16; c++, j<<=1)
-                        if (j > tiff_ifd[i].dng_levels.dng_whitelevel[0])
+                        if (j > (int)tiff_ifd[i].dng_levels.dng_whitelevel[0])
                         {
                             bps = c; break;
                         }
@@ -1873,7 +1924,10 @@ void LibRaw::apply_tiff()
     case 6:
     case 7:
     case 99:
-      load_raw = &LibRaw::lossless_jpeg_load_raw;
+      if (!dng_version && tiff_compress == 6 && !strcasecmp(make, "SONY"))
+        load_raw = &LibRaw::sony_ljpeg_load_raw;
+      else
+        load_raw = &LibRaw::lossless_jpeg_load_raw;
       break;
     case 262:
       load_raw = &LibRaw::kodak_262_load_raw;
@@ -2013,7 +2067,7 @@ void LibRaw::apply_tiff()
             unsigned(thumb_width * thumb_height / (SQR(thumb_misc) + 1)) &&
         tiff_ifd[i].comp != 34892)
     {
-        if (fsizecheck > 0ULL)
+        if (fsizecheck > 0LL)
         {
             bool ok = true;
             if (tiff_ifd[i].strip_byte_counts_count && tiff_ifd[i].strip_offsets_count)
diff --git a/src/tables/cameralist.cpp b/src/tables/cameralist.cpp
index 5de8a4bc..cc25b527 100644
--- a/src/tables/cameralist.cpp
+++ b/src/tables/cameralist.cpp
@@ -34,8 +34,9 @@ static const char *static_camera_list[] = {
 	"Apple iPhone 8",
 	"Apple iPhone 8 plus",
 	"Apple iPhone X",
-	"Apple iPhone 12 Max",
-	"Apple iPhone 12 Max Pro",
+	"Apple iPhone 12 Pro",
+	"Apple iPhone 12 Pro Max",
+	"Apple iPhone 13 Pro",
 	"Apple QuickTake 100",
 	"Apple QuickTake 150",
 	"Apple QuickTake 200",
@@ -213,6 +214,7 @@ static const char *static_camera_list[] = {
 	"Canon EOS M6 Mark II",
 	"Canon EOS M10",
 	"Canon EOS M50 / Kiss M",
+	"Canon EOS M50 Mark II",
 	"Canon EOS M100",
 	"Canon EOS M200",
 	"Canon EOS-1D C",
@@ -288,6 +290,7 @@ static const char *static_camera_list[] = {
 	"DJI 4384x3288",
 	"DJI Mavic Air",
 	"DJI Mavic Air2",
+	"DJI Mavic Air 2S",
 	"DJI Mavic Mini2",
 	"DJI Osmo Action",
 	"DJI Pocket",
@@ -332,8 +335,10 @@ static const char *static_camera_list[] = {
 	"FujiFilm HS30EXR / HS33EXR / HS35EXR",
 	"FujiFilm HS50EXR",
 	"FujiFilm GFX 50S",
+	"FujiFilm GFX 50S II",
 	"FujiFilm GFX 50R",
 	"FujiFilm GFX 100",
+	"FujiFilm GFX 100S",
 	"FujiFilm X-Pro1",
 	"FujiFilm X-Pro2",
 	"FujiFilm X-Pro3",
@@ -360,6 +365,7 @@ static const char *static_camera_list[] = {
 	"FujiFilm X-E2",
 	"FujiFilm X-E2S",
 	"FujiFilm X-E3",
+	"FujiFilm X-E4",
 	"FujiFilm X-M1",
 	"FujiFilm XF1",
 	"FujiFilm XF10",
@@ -369,7 +375,7 @@ static const char *static_camera_list[] = {
 	"FujiFilm X-T1 Graphite Silver",
 	"FujiFilm X-T2",
 	"FujiFilm X-T3",
-	"FujiFilm X-T4 (uncompressed and lossless compressed only)",
+	"FujiFilm X-T4",
 	"FujiFilm X-T10",
 	"FujiFilm X-T20",
 	"FujiFilm X-T30",
@@ -392,6 +398,8 @@ static const char *static_camera_list[] = {
 	"GoPro HERO6",
 	"GoPro HERO7",
 	"GoPro HERO8",
+	"GoPro HERO9",
+	"GoPro HERO10",
 #endif
 	"Hasselblad H2D-22",
 	"Hasselblad H2D-39",
@@ -441,6 +449,7 @@ static const char *static_camera_list[] = {
 	"Huawei P10+ (VKY-L09)",
 	"Huawei P10 Lite (WAS-LX1A)",
 	"Huawei P20 (EML-L09)",
+	"Huawei P20 Lite (ANE-LX1)",
 	"Huawei P20 Pro (CLT-L29/L09)",
 	"Huawei P30 Pro (VOG-L29)",
 	"Huawei Honor6a",
@@ -463,6 +472,7 @@ static const char *static_camera_list[] = {
 	"ISG 2020x1520",
 	"Ikonoskop A-Cam dII Panchromatic",
 	"Ikonoskop A-Cam dII",
+	"Kandao QooCam 8K",
 	"Kinefinity KineMINI",
 	"Kinefinity KineRAW Mini",
 	"Kinefinity KineRAW S35",
@@ -694,6 +704,7 @@ static const char *static_camera_list[] = {
 	"Nikon Z 7",
 	"Nikon Z 7 II",
 	"Nikon Z 50",
+	"Nikon Z fc",
 	"Nikon 1 AW1",
 	"Nikon 1 J1",
 	"Nikon 1 J2",
@@ -779,6 +790,7 @@ static const char *static_camera_list[] = {
 	"Olympus E-P2",
 	"Olympus E-P3",
 	"Olympus E-P5",
+	"Olympus E-P7",
 	"Olympus E-PL1",
 	"Olympus E-PL1s",
 	"Olympus E-PL2",
@@ -877,6 +889,7 @@ static const char *static_camera_list[] = {
 	"Panasonic AG-GH4",
 	"Panasonic DC-GH5",
 	"Panasonic DC-GH5S",
+	"Panasonic DC-GH5 Mark II",
 	"Panasonic DMC-GM1",
 	"Panasonic DMC-GM1s",
 	"Panasonic DMC-GM5",
@@ -931,7 +944,8 @@ static const char *static_camera_list[] = {
 	"Pentax K-1",
 	"Pentax K-1 Mark II",
 	"Pentax K-3",
-	"Pentax K-3 II",
+	"Pentax K-3 Mark II",
+	"Pentax K-3 Mark III",
 	"Pentax K-30",
 	"Pentax K-5",
 	"Pentax K-5 II",
@@ -992,10 +1006,14 @@ static const char *static_camera_list[] = {
 #endif
 	"RaspberryPi Camera",
 	"RaspberryPi Camera V2",
+#ifdef USE_6BY9RPI
+	"RaspberryPi HQ Camera",
+#endif
 	"Ricoh GR",
 	"Realme 3 Pro",
 	"Ricoh GR II",
 	"Ricoh GR III",
+	"Ricoh GR IIIx",
 	"Ricoh GR Digital",
 	"Ricoh GR Digital II",
 	"Ricoh GR Digital III",
@@ -1105,6 +1123,7 @@ static const char *static_camera_list[] = {
 	"SMaL Ultra-Pocket 3",
 	"SMaL Ultra-Pocket 4",
 	"SMaL Ultra-Pocket 5",
+	"Sony ILCE-1 (A1)",
 	"Sony ILCE-7 (A7)",
 	"Sony ILCE-7M2 (A7 II)",
 	"Sony ILCE-7M3 (A7 III)",
@@ -1112,7 +1131,9 @@ static const char *static_camera_list[] = {
 	"Sony ILCE-7R (A7R",
 	"Sony ILCE-7RM2 (A7R II)",
 	"Sony ILCE-7RM3 (A7R III)",
+	"Sony ILCE-7RM3A (A7R IIIA)",
 	"Sony ILCE-7RM4 (A7R IV)",
+	"Sony ILCE-7RM4A (A7R IVA)",
 	"Sony ILCE-7S (A7S)",
 	"Sony ILCE-7SM2 (A7S II)",
 	"Sony ILCE-7SM3 (A7S III)",
@@ -1202,7 +1223,9 @@ static const char *static_camera_list[] = {
 	"Sony IMX219-mipi 8mp",
 	"Sony Xperia 5 II (XQ-AS52)",
 	"Sony Xperia L",
+	"Sony Xperia 1 III",
 	"Sony ZV-1 (DCZV1/B)",
+	"Sony ZV-E10",
 	"STV680 VGA",
 	"PtGrey GRAS-50S5C",
 	"JaiPulnix BB-500CL",
@@ -1217,8 +1240,10 @@ static const char *static_camera_list[] = {
 	"Xiaomi MI 8",
 	"Xiaomi MI 9 Lite",
 	"Xiaomi MI MAX",
+	"Xiaomi POCO M3",
 	"Xiaomi RedMi Note3 Pro",
 	"Xiaomi RedMi Note7",
+	"Xiaomi RedMi Note 8T",
 	"Xiaomi FIMI X8SE",
 	"Xiaoyi YIAC3 (YI 4k)",
 	"Zeiss ZX1",
diff --git a/src/tables/colordata.cpp b/src/tables/colordata.cpp
index e2bf971f..7e7f5e10 100644
--- a/src/tables/colordata.cpp
+++ b/src/tables/colordata.cpp
@@ -44,6 +44,14 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
 	{ LIBRAW_CAMERAMAKER_Broadcom, "Pi", 16, 0x3ff,
 	  { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */
 
+#ifdef USE_6BY9RPI // this code normalizes model to LIBRAW_CAMERAMAKER_RaspberryPi
+    { LIBRAW_CAMERAMAKER_RaspberryPi, "RP_imx477", 0, 0, // Do not set black, it is set at parser to 256 or 64
+      { 5603, -1351, -600, -2872, 11180, 2132, 600, 453, 5821 } }, /* PyDNG */
+    { LIBRAW_CAMERAMAKER_RaspberryPi, "RP_imx", 66, 0x3ff,
+      { 5302,1083,-728,-5320,14112,1699,-863,2371,5136 } }, /* LibRaw */
+    { LIBRAW_CAMERAMAKER_RaspberryPi, "ov5647", 16, 0x3ff,
+      { 12782,-4059,-379,-478,9066,1413,1340,1513,5176 } }, /* DJC */
+#endif
     { LIBRAW_CAMERAMAKER_Canon, "EOS D30", 0, 0,
       { 9900,-2771,-1324,-7072,14229,3140,-2790,3344,8861 } },
     { LIBRAW_CAMERAMAKER_Canon, "EOS D60", 0, 0xfa0,
@@ -381,9 +389,9 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
     { LIBRAW_CAMERAMAKER_Fujifilm, "F900EXR", 0, 0,
       { 12085,-4727,-953,-3257,11489,2002,-511,2046,4592 } },
 
-    { LIBRAW_CAMERAMAKER_Fujifilm, "GFX 100", 0, 0,
+    { LIBRAW_CAMERAMAKER_Fujifilm, "GFX 100", 0, 0, // same CMs: "GFX 100", "GFX 100S"/"GFX100S", "GFX 100 IR"
       { 16212,-8423,-1583,-4336,12583,1937,-195,726,6199 } },
-    { LIBRAW_CAMERAMAKER_Fujifilm, "GFX 50", 0, 0, // same CMs: "GFX 50S", "GFX 50R"
+    { LIBRAW_CAMERAMAKER_Fujifilm, "GFX 50", 0, 0,  // same CMs: "GFX 50S", "GFX 50R", "GFX 50S II"
       { 11756,-4754,-874,-3056,11045,2305,-381,1457,6006 } },
 
     { LIBRAW_CAMERAMAKER_Fujifilm, "HS10", 0, 0xf68,
@@ -492,6 +500,8 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
       { 8458,-2451,-855,-4597,12447,2407,-1475,2482,6526 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-E3", 0, 0,
       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
+    { LIBRAW_CAMERAMAKER_Fujifilm, "X-E4", 0, 0,
+      { 13426, -6334, -1177, -4244, 12136, 2371, -580, 1303, 5980 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-H1", 0, 0,
       { 11434,-4948,-1210,-3746,12042,1903,-666,1479,5235 } },
     { LIBRAW_CAMERAMAKER_Fujifilm, "X-M1", 0, 0,
@@ -533,14 +543,14 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
     { LIBRAW_CAMERAMAKER_Hasselblad, "16-Uncoated-FFF", 0, 0,
       {  8068, -2959,  -108, -5788, 13608,  2389, -1002,  2237,  8162}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "16-Uncoated", 0, 0,
-      { 8519,-3260,-280,-5081,13459,1738,-1449,2960,7809 } },
+      {  8519, -3260,  -280, -5081, 13459,  1738, -1449,  2960,  7809}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "22-Uncoated-3FR", 0, 0,
       {  8523, -3257,  -280, -5078, 13458,  1743, -1449,  2961,  7809}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "22-Uncoated-FFF", 0, 0,
       {  8068, -2959,  -108, -5788, 13608,  2389, -1002,  2237,  8162}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "22-Uncoated", 0, 0,
-      { 8519,-3260,-280,-5081,13459,1738,-1449,2960,7809 } },
+      {  8519, -3260,  -280, -5081, 13459,  1738, -1449,  2960,  7809}},
 
     {LIBRAW_CAMERAMAKER_Hasselblad, "31-Uncoated-FFF", 0, 0,
       {  5155, -1201,   200, -5841, 13197,  2950, -1101,  2317,  6988}},
@@ -559,7 +569,7 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
     { LIBRAW_CAMERAMAKER_Hasselblad, "39-Coated-FFF", 0, 0,
       {  5323, -1233,   399, -4926, 12362,  2894,  -856,  2471,  5961}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "39-Coated", 0, 0,
-      { 3857,452,-46,-6008,14477,1596,-2627,4481,5718 } },
+      {  3857,   452,   -46, -6008, 14477,  1596, -2627,  4481,  5718}},
 
     {LIBRAW_CAMERAMAKER_Hasselblad, "40-Coated5-3FR", 0, 0,
       {  7014, -2067,  -540, -4821, 13016,  1980, -1663,  3089,  6940}},
@@ -573,7 +583,7 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
     { LIBRAW_CAMERAMAKER_Hasselblad, "40-Coated-FFF", 0, 0,
       {  6041, -1375,  -174, -5439, 10000,  3007,  -930,  2145,  6923}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "40-Coated", 0, 0,
-	    { 6159,-1402,-177,-5439,12762,3007,-955,2200,7104 } },
+	    {  6159, -1402,  -177, -5439, 12762,  3007,  -955,  2200,  7104}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-Coated5-3FR", 0, 0,
       {  5707,  -693,  -382, -4285, 12669,  1773, -1615,  3519,  5410}},
@@ -587,7 +597,7 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-Coated-FFF", 0, 0,
       {  5280,  -614,    39, -4950, 12426,  2843,  -939,  2434,  5968}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-Coated", 0, 0,
-	    { 5656,-659,-346,-3923,12306,1791,-1602,3509,5442 } },
+	    {  5656,  -659,  -346, -3923, 12306, 1791,  -1602,  3509,  5442}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "50-15-Coated5-II-3FR", 0, 0,
       { 10887, -6152,  1034, -3564, 12412,  4224,    63,   626, 10123}},
@@ -602,7 +612,7 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
     { LIBRAW_CAMERAMAKER_Hasselblad, "60-Coated-3FR", 0, 0,
       {  9296,   336, -1088, -6442, 14323,  2289, -1433,  2942,  5756}},
     { LIBRAW_CAMERAMAKER_Hasselblad, "60-Coated", 0, 0,
-	    { 9662,-684,-279,-4903,12293,2950,-344,1669,6024 } },
+	    {  9662,  -684,  -279, -4903, 12293,  2950,  -344,  1669,  6024}},
 
     { LIBRAW_CAMERAMAKER_Hasselblad, "100-17-Coated5", 0, 0,
       {  5110, -1357,  -308, -5573, 12835,  3077, -1279,  2025,  7010}},
@@ -977,13 +987,15 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
       { 8598,-2848,-857,-5618,13606,2195,-1002,1773,7137 } },
 
     { LIBRAW_CAMERAMAKER_Nikon, "Z 50", 0, 0,
-       { 11640,-4829,-1079,-5107,13006,2325,-972,1711,7380 } },
+      { 11640,-4829,-1079,-5107,13006,2325,-972,1711,7380 } },
     { LIBRAW_CAMERAMAKER_Nikon, "Z 5", 0, 0,
       { 8695,-2558,-648,-5015,12711,2575,-1279,2215,7514 } },
     { LIBRAW_CAMERAMAKER_Nikon, "Z 6", 0, 0,
       { 9943,-3269,-839,-5323,13269,2259,-1198,2083,7557 } },  // 'Z 6'(v.2), 'Z 6_2'
     { LIBRAW_CAMERAMAKER_Nikon, "Z 7", 0, 0,
       { 13705,-6004,-1400,-5464,13568,2062,-940,1706,7618 } }, // 'Z 7'(v.2), 'Z 7_2'
+    { LIBRAW_CAMERAMAKER_Nikon, "Z fc", 0, 0,
+      { 11640,-4829,-1079,-5107,13006,2325,-972,1711,7380 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "AIR A01", 0, 0xfe1,
       { 8992,-3093,-639,-2563,10721,2122,-437,1270,5473 } },
@@ -1044,6 +1056,8 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
       { 7575,-2159,-571,-3722,11341,2725,-1434,2819,6271 } },
     { LIBRAW_CAMERAMAKER_Olympus, "E-P5", 0, 0,
       { 8380,-2630,-639,-2887,10725,2496,-627,1427,5438 } },
+    { LIBRAW_CAMERAMAKER_Olympus, "E-P7", 0, 0,
+      { 9476,-3182,-765,-2613,10958,1893,-449,1315,5268 } },
 
     { LIBRAW_CAMERAMAKER_Olympus, "E-PL10", 0, 0,
       { 9197,-3190,-659,-2606,10830,2039,-458,1250,5458 } },
@@ -1166,6 +1180,8 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
       { 8596,-2981,-639,-4202,12046,2431,-685,1424,6122 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-30", 0, 0,
       { 8134,-2728,-645,-4365,11987,2694,-838,1509,6498 } },
+    { LIBRAW_CAMERAMAKER_Pentax, "K-3 Mark III", 0, 0,
+      {  9251, -3817, -1069, -4627, 12667,  2175,  -798,  1660,  5633 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-3", 0, 0, // same CMs: K-3, "K-3 II"
       { 7415,-2052,-721,-5186,12788,2682,-1446,2157,6773 } },
     { LIBRAW_CAMERAMAKER_Pentax, "K-500", 0, 0,
@@ -1319,6 +1335,8 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
       { 7122,-2108,-512,-3155,11201,2231,-541,1423,5045 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-GH5s", -15, 0,
       { 6929,-2355,-708,-4192,12534,1828,-1097,1989,5195 } },
+    { LIBRAW_CAMERAMAKER_Panasonic, "DC-GH5M2", 0, 0,
+      {  9300, -3659,  -755, -2981, 10988,  2287,  -190,  1077,  5016 } },
     { LIBRAW_CAMERAMAKER_Panasonic, "DC-GH5", -15, 0,
       { 7641,-2336,-605,-3218,11299,2187,-485,1338,5121 } },
 
@@ -1584,6 +1602,9 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
     { LIBRAW_CAMERAMAKER_Sony, "ZV-1", -800, 0,
       {8280,-2987,-703,-3531,11645,2133,-550,1542,5312 } },
 
+    { LIBRAW_CAMERAMAKER_Sony, "ZV-E10", 0, 0,
+      { 7657,-2847,-607,-4083,11966,2389,-684,1418,5844 } }, // a la ILCE-6100
+
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX100M7", -800, 0,
       {10315, -4390, -937, -4859, 12734, 2365, -734, 1537, 5997 } },
     { LIBRAW_CAMERAMAKER_Sony, "DSC-RX100M6", -800, 0,
@@ -1641,28 +1662,34 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
       { 5991,-1732,-443,-4100,11989,2381,-704,1467,5992 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCA-99M2", 0, 0,
       { 6660,-1918,-471,-4613,12398,2485,-649,1433,6447 } },
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-9", 0, 0, // same CMs: ILCE-9, ILCE-9M2
-      { 6389,-1703,-378,-4562,12265,2587,-670,1489,6550 } },
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7SM3", 0, 0,
-      { 6912,-2127,-469,-4470,12175,2587,-398,1478,6492 } }, // preliminary
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7S", 0, 0, // same CMs: ILCE-7S, ILCE-7SM2
-      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },
 
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM4", 0, 0,
-      { 7662, -2686,-660,-5240, 12965,2530, -796, 1508, 6167 }},
-    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM3", 0, 0,
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-1", 0, 0,
+      { 8161, -2947, -739, -4811, 12668, 2389, -437, 1229, 6524}},
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM4", 0, 0, // same CMs: ILCE-7RM4, ILCE-7RM4A
+      { 7662, -2686,-660,-5240, 12965,2530, -796, 1508, 6167 } },
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM3", 0, 0, // same CMs: ILCE-7RM3, ILCE-7RM3A
       { 6640,-1847,-503,-5238,13010,2474,-993,1673,6527 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7RM2", 0, 0,
       { 6629,-1900,-483,-4618,12349,2550,-622,1381,6514 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7R", 0, 0,
       { 4913,-541,-202,-6130,13513,2906,-1564,2151,7183 } },
+
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7SM3", 0, 0,
+      { 6912,-2127,-469,-4470,12175,2587,-398,1478,6492 } },
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-7S", 0, 0, // same CMs: ILCE-7S, ILCE-7SM2
+      { 5838,-1430,-246,-3497,11477,2297,-748,1885,5778 } },
+
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7C", 0, 0,
       { 7374,-2389,-551,-5435,13162,2519,-1006,1795,6552 } },
+
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7M3", 0, 0,
       { 7374,-2389,-551,-5435,13162,2519,-1006,1795,6552 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-7", 0, 0, // same CMs: ILCE-7, ILCE-7M2
       { 5271,-712,-347,-6153,13653,2763,-1601,2366,7242 } },
 
+    { LIBRAW_CAMERAMAKER_Sony, "ILCE-9", 0, 0, // same CMs: ILCE-9, ILCE-9M2
+      { 6389,-1703,-378,-4562,12265,2587,-670,1489,6550 } },
+
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-6100", 0, 0,
       { 7657,-2847,-607,-4083,11966,2389,-684,1418,5844 } },
     { LIBRAW_CAMERAMAKER_Sony, "ILCE-6300", 0, 0,
@@ -1676,6 +1703,9 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
     { LIBRAW_CAMERAMAKER_Sony, "ILCE", 0, 0, // same CMs: ILCE-3000, ILCE-5000, ILCE-5100, ILCE-6000, ILCE-QX1
       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
 
+    { LIBRAW_CAMERAMAKER_Sony, "ILME-FX3", 0, 0,
+      { 6912, -2127, -469, -4470, 12175, 2587, -398, 1478, 6492 } },
+
     { LIBRAW_CAMERAMAKER_Sony, "NEX-5N", 0, 0,
       { 5991,-1456,-455,-4764,12135,2980,-707,1425,6701 } },
     { LIBRAW_CAMERAMAKER_Sony, "NEX-5R", 0, 0,
@@ -1742,7 +1772,7 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
   {
 	  if (table[i].m_idx == make_idx)
 	  {
-		  unsigned l = strlen(table[i].prefix);
+		  size_t l = strlen(table[i].prefix);
 		  if (!l ||  !strncasecmp(t_model, table[i].prefix, l))
 		  {
 			  if (!dng_version)
@@ -1764,10 +1794,9 @@ int LibRaw::adobe_coeff(unsigned make_idx, const char *t_model,
 			  {
 				  for (raw_color = j = 0; j < 12; j++)
 					  if (internal_only)
-						  imgdata.color.cam_xyz[j / 3][j % 3] = table[i].trans[j] / 10000.0;
+						  imgdata.color.cam_xyz[j / 3][j % 3] = table[i].trans[j] / 10000.f;
 					  else
-						  imgdata.color.cam_xyz[j / 3][j % 3] = ((double *)cam_xyz)[j] =
-						  table[i].trans[j] / 10000.0;
+                          ((double *)cam_xyz)[j] = imgdata.color.cam_xyz[j / 3][j % 3] = table[i].trans[j] / 10000.f;
 				  if (!internal_only)
 					  cam_xyz_coeff(rgb_cam, cam_xyz);
 			  }
diff --git a/src/tables/wblists.cpp b/src/tables/wblists.cpp
index c565aef6..f377cd3e 100644
--- a/src/tables/wblists.cpp
+++ b/src/tables/wblists.cpp
@@ -25,7 +25,7 @@ libraw_static_table_t LibRaw::tagtype_dataunit_bytes(_tagtype_dataunit_bytes, _A
 
 int libraw_tagtype_dataunit_bytes(int tagtype)
 {
-    return _tagtype_dataunit_bytes[(tagtype <= _ARR_SZ(_tagtype_dataunit_bytes)) ? tagtype : 0];
+    return _tagtype_dataunit_bytes[((unsigned)tagtype <= _ARR_SZ(_tagtype_dataunit_bytes)) ? tagtype : 0];
 }
 
 
diff --git a/src/utils/decoder_info.cpp b/src/utils/decoder_info.cpp
index c6c43bc2..01ba2141 100644
--- a/src/utils/decoder_info.cpp
+++ b/src/utils/decoder_info.cpp
@@ -276,6 +276,10 @@ int LibRaw::get_decoder_info(libraw_decoder_info_t *d_info)
   {
     d_info->decoder_name = "sony_load_raw()";
   }
+  else if (load_raw == &LibRaw::sony_ljpeg_load_raw)
+  {
+    d_info->decoder_name = "sony_ljpeg_load_raw()";
+  }
   else if (load_raw == &LibRaw::sony_arw_load_raw)
   {
     d_info->decoder_name = "sony_arw_load_raw()";
diff --git a/src/utils/init_close_utils.cpp b/src/utils/init_close_utils.cpp
index 19090c91..ce420853 100644
--- a/src/utils/init_close_utils.cpp
+++ b/src/utils/init_close_utils.cpp
@@ -153,8 +153,8 @@ void LibRaw::recycle()
 #undef FREE
 
   ZERO(imgdata.sizes);
-  imgdata.sizes.raw_inset_crop.cleft = 0xffff;
-  imgdata.sizes.raw_inset_crop.ctop  = 0xffff;
+  imgdata.sizes.raw_inset_crops[0].cleft = imgdata.sizes.raw_inset_crops[1].cleft = 0xffff;
+  imgdata.sizes.raw_inset_crops[0].ctop  = imgdata.sizes.raw_inset_crops[1].ctop = 0xffff;
 
   ZERO(imgdata.idata);
   ZERO(imgdata.color);
@@ -183,9 +183,9 @@ void LibRaw::recycle()
       imgdata.color.dng_color[1].illuminant = LIBRAW_WBI_None;
   for (int i = 0; i < 4; i++) imgdata.color.dng_levels.analogbalance[i] = 1.0f;
 
-  MN.canon.SensorLeftBorder = -1;
-  MN.canon.SensorTopBorder = -1;
-  MN.canon.AutoLightingOptimizer = 3; // 'off' value
+  MN.canon.DefaultCropAbsolute.l = -1;
+  MN.canon.DefaultCropAbsolute.t = -1;
+  MN.canon.AutoLightingOptimizer =  3; // 'off' value
 
   MN.fuji.WB_Preset = 0xffff;
   MN.fuji.ExpoMidPointShift = -999.f;
@@ -203,6 +203,11 @@ void LibRaw::recycle()
   MN.fuji.FocusWarning = 0xffff;
   for (int i = 0; i < 3; i++) MN.fuji.ImageStabilization[i] = 0xffff;
   MN.fuji.DriveMode = -1;
+  MN.fuji.ImageCount = -1;
+  MN.fuji.AutoBracketing = -1;
+  MN.fuji.SequenceNumber = -1;
+  MN.fuji.SeriesLength = -1;
+  MN.fuji.PixelShiftOffset[0] = MN.fuji.PixelShiftOffset[1] = -999.f;
 
   MN.hasselblad.nIFD_CM[0] = MN.hasselblad.nIFD_CM[1] = -1;
 
@@ -228,6 +233,7 @@ void LibRaw::recycle()
   MN.olympus.FocusStepNear = 0xffff;
   MN.olympus.FocusDistance = -999.0;
   for (int i = 0; i < 4; i++) MN.olympus.AspectFrame[i] = 0xffff;
+  MN.olympus.StackedImage[0] = 0xffffffff;
 
   MN.panasonic.LensManufacturer = 0xffffffff;
 
diff --git a/src/utils/open.cpp b/src/utils/open.cpp
index 98b6887a..655dfae6 100644
--- a/src/utils/open.cpp
+++ b/src/utils/open.cpp
@@ -163,12 +163,16 @@ int LibRaw::open_file(const char *fname)
         stream = new LibRaw_bigfile_datastream(fname);
 #endif
     }
-
     catch (const std::bad_alloc&)
     {
         recycle();
         return LIBRAW_UNSUFFICIENT_MEMORY;
     }
+    if ((stream->size() > (INT64)LIBRAW_MAX_NONDNG_RAW_FILE_SIZE) && (stream->size() > (INT64)LIBRAW_MAX_DNG_RAW_FILE_SIZE))
+    {
+      delete stream;
+      return LIBRAW_TOO_BIG;
+    }
     return libraw_openfile_tail(stream);
 }
 
@@ -195,6 +199,12 @@ int LibRaw::open_file(const wchar_t *fname)
         recycle();
         return LIBRAW_UNSUFFICIENT_MEMORY;
     }
+    if ((stream->size() > (INT64)LIBRAW_MAX_DNG_RAW_FILE_SIZE) && (stream->size() > (INT64)LIBRAW_MAX_NONDNG_RAW_FILE_SIZE))
+    {
+      delete stream;
+      return LIBRAW_TOO_BIG;
+    }
+
     return libraw_openfile_tail(stream);
 }
 #endif
@@ -208,6 +218,9 @@ int LibRaw::open_buffer(const void *buffer, size_t size)
   if (!buffer || buffer == (const void *)-1)
     return LIBRAW_IO_ERROR;
 
+  if ((size > (INT64)LIBRAW_MAX_DNG_RAW_FILE_SIZE) && (size > (INT64)LIBRAW_MAX_NONDNG_RAW_FILE_SIZE))   
+      return LIBRAW_TOO_BIG;
+
   LibRaw_buffer_datastream *stream;
   try
   {
@@ -448,6 +461,9 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
     return ENOENT;
   if (!stream->valid())
     return LIBRAW_IO_ERROR;
+  if ((stream->size() > (INT64)LIBRAW_MAX_DNG_RAW_FILE_SIZE) && (stream->size() > (INT64)LIBRAW_MAX_NONDNG_RAW_FILE_SIZE))
+      return LIBRAW_TOO_BIG;
+
   recycle();
   if (callbacks.pre_identify_cb)
   {
@@ -468,7 +484,7 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
 	  if (callbacks.post_identify_cb)
 		  (callbacks.post_identify_cb)(this);
 
-#define isRIC imgdata.sizes.raw_inset_crop
+#define isRIC imgdata.sizes.raw_inset_crops[0]
 
 	  if (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Fujifilm)
 		  && (!strcmp(imgdata.idata.normalized_model, "S3Pro")
@@ -478,6 +494,14 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
 		  isRIC.cleft = isRIC.ctop = 0xffff;
 		  isRIC.cwidth = isRIC.cheight = 0;
 	  }
+      // Wipe out canon  incorrect in-camera crop
+      if (!imgdata.idata.dng_version && makeIs(LIBRAW_CAMERAMAKER_Canon)
+          && isRIC.cleft == 0 && isRIC.ctop == 0 // non symmetric!
+          && isRIC.cwidth < (imgdata.sizes.raw_width * 4 / 5))  // less than 80% of sensor width
+      {
+        isRIC.cleft = isRIC.ctop = 0xffff;
+        isRIC.cwidth = isRIC.cheight = 0;
+      }
 
       // Wipe out non-standard WB
       if (!imgdata.idata.dng_version &&
@@ -524,12 +548,18 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
 
 		  if (libraw_internal_data.unpacker_data.pana_encoding == 6)
 		  {
-			  int rowbytes = imgdata.sizes.raw_width / 11 * 16;
-			  if ((imgdata.sizes.raw_width % 11) == 0 &&
-				  (INT64(imgdata.sizes.raw_height) * rowbytes ==
-					  INT64(libraw_internal_data.unpacker_data.data_size)))
+			  int rowbytes11 = imgdata.sizes.raw_width / 11 * 16;
+              int rowbytes14 = imgdata.sizes.raw_width / 14 * 16;
+              INT64 ds = INT64(libraw_internal_data.unpacker_data.data_size);
+              if (!ds)
+                  ds = libraw_internal_data.internal_data.input->size() - libraw_internal_data.unpacker_data.data_offset;
+              if ((imgdata.sizes.raw_width % 11) == 0 &&
+				  (INT64(imgdata.sizes.raw_height) * rowbytes11 == ds))
 				  load_raw = &LibRaw::panasonicC6_load_raw;
-			  else
+              else if ((imgdata.sizes.raw_width % 14) == 0 &&
+                (INT64(imgdata.sizes.raw_height) * rowbytes14 == ds))
+                  load_raw = &LibRaw::panasonicC6_load_raw;
+              else
 				  imgdata.idata.raw_count = 0; // incorrect size
 		  }
 		  else if (libraw_internal_data.unpacker_data.pana_encoding == 7)
@@ -570,24 +600,24 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
 
 	  if (makeIs(LIBRAW_CAMERAMAKER_Canon))
 	  {
-		  if (MN.canon.SensorLeftBorder != -1)
-		  { // tag 0x00e0 SensorInfo was parsed
-			  if (isRIC.aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)
+		  if (MN.canon.DefaultCropAbsolute.l != -1)  // tag 0x00e0 SensorInfo was parsed
+		  {
+			  if (imgdata.sizes.raw_aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)
 			  { // tag 0x009a AspectInfo was parsed
-				  isRIC.cleft += MN.canon.SensorLeftBorder;
-				  isRIC.ctop += MN.canon.SensorTopBorder;
+				  isRIC.cleft += MN.canon.DefaultCropAbsolute.l;
+				  isRIC.ctop  += MN.canon.DefaultCropAbsolute.t;
 			  }
 			  else
 			  {
-				  isRIC.cleft = MN.canon.SensorLeftBorder;
-				  isRIC.ctop = MN.canon.SensorTopBorder;
-				  isRIC.cwidth = MN.canon.SensorRightBorder - MN.canon.SensorLeftBorder + 1;
-				  isRIC.cheight = MN.canon.SensorBottomBorder - MN.canon.SensorTopBorder + 1;
+				  isRIC.cleft   = MN.canon.DefaultCropAbsolute.l;
+				  isRIC.ctop    = MN.canon.DefaultCropAbsolute.t;
+				  isRIC.cwidth  = MN.canon.DefaultCropAbsolute.r - MN.canon.DefaultCropAbsolute.l + 1;
+				  isRIC.cheight = MN.canon.DefaultCropAbsolute.b - MN.canon.DefaultCropAbsolute.t + 1;
 			  }
 		  }
 		  else
 		  {
-			  if (isRIC.aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)
+			  if (imgdata.sizes.raw_aspect != LIBRAW_IMAGE_ASPECT_UNKNOWN)
 			  {
 			  }
 			  else
@@ -595,6 +625,19 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
 			  }
 		  }
 #undef isRIC
+          if (imgdata.color.raw_bps < 14 && !imgdata.idata.dng_version && load_raw != &LibRaw::canon_sraw_load_raw)
+          {
+              unsigned xmax = (1 << imgdata.color.raw_bps) - 1;
+              if (MN.canon.SpecularWhiteLevel > xmax) // Adjust 14-bit metadata to real bps
+              {
+                int div = 1 << (14 - imgdata.color.raw_bps);
+                for (int c = 0; c < 4; c++) imgdata.color.linear_max[c] /= div;
+                for (int c = 0; c < 4; c++)  MN.canon.ChannelBlackLevel[c] /= div;
+                MN.canon.AverageBlackLevel /= div;
+                MN.canon.SpecularWhiteLevel /= div;
+                MN.canon.NormalWhiteLevel /= div;
+              }
+          }
 	  }
 
 	  if (makeIs(LIBRAW_CAMERAMAKER_Canon) &&
@@ -608,13 +651,13 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
 			  MN.canon.SensorWidth > 1)
 		  {
 			  imgdata.sizes.raw_width = MN.canon.SensorWidth;
-			  imgdata.sizes.left_margin = MN.canon.SensorLeftBorder;
+			  imgdata.sizes.left_margin = MN.canon.DefaultCropAbsolute.l;
 			  imgdata.sizes.iwidth = imgdata.sizes.width =
-				  MN.canon.SensorRightBorder - MN.canon.SensorLeftBorder + 1;
+				  MN.canon.DefaultCropAbsolute.r - MN.canon.DefaultCropAbsolute.l + 1;
 			  imgdata.sizes.raw_height = MN.canon.SensorHeight;
-			  imgdata.sizes.top_margin = MN.canon.SensorTopBorder;
+			  imgdata.sizes.top_margin = MN.canon.DefaultCropAbsolute.t;
 			  imgdata.sizes.iheight = imgdata.sizes.height =
-				  MN.canon.SensorBottomBorder - MN.canon.SensorTopBorder + 1;
+				  MN.canon.DefaultCropAbsolute.b - MN.canon.DefaultCropAbsolute.t + 1;
 			  libraw_internal_data.unpacker_data.load_flags |=
 				  256; // reset width/height in canon_sraw_load_raw()
 			  imgdata.sizes.raw_pitch = 8 * imgdata.sizes.raw_width;
@@ -663,52 +706,128 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
 			  else
 				  parse_fuji_compressed_header();
 		  }
-		  if (imgdata.idata.filters == 9)
-		  {
-			  // Adjust top/left margins for X-Trans
-			  int newtm = imgdata.sizes.top_margin % 6
-				  ? (imgdata.sizes.top_margin / 6 + 1) * 6
-				  : imgdata.sizes.top_margin;
-			  int newlm = imgdata.sizes.left_margin % 6
-				  ? (imgdata.sizes.left_margin / 6 + 1) * 6
-				  : imgdata.sizes.left_margin;
-			  if (newtm != imgdata.sizes.top_margin ||
-				  newlm != imgdata.sizes.left_margin)
-			  {
-				  imgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);
-				  imgdata.sizes.top_margin = newtm;
-				  imgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);
-				  imgdata.sizes.left_margin = newlm;
-				  for (int c1 = 0; c1 < 6; c1++)
-					  for (int c2 = 0; c2 < 6; c2++)
-						  imgdata.idata.xtrans[c1][c2] = imgdata.idata.xtrans_abs[c1][c2];
-			  }
-		  }
 	  }
-	  if (!libraw_internal_data.internal_output_params.fuji_width
-		  && imgdata.idata.filters >= 1000
-		  && ((imgdata.sizes.top_margin % 2) || (imgdata.sizes.left_margin % 2)))
+      // set raw_inset_crops[1] via raw_aspect
+      if (imgdata.sizes.raw_aspect >= LIBRAW_IMAGE_ASPECT_MINIMAL_REAL_ASPECT_VALUE
+          && imgdata.sizes.raw_aspect <= LIBRAW_IMAGE_ASPECT_MAXIMAL_REAL_ASPECT_VALUE
+          /* crops[0] is valid*/
+          && (imgdata.sizes.raw_inset_crops[0].cleft < 0xffff)
+          && (imgdata.sizes.raw_inset_crops[0].cleft + imgdata.sizes.raw_inset_crops[0].cwidth <= imgdata.sizes.raw_width)
+          && (imgdata.sizes.raw_inset_crops[0].ctop < 0xffff)
+          && (imgdata.sizes.raw_inset_crops[0].ctop + imgdata.sizes.raw_inset_crops[0].cheight <= imgdata.sizes.raw_height)
+          && imgdata.sizes.raw_inset_crops[0].cwidth > 0 && imgdata.sizes.raw_inset_crops[0].cheight >0
+          /* crops[1] is not set*/
+          && (imgdata.sizes.raw_inset_crops[1].cleft == 0xffff)
+          && (imgdata.sizes.raw_inset_crops[1].ctop == 0xffff)
+          )
+      {
+          float c0_ratio = float(imgdata.sizes.raw_inset_crops[0].cwidth) / float(imgdata.sizes.raw_inset_crops[0].cheight);
+          float c1_ratio = float(imgdata.sizes.raw_aspect) / 1000.f;
+          if (c0_ratio / c1_ratio < 0.98 || c0_ratio / c1_ratio > 1.02) // set crops[1]
+          {
+              if (c1_ratio > c0_ratio) // requested image is wider, cut from top/bottom
+              {
+                  int newheight =  int(imgdata.sizes.raw_inset_crops[0].cwidth / c1_ratio);
+                  int dtop = (imgdata.sizes.raw_inset_crops[0].cheight - newheight) / 2;
+                  imgdata.sizes.raw_inset_crops[1].ctop = imgdata.sizes.raw_inset_crops[0].ctop + dtop;
+                  imgdata.sizes.raw_inset_crops[1].cheight = newheight;
+                  imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[0].cleft;
+                  imgdata.sizes.raw_inset_crops[1].cwidth = imgdata.sizes.raw_inset_crops[0].cwidth;
+              }
+              else
+              {
+                  int newwidth = int(imgdata.sizes.raw_inset_crops[0].cheight * c1_ratio);
+                  int dleft = (imgdata.sizes.raw_inset_crops[0].cwidth - newwidth) / 2;
+                  imgdata.sizes.raw_inset_crops[1].cleft = imgdata.sizes.raw_inset_crops[0].cleft + dleft;
+                  imgdata.sizes.raw_inset_crops[1].cwidth = newwidth;
+                  imgdata.sizes.raw_inset_crops[1].ctop = imgdata.sizes.raw_inset_crops[0].ctop;
+                  imgdata.sizes.raw_inset_crops[1].cheight = imgdata.sizes.raw_inset_crops[0].cheight;
+              }
+          }
+      }
+
+      int adjust_margins = 0;
+      if (makeIs(LIBRAW_CAMERAMAKER_Fujifilm) && (imgdata.idata.filters == 9))
+      {
+          // Adjust top/left margins for X-Trans
+          int newtm = imgdata.sizes.top_margin % 6
+              ? (imgdata.sizes.top_margin / 6 + 1) * 6
+              : imgdata.sizes.top_margin;
+          int newlm = imgdata.sizes.left_margin % 6
+              ? (imgdata.sizes.left_margin / 6 + 1) * 6
+              : imgdata.sizes.left_margin;
+          if (newtm != imgdata.sizes.top_margin ||
+              newlm != imgdata.sizes.left_margin)
+          {
+              imgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);
+              imgdata.sizes.top_margin = newtm;
+              imgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);
+              imgdata.sizes.left_margin = newlm;
+              for (int c1 = 0; c1 < 6; c1++)
+                  for (int c2 = 0; c2 < 6; c2++)
+                      imgdata.idata.xtrans[c1][c2] = imgdata.idata.xtrans_abs[c1][c2];
+          }
+          adjust_margins = 6;
+      }
+      else if (!libraw_internal_data.internal_output_params.fuji_width
+          && imgdata.idata.filters >= 1000)
 	  {
-		  int crop[2] = { 0,0 };
-		  unsigned filt;
-		  int c;
-		  if (imgdata.sizes.top_margin % 2)
-		  {
-			  imgdata.sizes.top_margin += 1;
-			  imgdata.sizes.height -= 1;
-			  crop[1] = 1;
-		  }
-		  if (imgdata.sizes.left_margin % 2)
-		  {
-			  imgdata.sizes.left_margin += 1;
-			  imgdata.sizes.width -= 1;
-			  crop[0] = 1;
-		  }
-		  for (filt = c = 0; c < 16; c++)
-			  filt |= FC((c >> 1) + (crop[1]), (c & 1) + (crop[0])) << c * 2;
-		  imgdata.idata.filters = filt;
+          if ((imgdata.sizes.top_margin % 2) || (imgdata.sizes.left_margin % 2))
+          {
+              int crop[2] = { 0,0 };
+              unsigned filt;
+              int c;
+              if (imgdata.sizes.top_margin % 2)
+              {
+                  imgdata.sizes.top_margin += 1;
+                  imgdata.sizes.height -= 1;
+                  crop[1] = 1;
+              }
+              if (imgdata.sizes.left_margin % 2)
+              {
+                  imgdata.sizes.left_margin += 1;
+                  imgdata.sizes.width -= 1;
+                  crop[0] = 1;
+              }
+              for (filt = c = 0; c < 16; c++)
+                  filt |= FC((c >> 1) + (crop[1]), (c & 1) + (crop[0])) << c * 2;
+              imgdata.idata.filters = filt;
+          }
+          adjust_margins = 2;
 	  }
 
+      if(adjust_margins) // adjust crop_inset margins
+          for (int i = 0; i < 2; i++)
+          {
+              if (imgdata.sizes.raw_inset_crops[i].cleft && imgdata.sizes.raw_inset_crops[i].cleft < 0xffff
+                  && imgdata.sizes.raw_inset_crops[i].cwidth && imgdata.sizes.raw_inset_crops[i].cwidth < 0xffff
+                  && (imgdata.sizes.raw_inset_crops[i].cleft%adjust_margins)
+                  && (imgdata.sizes.raw_inset_crops[i].cwidth > adjust_margins))
+              {
+                  int newleft = ((imgdata.sizes.raw_inset_crops[i].cleft / adjust_margins) + 1) * adjust_margins;
+                  int diff = newleft - imgdata.sizes.raw_inset_crops[i].cleft;
+                  if (diff > 0)
+                  {
+                      imgdata.sizes.raw_inset_crops[i].cleft += diff;
+                      imgdata.sizes.raw_inset_crops[i].cwidth -= diff;
+                  }
+              }
+              if (imgdata.sizes.raw_inset_crops[i].ctop && imgdata.sizes.raw_inset_crops[i].ctop < 0xffff
+                  && imgdata.sizes.raw_inset_crops[i].cheight && imgdata.sizes.raw_inset_crops[i].cheight < 0xffff
+                  && (imgdata.sizes.raw_inset_crops[i].ctop%adjust_margins)
+                  && (imgdata.sizes.raw_inset_crops[i].cheight > adjust_margins))
+              {
+                  int newtop = ((imgdata.sizes.raw_inset_crops[i].ctop / adjust_margins) + 1) * adjust_margins;
+                  int diff = newtop - imgdata.sizes.raw_inset_crops[i].ctop;
+                  if (diff > 0)
+                  {
+                      imgdata.sizes.raw_inset_crops[i].ctop += diff;
+                      imgdata.sizes.raw_inset_crops[i].cheight -= diff;
+                  }
+              }
+          }
+
+
 #ifdef USE_DNGSDK
 	  if (
 		  imgdata.rawparams.use_dngsdk &&
@@ -747,20 +866,17 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
 	  }
 
     if (imgdata.idata.dng_version &&
-        !(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP) &&
 		makeIs(LIBRAW_CAMERAMAKER_Panasonic)
           && !strcasecmp(imgdata.idata.normalized_model, "DMC-LX100"))
       imgdata.sizes.width = 4288;
 
-    if (imgdata.idata.dng_version &&
-        !(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP)
-	&& makeIs(LIBRAW_CAMERAMAKER_Leica)
+    if (imgdata.idata.dng_version
+    	&& makeIs(LIBRAW_CAMERAMAKER_Leica)
         && !strcasecmp(imgdata.idata.normalized_model, "SL2"))
         	imgdata.sizes.height -= 16;
 
 	if (makeIs(LIBRAW_CAMERAMAKER_Sony) &&
-        imgdata.idata.dng_version &&
-        !(imgdata.rawparams.options & LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP))
+        imgdata.idata.dng_version)
     {
       if (S.raw_width == 3984)
         S.width = 3925;
diff --git a/src/utils/thumb_utils.cpp b/src/utils/thumb_utils.cpp
index 00af09bd..6a08db92 100644
--- a/src/utils/thumb_utils.cpp
+++ b/src/utils/thumb_utils.cpp
@@ -235,11 +235,16 @@ int LibRaw::thumbOK(INT64 maxsz)
     return 0;
   if (!ID.toffset && !(imgdata.thumbnail.tlength > 0 &&
                        load_raw == &LibRaw::broadcom_load_raw) // RPi
+#ifdef USE_6BY9RPI
+      && !(imgdata.thumbnail.tlength > 0 && libraw_internal_data.unpacker_data.load_flags & 0x4000 &&
+           (load_raw == &LibRaw::rpi_load_raw8 || load_raw == &LibRaw::nokia_load_raw ||
+            load_raw == &LibRaw::rpi_load_raw12 || load_raw == &LibRaw::rpi_load_raw14))
+#endif
   )
     return 0;
   INT64 fsize = ID.input->size();
-  if (fsize > 0x7fffffffU)
-    return 0; // No thumb for raw > 2Gb
+  if (fsize > 0xffffffffU)
+    return 0; // No thumb for raw > 4Gb-1
   int tsize = 0;
   int tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;
   if (write_thumb == &LibRaw::jpeg_thumb)
diff --git a/src/utils/utils_libraw.cpp b/src/utils/utils_libraw.cpp
index 3ca4f27b..f76556d9 100644
--- a/src/utils/utils_libraw.cpp
+++ b/src/utils/utils_libraw.cpp
@@ -612,6 +612,37 @@ short LibRaw::tiff_sget (unsigned save, uchar *buf, unsigned buf_len, INT64 *tag
   return 0;
 }
 
+#define rICC  imgdata.sizes.raw_inset_crops
+#define S imgdata.sizes
+#define RS imgdata.rawdata.sizes
+int LibRaw::adjust_to_raw_inset_crop(unsigned mask, float maxcrop)
+
+{
+    int adjindex = -1;
+	int limwidth = S.width * maxcrop;
+	int limheight = S.height * maxcrop;
+
+    for(int i = 1; i >= 0; i--)
+        if (mask & (1<<i))
+            if (rICC[i].ctop < 0xffff && rICC[i].cleft < 0xffff
+                && rICC[i].cleft + rICC[i].cwidth <= S.raw_width
+                && rICC[i].ctop + rICC[i].cheight <= S.raw_height
+				&& rICC[i].cwidth >= limwidth && rICC[i].cheight >= limheight)
+            {
+                adjindex = i;
+                break;
+            }
+
+    if (adjindex >= 0)
+    {
+        RS.left_margin = S.left_margin = rICC[adjindex].cleft;
+        RS.top_margin = S.top_margin = rICC[adjindex].ctop;
+        RS.width = S.width = MIN(rICC[adjindex].cwidth, int(S.raw_width) - int(S.left_margin));
+        RS.height = S.height = MIN(rICC[adjindex].cheight, int(S.raw_height) - int(S.top_margin));
+    }
+    return adjindex + 1;
+}
+
 char** LibRaw::malloc_omp_buffers(int buffer_count, size_t buffer_size, const char* where)
 {
     char** buffers = (char**)malloc(sizeof(char*) * buffer_count);
diff --git a/src/x3f/x3f_parse_process.cpp b/src/x3f/x3f_parse_process.cpp
index 0272fc79..5ac9aa6f 100644
--- a/src/x3f/x3f_parse_process.cpp
+++ b/src/x3f/x3f_parse_process.cpp
@@ -137,18 +137,18 @@ void LibRaw::parse_x3f()
     {
       int i;
       x3f_property_t *P = PL->property_table.element;
-      for (i = 0; i < PL->num_properties; i++)
+      for (i = 0; i < (int)PL->num_properties; i++)
       {
         char name[100], value[100];
         int noffset = (P[i].name - datap);
         int voffset = (P[i].value - datap);
-        if (noffset < 0 || noffset > maxitems || voffset < 0 ||
-            voffset > maxitems)
+        if (noffset < 0 || noffset > (int)maxitems || voffset < 0 ||
+            voffset > (int)maxitems)
           throw LIBRAW_EXCEPTION_IO_CORRUPT;
         int maxnsize = maxitems - (P[i].name - datap);
         int maxvsize = maxitems - (P[i].value - datap);
-        utf2char(P[i].name, name, MIN(maxnsize, sizeof(name)));
-        utf2char(P[i].value, value, MIN(maxvsize, sizeof(value)));
+        utf2char(P[i].name, name, MIN(maxnsize, ((int)sizeof(name))));
+        utf2char(P[i].value, value, MIN(maxvsize, ((int)sizeof(value))));
         if (!strcmp(name, "ISO"))
           imgdata.other.iso_speed = atoi(value);
         if (!strcmp(name, "CAMMANUF"))
@@ -350,7 +350,7 @@ void LibRaw::x3f_thumb_loader()
       imgdata.thumbnail.thumb = (char *)malloc(ID->columns * ID->rows * 3);
       merror(imgdata.thumbnail.thumb, "LibRaw::x3f_thumb_loader()");
       char *src0 = (char *)ID->data;
-      for (int row = 0; row < ID->rows; row++)
+      for (int row = 0; row < (int)ID->rows; row++)
       {
         int offset = row * ID->row_stride;
         if (offset + ID->columns * 3 > ID->data_size)
@@ -440,7 +440,7 @@ void LibRaw::x3f_dpq_interpolate_af(int xstep, int ystep, int scale)
       if (_ABS(pixf[2] - pixel0[2]) > _ABS(pixel_right[2] - pixel0[2]))
         pixf = pixel_right;
       int blocal = pixel0[2], bnear = pixf[2];
-      if (blocal < imgdata.color.black + 16 || bnear < imgdata.color.black + 16)
+      if (blocal < (int)imgdata.color.black + 16 || bnear < (int)imgdata.color.black + 16)
       {
         if (pixel0[0] < imgdata.color.black)
           pixel0[0] = imgdata.color.black;
@@ -613,7 +613,7 @@ void LibRaw::x3f_load_raw()
     {
       // Move quattro data in place
       // R/B plane
-      for (int prow = 0; prow < TRU->x3rgb16.rows && prow < S.raw_height / 2;
+      for (int prow = 0; prow < (int)TRU->x3rgb16.rows && prow < S.raw_height / 2;
            prow++)
       {
         ushort(*destrow)[3] =
@@ -623,21 +623,21 @@ void LibRaw::x3f_load_raw()
         ushort(*srcrow)[3] =
             (unsigned short(*)[3]) & data[prow * TRU->x3rgb16.row_stride];
         for (int pcol = 0;
-             pcol < TRU->x3rgb16.columns && pcol < S.raw_width / 2; pcol++)
+             pcol < (int)TRU->x3rgb16.columns && pcol < S.raw_width / 2; pcol++)
         {
           destrow[pcol * 2][0] = srcrow[pcol][0];
           destrow[pcol * 2][1] = srcrow[pcol][1];
         }
       }
-      for (int row = 0; row < Q->top16.rows && row < S.raw_height; row++)
+      for (int row = 0; row < (int)Q->top16.rows && row < S.raw_height; row++)
       {
         ushort(*destrow)[3] =
             (unsigned short(*)[3]) &
             imgdata.rawdata
                 .color3_image[row * S.raw_pitch / 3 / sizeof(ushort)][0];
-        ushort(*srcrow) =
+        ushort *srcrow =
             (unsigned short *)&Q->top16.data[row * Q->top16.columns];
-        for (int col = 0; col < Q->top16.columns && col < S.raw_width; col++)
+        for (int col = 0; col < (int)Q->top16.columns && col < S.raw_width; col++)
           destrow[col][2] = srcrow[col];
       }
     }
diff --git a/src/x3f/x3f_utils_patched.cpp b/src/x3f/x3f_utils_patched.cpp
index 53e02cc3..a84b8be9 100644
--- a/src/x3f/x3f_utils_patched.cpp
+++ b/src/x3f/x3f_utils_patched.cpp
@@ -135,7 +135,7 @@ unsigned x3f_get4(LibRaw_abstract_datastream *f)
     (_T).size = (_NUM);                                                        \
     (_T).element =                                                             \
         (_TYPE *)realloc((_T).element, (_NUM) * sizeof((_T).element[0]));      \
-    for (_i = 0; _i < (_T).size; _i++)                                         \
+    for (_i = 0; _i < (int)(_T).size; _i++)                                         \
       _GETX((_T).element[_i]);                                                 \
   } while (0)
 
@@ -146,7 +146,7 @@ unsigned x3f_get4(LibRaw_abstract_datastream *f)
     (_T).size = (_NUM);                                                        \
     (_T).element = (x3f_property_t *)realloc(                                  \
         (_T).element, (_NUM) * sizeof((_T).element[0]));                       \
-    for (_i = 0; _i < (_T).size; _i++)                                         \
+    for (_i = 0; _i < (int)(_T).size; _i++)                                         \
     {                                                                          \
       GET4((_T).element[_i].name_offset);                                      \
       GET4((_T).element[_i].value_offset);                                     \
@@ -387,7 +387,7 @@ static x3f_huffman_t *new_huffman(x3f_huffman_t **HUFP)
     }
 
     /* Traverse the directory */
-    for (d = 0; d < DS->num_directory_entries; d++)
+    for (d = 0; d < (int)DS->num_directory_entries; d++)
     {
       x3f_directory_entry_t *DE = &DS->directory_entry[d];
       x3f_directory_entry_header_t *DEH = &DE->header;
@@ -526,7 +526,7 @@ static void free_camf_entry(camf_entry_t *entry)
   if (DS->num_directory_entries > 50)
     return X3F_ARGUMENT_ERROR;
 
-  for (d = 0; d < DS->num_directory_entries; d++)
+  for (d = 0; d < (int)DS->num_directory_entries; d++)
   {
     x3f_directory_entry_t *DE = &DS->directory_entry[d];
     x3f_directory_entry_header_t *DEH = &DE->header;
@@ -560,7 +560,7 @@ static void free_camf_entry(camf_entry_t *entry)
         FREE(CAMF->table.element);
         cleanup_huffman_tree(&CAMF->tree);
         FREE(CAMF->decoded_data);
-        for (i = 0; i < CAMF->entry_table.size; i++)
+        for (i = 0; i < (int)CAMF->entry_table.size; i++)
         {
           free_camf_entry(&CAMF->entry_table.element[i]);
         }
@@ -592,7 +592,7 @@ static x3f_directory_entry_t *x3f_get(x3f_t *x3f, uint32_t type,
 
   DS = &x3f->directory_section;
 
-  for (d = 0; d < DS->num_directory_entries; d++)
+  for (d = 0; d < (int)DS->num_directory_entries; d++)
   {
     x3f_directory_entry_t *DE = &DS->directory_entry[d];
     x3f_directory_entry_header_t *DEH = &DE->header;
@@ -749,7 +749,7 @@ static void populate_true_huffman_tree(x3f_hufftree_t *tree,
 
   new_node(tree);
 
-  for (i = 0; i < table->size; i++)
+  for (i = 0; i < (int)table->size; i++)
   {
     x3f_true_huffman_element_t *element = &table->element[i];
     uint32_t length = element->code_size;
@@ -782,7 +782,7 @@ static void populate_huffman_tree(x3f_hufftree_t *tree, x3f_table32_t *table,
 
   new_node(tree);
 
-  for (i = 0; i < table->size; i++)
+  for (i = 0; i < (int)table->size; i++)
   {
     uint32_t element = table->element[i];
 
@@ -967,13 +967,13 @@ static void true_decode_one_color(x3f_image_data_t *ID, int color)
   if (rows != area->rows || cols < area->columns)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
 
-  for (row = 0; row < rows; row++)
+  for (row = 0; row < (int)rows; row++)
   {
     int col;
     bool_t odd_row = row & 1;
     int32_t acc[2];
 
-    for (col = 0; col < cols; col++)
+    for (col = 0; col < (int)cols; col++)
     {
       bool_t odd_col = col & 1;
       int32_t diff = get_true_diff(&BS, tree);
@@ -985,7 +985,7 @@ static void true_decode_one_color(x3f_image_data_t *ID, int color)
         row_start_acc[odd_row][odd_col] = value;
 
       /* Discard additional data at the right for binned Quattro plane 2 */
-      if (col >= area->columns)
+      if (col >= (int)area->columns)
         continue;
 
       *dst = value;
@@ -1047,7 +1047,7 @@ static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,
 	  throw LIBRAW_EXCEPTION_IO_CORRUPT;
   set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);
 
-  for (col = 0; col < ID->columns; col++)
+  for (col = 0; col < (int)ID->columns; col++)
   {
     int color;
 
@@ -1094,13 +1094,13 @@ static void huffman_decode(x3f_info_t *I, x3f_directory_entry_t *DE, int bits)
   int minimum = 0;
   int offset = legacy_offset;
 
-  for (row = 0; row < ID->rows; row++)
+  for (row = 0; row < (int)ID->rows; row++)
     huffman_decode_row(I, DE, bits, row, offset, &minimum);
 
   if (auto_legacy_offset && minimum < 0)
   {
     offset = -minimum;
-    for (row = 0; row < ID->rows; row++)
+    for (row = 0; row < (int)ID->rows; row++)
       huffman_decode_row(I, DE, bits, row, offset, &minimum);
   }
 }
@@ -1120,7 +1120,7 @@ static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,
   x3f_image_data_t *ID = &DEH->data_subsection.image_data;
   x3f_huffman_t *HUF = ID->huffman;
 
-  if (row*row_stride > ID->data_size - (ID->columns*sizeof(uint32_t)))
+  if (row*row_stride > (int)(ID->data_size - (ID->columns*sizeof(uint32_t))))
 	  throw LIBRAW_EXCEPTION_IO_CORRUPT;
   uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);
 
@@ -1153,7 +1153,7 @@ static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,
     break;
   }
 
-  for (col = 0; col < ID->columns; col++)
+  for (col = 0; col < (int)ID->columns; col++)
   {
     int color;
     uint32_t val = data[col];
@@ -1192,7 +1192,7 @@ static void simple_decode(x3f_info_t *I, x3f_directory_entry_t *DE, int bits,
 
   int row;
 
-  for (row = 0; row < ID->rows; row++)
+  for (row = 0; row < (int)ID->rows; row++)
     simple_decode_row(I, DE, bits, row, row_stride);
 }
 
@@ -1267,7 +1267,7 @@ static void x3f_load_property_list(x3f_info_t *I, x3f_directory_entry_t *DE)
   uint32_t maxoffset = PL->data_size / sizeof(utf16_t) -
                        2; // at least 2 chars, value + terminating 0x0000
 
-  for (i = 0; i < PL->num_properties; i++)
+  for (i = 0; i < (int)PL->num_properties; i++)
   {
     x3f_property_t *P = &PL->property_table.element[i];
     if (P->name_offset > maxoffset || P->value_offset > maxoffset)
@@ -1563,7 +1563,7 @@ static void x3f_load_camf_decode_type2(x3f_camf_t *CAMF)
   CAMF->decoded_data_size = CAMF->data_size;
   CAMF->decoded_data = malloc(CAMF->decoded_data_size);
 
-  for (i = 0; i < CAMF->data_size; i++)
+  for (i = 0; i < (int)CAMF->data_size; i++)
   {
     uint8_t old, _new;
     uint32_t tmp;
@@ -1615,7 +1615,7 @@ static void camf_decode_type4(x3f_camf_t *CAMF)
   row_start_acc[1][0] = seed;
   row_start_acc[1][1] = seed;
 
-  for (row = 0; row < rows; row++)
+  for (row = 0; row < (int)rows; row++)
   {
     int col;
     bool_t odd_row = row & 1;
@@ -1624,7 +1624,7 @@ static void camf_decode_type4(x3f_camf_t *CAMF)
     /* We loop through all the columns and the rows. But the actual
        data is smaller than that, so we break the loop when reaching
        the end. */
-    for (col = 0; col < cols; col++)
+    for (col = 0; col < (int)cols; col++)
     {
       bool_t odd_col = col & 1;
       int32_t diff = get_true_diff(&BS, tree);
@@ -1728,7 +1728,7 @@ static void camf_decode_type5(x3f_camf_t *CAMF)
 
   set_bit_state(&BS, CAMF->decoding_start);
 
-  for (i = 0; i < CAMF->decoded_data_size; i++)
+  for (i = 0; i < (int)CAMF->decoded_data_size; i++)
   {
     int32_t diff = get_true_diff(&BS, tree);
 
@@ -1792,7 +1792,7 @@ static void x3f_setup_camf_property_entry(camf_entry_t *entry)
   entry->property_name = (char **)malloc(num * sizeof(uint8_t *));
   entry->property_value = (uint8_t **)malloc(num * sizeof(uint8_t *));
 
-  for (i = 0; i < num; i++)
+  for (i = 0; i < (int)num; i++)
   {
     uint32_t name_off = off + *(uint32_t *)(v + 8 + 8 * i);
     uint32_t value_off = off + *(uint32_t *)(v + 8 + 8 * i + 4);
@@ -1856,7 +1856,7 @@ static void get_matrix_copy(camf_entry_t *entry)
       memcpy(entry->matrix_decoded, entry->matrix_data, size);
       break;
     case M_FLOAT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((double *)entry->matrix_decoded)[i] =
             (double)((float *)entry->matrix_data)[i];
       break;
@@ -1868,12 +1868,12 @@ static void get_matrix_copy(camf_entry_t *entry)
     switch (entry->matrix_decoded_type)
     {
     case M_INT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((int32_t *)entry->matrix_decoded)[i] =
             (int32_t)((int16_t *)entry->matrix_data)[i];
       break;
     case M_UINT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((uint32_t *)entry->matrix_decoded)[i] =
             (uint32_t)((uint16_t *)entry->matrix_data)[i];
       break;
@@ -1885,12 +1885,12 @@ static void get_matrix_copy(camf_entry_t *entry)
     switch (entry->matrix_decoded_type)
     {
     case M_INT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((int32_t *)entry->matrix_decoded)[i] =
             (int32_t)((int8_t *)entry->matrix_data)[i];
       break;
     case M_UINT:
-      for (i = 0; i < elements; i++)
+      for (i = 0; i < (int)elements; i++)
         ((uint32_t *)entry->matrix_decoded)[i] =
             (uint32_t)((uint8_t *)entry->matrix_data)[i];
       break;
@@ -1916,14 +1916,14 @@ static void x3f_setup_camf_matrix_entry(camf_entry_t *entry)
   camf_dim_entry_t *dentry = entry->matrix_dim_entry =
       (camf_dim_entry_t *)malloc(dim * sizeof(camf_dim_entry_t));
 
-  for (i = 0; i < dim; i++)
+  for (i = 0; i < (int)dim; i++)
   {
     uint32_t size = dentry[i].size = *(uint32_t *)(v + 12 + 12 * i + 0);
     dentry[i].name_offset = *(uint32_t *)(v + 12 + 12 * i + 4);
     dentry[i].n = *(uint32_t *)(v + 12 + 12 * i + 8);
     dentry[i].name = (char *)(e + dentry[i].name_offset);
 
-    if (dentry[i].n != i)
+    if ((int)dentry[i].n != i)
     {
     }
 
