From ab51d587bb9b229b1fade1afd02e1574c1ba5c76 Mon Sep 17 00:00:00 2001
From: Lukas Czerner <lczerner@redhat.com>
Date: Thu, 21 Apr 2022 19:31:48 +0200
Subject: [PATCH 01/22] libext2fs: add sanity check to extent manipulation

It is possible to have a corrupted extent tree in such a way that a leaf
node contains zero extents in it. Currently if that happens and we try
to traverse the tree we can end up accessing wrong data, or possibly
even uninitialized memory. Make sure we don't do that.

Additionally make sure that we have a sane number of bytes passed to
memmove() in ext2fs_extent_delete().

Note that e2fsck is currently unable to spot and fix such corruption in
pass1.

Signed-off-by: Lukas Czerner <lczerner@redhat.com>
Reported-by: Nils Bars <nils_bars@t-online.de>
Addresses: https://bugzilla.redhat.com/show_bug.cgi?id=2068113
Addresses: CVE-2022-1304
Addresses-Debian-Bug: #1010263
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 lib/ext2fs/extent.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/lib/ext2fs/extent.c b/lib/ext2fs/extent.c
index b324c7b0f..1a206a16c 100644
--- a/lib/ext2fs/extent.c
+++ b/lib/ext2fs/extent.c
@@ -495,6 +495,10 @@ errcode_t ext2fs_extent_get(ext2_extent_handle_t handle,
 			ext2fs_le16_to_cpu(eh->eh_entries);
 		newpath->max_entries = ext2fs_le16_to_cpu(eh->eh_max);
 
+		/* Make sure there is at least one extent present */
+		if (newpath->left <= 0)
+			return EXT2_ET_EXTENT_NO_DOWN;
+
 		if (path->left > 0) {
 			ix++;
 			newpath->end_blk = ext2fs_le32_to_cpu(ix->ei_block);
@@ -1630,6 +1634,10 @@ errcode_t ext2fs_extent_delete(ext2_extent_handle_t handle, int flags)
 
 	cp = path->curr;
 
+	/* Sanity check before memmove() */
+	if (path->left < 0)
+		return EXT2_ET_EXTENT_LEAF_BAD;
+
 	if (path->left) {
 		memmove(cp, cp + sizeof(struct ext3_extent_idx),
 			path->left * sizeof(struct ext3_extent_idx));

From 997902106fab2bc7cb0f7251eb55fad4b721b51a Mon Sep 17 00:00:00 2001
From: Lukas Czerner <lczerner@redhat.com>
Date: Thu, 17 Feb 2022 10:24:58 +0100
Subject: [PATCH 02/22] resize2fs: remove unused variable 'c'

Signed-off-by: Lukas Czerner <lczerner@redhat.com>
Reviewed-by: Andreas Dilger <adilger@dilger.ca>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 resize/resize2fs.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/resize/resize2fs.c b/resize/resize2fs.c
index b9783e8cc..d69cb01ed 100644
--- a/resize/resize2fs.c
+++ b/resize/resize2fs.c
@@ -2847,7 +2847,7 @@ static errcode_t resize2fs_calculate_summary_stats(ext2_filsys fs)
 	errcode_t	retval;
 	blk64_t		blk = fs->super->s_first_data_block;
 	ext2_ino_t	ino;
-	unsigned int	n, c, group, count;
+	unsigned int	n, group, count;
 	blk64_t		total_clusters_free = 0;
 	int		total_inodes_free = 0;
 	int		group_free = 0;

From a282671a02e8fffa04ac0f9db7982fd6bb0a0916 Mon Sep 17 00:00:00 2001
From: Lukas Czerner <lczerner@redhat.com>
Date: Thu, 17 Feb 2022 10:24:59 +0100
Subject: [PATCH 03/22] libss: fix possible NULL pointer dereferece on
 allocation failure

Currently in ss_execute_command() we're missng a check to see if the
memory allocation was succesful. Fix it by checking the return from
malloc and returning ENOMEM if it had failed.

[ Removed addition of the SS_ET_ENOMEM entry to the the libss error
  table.  -TYT ]

Signed-off-by: Lukas Czerner <lczerner@redhat.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 lib/ss/execute_cmd.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/lib/ss/execute_cmd.c b/lib/ss/execute_cmd.c
index d443a4685..2e2c8cfa0 100644
--- a/lib/ss/execute_cmd.c
+++ b/lib/ss/execute_cmd.c
@@ -171,6 +171,8 @@ int ss_execute_command(int sci_idx, register char *argv[])
 	for (argp = argv; *argp; argp++)
 		argc++;
 	argp = (char **)malloc((argc+1)*sizeof(char *));
+	if (!argp)
+		return(ENOMEM);
 	for (i = 0; i <= argc; i++)
 		argp[i] = argv[i];
 	i = really_execute_command(sci_idx, argc, &argp);

From 97079a792dd5e9ea9d4708d2e80244c930a139cd Mon Sep 17 00:00:00 2001
From: Lukas Czerner <lczerner@redhat.com>
Date: Thu, 17 Feb 2022 10:25:00 +0100
Subject: [PATCH 04/22] Use mallinfo2 instead of mallinfo if available

mallinfo has been deprecated with GNU C library version 2.33 in favor of
mallinfo2 which works exactly the same as mallinfo but with larger field
widths. Use mallinfo2 if available.

Signed-off-by: Lukas Czerner <lczerner@redhat.com>
Reviewed-by: Andreas Dilger <adilger@dilger.ca>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 configure               |  2 +-
 configure.ac            |  1 +
 e2fsck/iscan.c          | 11 ++++++++++-
 e2fsck/util.c           | 11 ++++++++++-
 lib/config.h.in         |  3 +++
 resize/resource_track.c | 13 ++++++++++---
 6 files changed, 35 insertions(+), 6 deletions(-)

diff --git a/configure b/configure
index effd929d8..530bc77ca 100755
--- a/configure
+++ b/configure
@@ -11254,7 +11254,7 @@ fi
 if test -n "$DLOPEN_LIB" ; then
    ac_cv_func_dlopen=yes
 fi
-for ac_func in  	__secure_getenv 	add_key 	backtrace 	chflags 	dlopen 	fadvise64 	fallocate 	fallocate64 	fchown 	fcntl 	fdatasync 	fstat64 	fsync 	ftruncate64 	futimes 	getcwd 	getdtablesize 	getentropy 	gethostname 	getmntinfo 	getpwuid_r 	getrandom 	getrlimit 	getrusage 	jrand48 	keyctl 	llistxattr 	llseek 	lseek64 	mallinfo 	mbstowcs 	memalign 	mempcpy 	mmap 	msync 	nanosleep 	open64 	pathconf 	posix_fadvise 	posix_fadvise64 	posix_memalign 	prctl 	pread 	pwrite 	pread64 	pwrite64 	secure_getenv 	setmntent 	setresgid 	setresuid 	snprintf 	srandom 	stpcpy 	strcasecmp 	strdup 	strnlen 	strptime 	strtoull 	sync_file_range 	sysconf 	usleep 	utime 	utimes 	valloc
+for ac_func in  	__secure_getenv 	add_key 	backtrace 	chflags 	dlopen 	fadvise64 	fallocate 	fallocate64 	fchown 	fcntl 	fdatasync 	fstat64 	fsync 	ftruncate64 	futimes 	getcwd 	getdtablesize 	getentropy 	gethostname 	getmntinfo 	getpwuid_r 	getrandom 	getrlimit 	getrusage 	jrand48 	keyctl 	llistxattr 	llseek 	lseek64 	mallinfo 	mallinfo2 	mbstowcs 	memalign 	mempcpy 	mmap 	msync 	nanosleep 	open64 	pathconf 	posix_fadvise 	posix_fadvise64 	posix_memalign 	prctl 	pread 	pwrite 	pread64 	pwrite64 	secure_getenv 	setmntent 	setresgid 	setresuid 	snprintf 	srandom 	stpcpy 	strcasecmp 	strdup 	strnlen 	strptime 	strtoull 	sync_file_range 	sysconf 	usleep 	utime 	utimes 	valloc
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
diff --git a/configure.ac b/configure.ac
index dff3d1ca7..8acc4e1cb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1214,6 +1214,7 @@ AC_CHECK_FUNCS(m4_flatten([
 	llseek
 	lseek64
 	mallinfo
+	mallinfo2
 	mbstowcs
 	memalign
 	mempcpy
diff --git a/e2fsck/iscan.c b/e2fsck/iscan.c
index 607e47528..33c6a4cdc 100644
--- a/e2fsck/iscan.c
+++ b/e2fsck/iscan.c
@@ -109,7 +109,16 @@ void print_resource_track(const char *desc,
 		printf("%s: ", desc);
 
 #define kbytes(x)	(((unsigned long long)(x) + 1023) / 1024)
-#ifdef HAVE_MALLINFO
+#ifdef HAVE_MALLINFO2
+	if (1) {
+		struct mallinfo2 malloc_info = mallinfo2();
+
+		printf("Memory used: %lluk/%lluk (%lluk/%lluk), ",
+		       kbytes(malloc_info.arena), kbytes(malloc_info.hblkhd),
+		       kbytes(malloc_info.uordblks),
+		       kbytes(malloc_info.fordblks));
+	} else
+#elif defined HAVE_MALLINFO
 	/* don't use mallinfo() if over 2GB used, since it returns "int" */
 	if ((char *)sbrk(0) - (char *)track->brk_start < 2LL << 30) {
 		struct mallinfo	malloc_info = mallinfo();
diff --git a/e2fsck/util.c b/e2fsck/util.c
index 3fe3c9888..42740d9ef 100644
--- a/e2fsck/util.c
+++ b/e2fsck/util.c
@@ -430,7 +430,16 @@ void print_resource_track(e2fsck_t ctx, const char *desc,
 		log_out(ctx, "%s: ", desc);
 
 #define kbytes(x)	(((unsigned long long)(x) + 1023) / 1024)
-#ifdef HAVE_MALLINFO
+#ifdef HAVE_MALLINFO2
+	if (1) {
+		struct mallinfo2 malloc_info = mallinfo2();
+
+		log_out(ctx, _("Memory used: %lluk/%lluk (%lluk/%lluk), "),
+			kbytes(malloc_info.arena), kbytes(malloc_info.hblkhd),
+			kbytes(malloc_info.uordblks),
+			kbytes(malloc_info.fordblks));
+	} else
+#elif defined HAVE_MALLINFO
 	/* don't use mallinfo() if over 2GB used, since it returns "int" */
 	if ((char *)sbrk(0) - (char *)track->brk_start < 2LL << 30) {
 		struct mallinfo	malloc_info = mallinfo();
diff --git a/lib/config.h.in b/lib/config.h.in
index 9c9de65da..b5856bb57 100644
--- a/lib/config.h.in
+++ b/lib/config.h.in
@@ -208,6 +208,9 @@
 /* Define to 1 if you have the `mallinfo' function. */
 #undef HAVE_MALLINFO
 
+/* Define to 1 if you have the `mallinfo2' function. */
+#undef HAVE_MALLINFO2
+
 /* Define to 1 if you have the <malloc.h> header file. */
 #undef HAVE_MALLOC_H
 
diff --git a/resize/resource_track.c b/resize/resource_track.c
index f0efe1141..f46670606 100644
--- a/resize/resource_track.c
+++ b/resize/resource_track.c
@@ -63,8 +63,10 @@ void print_resource_track(ext2_resize_t rfs, struct resource_track *track,
 #ifdef HAVE_GETRUSAGE
 	struct rusage r;
 #endif
-#ifdef HAVE_MALLINFO
-	struct mallinfo	malloc_info;
+#ifdef HAVE_MALLINFO2
+	struct mallinfo2 malloc_info;
+#elif defined HAVE_MALLINFO
+	struct mallinfo malloc_info;
 #endif
 	struct timeval time_end;
 
@@ -76,8 +78,13 @@ void print_resource_track(ext2_resize_t rfs, struct resource_track *track,
 	if (track->desc)
 		printf("%s: ", track->desc);
 
-#ifdef HAVE_MALLINFO
 #define kbytes(x)	(((unsigned long)(x) + 1023) / 1024)
+#ifdef HAVE_MALLINFO2
+	malloc_info = mallinfo2();
+	printf("Memory used: %luk/%luk (%luk/%luk), ",
+		kbytes(malloc_info.arena), kbytes(malloc_info.hblkhd),
+		kbytes(malloc_info.uordblks), kbytes(malloc_info.fordblks));
+#elif defined HAVE_MALLINFO
 
 	malloc_info = mallinfo();
 	printf("Memory used: %luk/%luk (%luk/%luk), ",

From 63f265c857e79bf59982985158154b3edb429e70 Mon Sep 17 00:00:00 2001
From: Andreas Dilger <adilger@dilger.ca>
Date: Wed, 1 Dec 2021 15:56:51 -0700
Subject: [PATCH 05/22] misc: fix chattr usage message for project ID

Fix the "chattr -h" usage message to properly document that the
"-p" option takes a project argument, like "-v" takes a version.

Update the man page formatting to emphasize literal strings.

Signed-off-by: Andreas Dilger <adilger@dilger.ca>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 misc/chattr.1.in | 86 +++++++++++++++++++++++++++++++++---------------
 misc/chattr.c    |  2 +-
 2 files changed, 61 insertions(+), 27 deletions(-)

diff --git a/misc/chattr.1.in b/misc/chattr.1.in
index 922410b62..cd2e0020c 100644
--- a/misc/chattr.1.in
+++ b/misc/chattr.1.in
@@ -23,44 +23,77 @@ chattr \- change file attributes on a Linux file system
 .B chattr
 changes the file attributes on a Linux file system.
 .PP
-The format of a symbolic mode is +-=[aAcCdDeFijmPsStTux].
+The format of a symbolic
+.I mode
+is
+.BR +-= [ aAcCdDeFijmPsStTux ].
 .PP
-The operator '+' causes the selected attributes to be added to the
-existing attributes of the files; '-' causes them to be removed; and '='
+The operator
+.RB ' + '
+causes the selected attributes to be added to the
+existing attributes of the files;
+.RB ' - '
+causes them to be removed; and
+.RB ' = '
 causes them to be the only attributes that the files have.
 .PP
-The letters 'aAcCdDeFijmPsStTux' select the new attributes for the files:
-append only (a),
-no atime updates (A),
-compressed (c),
-no copy on write (C),
-no dump (d),
-synchronous directory updates (D),
-extent format (e),
-case-insensitive directory lookups (F),
-immutable (i),
-data journaling (j),
-don't compress (m),
-project hierarchy (P),
-secure deletion (s),
-synchronous updates (S),
-no tail-merging (t),
-top of directory hierarchy (T),
-undeletable (u),
-and direct access for files (x).
+The letters
+.RB ' aAcCdDeFijmPsStTux '
+select the new attributes for the files:
+append only
+.RB ( a ),
+no atime updates
+.RB ( A ),
+compressed
+.RB ( c ),
+no copy on write
+.RB ( C ),
+no dump
+.RB ( d ),
+synchronous directory updates
+.RB ( D ),
+extent format
+.RB ( e ),
+case-insensitive directory lookups
+.RB ( F ),
+immutable
+.RB ( i ),
+data journaling
+.RB ( j ),
+don't compress
+.RB ( m ),
+project hierarchy
+.RB ( P ),
+secure deletion
+.RB ( s ),
+synchronous updates
+.RB ( S ),
+no tail-merging
+.RB ( t ),
+top of directory hierarchy
+.RB ( T ),
+undeletable
+.RB ( u ),
+and direct access for files
+.RB ( x ).
 .PP
 The following attributes are read-only, and may be listed by
 .BR lsattr (1)
 but not modified by chattr:
-encrypted (E),
-indexed directory (I),
-inline data (N),
-and verity (V).
+encrypted
+.RB ( E ),
+indexed directory
+.RB ( I ),
+inline data
+.RB ( N ),
+and verity
+.RB ( V ).
 .PP
 Not all flags are supported or utilized by all file systems; refer to
 file system-specific man pages such as
 .BR btrfs (5),
 .BR ext4 (5),
+.BR mkfs.f2fs (8),
 and
 .BR xfs (5)
 for more file system-specific details.
@@ -258,4 +291,5 @@ http://e2fsprogs.sourceforge.net.
 .BR lsattr (1),
 .BR btrfs (5),
 .BR ext4 (5),
+.BR mkfs.f2fs (8),
 .BR xfs (5).
diff --git a/misc/chattr.c b/misc/chattr.c
index 644ef4e99..c7382a37a 100644
--- a/misc/chattr.c
+++ b/misc/chattr.c
@@ -86,7 +86,7 @@ static unsigned long sf;
 static void usage(void)
 {
 	fprintf(stderr,
-		_("Usage: %s [-pRVf] [-+=aAcCdDeijPsStTuFx] [-v version] files...\n"),
+		_("Usage: %s [-RVf] [-+=aAcCdDeijPsStTuFx] [-p project] [-v version] files...\n"),
 		program_name);
 	exit(1);
 }

From c1bd25333e8986b081b82a8eb8c9173a0c7480af Mon Sep 17 00:00:00 2001
From: Andreas Dilger <adilger@dilger.ca>
Date: Wed, 8 Dec 2021 00:51:12 -0700
Subject: [PATCH 06/22] e2fsck: map PROMPT_* values to prompt messages

It isn't totally clear when searching the code for PROMPT_*
constants from problem codes where these messages come from.
Similarly, there isn't a direct mapping from the prompt string
to the constant.

Add comments that make this mapping more clear.

Signed-off-by: Andreas Dilger <adilger@dilger.ca>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 e2fsck/problem.c | 46 +++++++++++++++++++++++-----------------------
 1 file changed, 23 insertions(+), 23 deletions(-)

diff --git a/e2fsck/problem.c b/e2fsck/problem.c
index 757b5d564..2d02468c8 100644
--- a/e2fsck/problem.c
+++ b/e2fsck/problem.c
@@ -50,29 +50,29 @@
  * to fix a problem.
  */
 static const char *prompt[] = {
-	N_("(no prompt)"),	/* 0 */
-	N_("Fix"),		/* 1 */
-	N_("Clear"),		/* 2 */
-	N_("Relocate"),		/* 3 */
-	N_("Allocate"),		/* 4 */
-	N_("Expand"),		/* 5 */
-	N_("Connect to /lost+found"), /* 6 */
-	N_("Create"),		/* 7 */
-	N_("Salvage"),		/* 8 */
-	N_("Truncate"),		/* 9 */
-	N_("Clear inode"),	/* 10 */
-	N_("Abort"),		/* 11 */
-	N_("Split"),		/* 12 */
-	N_("Continue"),		/* 13 */
-	N_("Clone multiply-claimed blocks"), /* 14 */
-	N_("Delete file"),	/* 15 */
-	N_("Suppress messages"),/* 16 */
-	N_("Unlink"),		/* 17 */
-	N_("Clear HTree index"),/* 18 */
-	N_("Recreate"),		/* 19 */
-	N_("Optimize"),		/* 20 */
-	N_("Clear flag"),	/* 21 */
-	"",			/* 22 */
+	N_("(no prompt)"),			/* PROMPT_NONE		=  0 */
+	N_("Fix"),				/* PROMPT_FIX		=  1 */
+	N_("Clear"),				/* PROMPT_CLEAR		=  2 */
+	N_("Relocate"),				/* PROMPT_RELOCATE	=  3 */
+	N_("Allocate"),				/* PROMPT_CREATE	=  4 */
+	N_("Expand"),				/* PROMPT_EXPAND	=  5 */
+	N_("Connect to /lost+found"),		/* PROMPT_CONNECT	=  6 */
+	N_("Create"),				/* PROMPT_CREATE	=  7 */
+	N_("Salvage"),				/* PROMPT_SALVAGE	=  8 */
+	N_("Truncate"),				/* PROMPT_TRUNCATE	=  9 */
+	N_("Clear inode"),			/* PROMPT_CLEAR_INODE	= 10 */
+	N_("Abort"),				/* PROMPT_ABORT		= 11 */
+	N_("Split"),				/* PROMPT_SPLIT		= 12 */
+	N_("Continue"),				/* PROMPT_CONTINUE	= 13 */
+	N_("Clone multiply-claimed blocks"),	/* PROMPT_CLONE		= 14 */
+	N_("Delete file"),			/* PROMPT_DELETE	= 15 */
+	N_("Suppress messages"),		/* PROMPT_SUPPRESS	= 16 */
+	N_("Unlink"),				/* PROMPT_UNLINK	= 17 */
+	N_("Clear HTree index"),		/* PROMPT_CLEAR_HTREE	= 18 */
+	N_("Recreate"),				/* PROMPT_RECREATE	= 19 */
+	N_("Optimize"),				/* PROMPT_OPTIMIZE	= 20 */
+	N_("Clear flag"),			/* PROMPT_CLEAR_FLAG	= 21 */
+	"",					/* PROMPT_NULL		= 22 */
 };
 
 /*

From 6b0e3bd7bd2f2db3c3993c5d91379ad55e60b51e Mon Sep 17 00:00:00 2001
From: Andreas Dilger <adilger@whamcloud.com>
Date: Sun, 12 Dec 2021 23:35:30 -0700
Subject: [PATCH 07/22] e2fsck: no parent lookup in disconnected dir

Don't call into ext2fs_get_pathname() to do a name lookup for a
disconnected directory, since the directory block traversal in
pass1 has already scanned all of the leaf blocks and never finds
the entry, always printing "???".  If the name entry had been
found earlier, the directory would not be disconnected in pass3.

Instead, lookup ".." and print the parent name in the prompt, and
then do not search for the current directory name at all.  This
avoids a useless full directory scan for each disconnected entry,
which can potentially be slow if the parent directory is large.

Separate the recursively looped directory case to a new error code,
since it is a different problem that should use its own descriptive
text, and a proper pathname can be shown in this case.

Lustre-bug-Id: https://jira.whamcloud.com/browse/LU-15330
Change-Id: If17a92689f24f365ca1fbe5c837e7d5f383ebbe5
Signed-off-by: Andreas Dilger <adilger@whamcloud.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 e2fsck/pass3.c                        |  19 ++++++++++++-------
 e2fsck/problem.c                      |   8 +++++++-
 e2fsck/problem.h                      |   3 +++
 tests/f_bad_encryption/expect.1       |   6 +++---
 tests/f_badroot/expect.1              |   2 +-
 tests/f_encrypted_lpf/expect.1        |   4 ++--
 tests/f_expand/expect.1.gz            | Bin 13462 -> 13461 bytes
 tests/f_lpf2/expect.1                 |   4 ++--
 tests/f_noroot/expect.1               |   4 ++--
 tests/f_orphan_dotdot_ft/expect.1     |   6 +++---
 tests/f_rebuild_csum_rootdir/expect.1 |   2 +-
 tests/f_recnect_bad/expect.1          |   2 +-
 tests/f_resize_inode_meta_bg/expect.1 |   2 +-
 13 files changed, 38 insertions(+), 24 deletions(-)

diff --git a/e2fsck/pass3.c b/e2fsck/pass3.c
index cedaaf5a5..d6b8c8b47 100644
--- a/e2fsck/pass3.c
+++ b/e2fsck/pass3.c
@@ -22,7 +22,7 @@
  * will offer to reconnect it to /lost+found.  While it is chasing
  * parent pointers up the filesystem tree, if pass3 sees a directory
  * twice, then it has detected a filesystem loop, and it will again
- * offer to reconnect the directory to /lost+found in to break the
+ * offer to reconnect the directory to /lost+found in order to break the
  * filesystem loop.
  *
  * Pass 3 also contains the subroutine, e2fsck_reconnect_file() to
@@ -304,7 +304,7 @@ static int check_directory(e2fsck_t ctx, ext2_ino_t dir,
 		 * If it was marked done already, then we've reached a
 		 * parent we've already checked.
 		 */
-	  	if (ext2fs_mark_inode_bitmap2(inode_done_map, ino))
+		if (ext2fs_mark_inode_bitmap2(inode_done_map, ino))
 			break;
 
 		if (e2fsck_dir_info_get_parent(ctx, ino, &parent)) {
@@ -319,13 +319,18 @@ static int check_directory(e2fsck_t ctx, ext2_ino_t dir,
 		 */
 		if (!parent ||
 		    (loop_pass &&
-		     (ext2fs_test_inode_bitmap2(inode_loop_detect,
-					       parent)))) {
+		     ext2fs_test_inode_bitmap2(inode_loop_detect, parent))) {
 			pctx->ino = ino;
-			if (fix_problem(ctx, PR_3_UNCONNECTED_DIR, pctx)) {
-				if (e2fsck_reconnect_file(ctx, pctx->ino))
+			if (parent)
+				pctx->dir = parent;
+			else
+				ext2fs_lookup(fs, ino, "..", 2, NULL,
+					      &pctx->dir);
+			if (fix_problem(ctx, !parent ? PR_3_UNCONNECTED_DIR :
+						       PR_3_LOOPED_DIR, pctx)) {
+				if (e2fsck_reconnect_file(ctx, pctx->ino)) {
 					ext2fs_unmark_valid(fs);
-				else {
+				} else {
 					fix_dotdot(ctx, pctx->ino,
 						   ctx->lost_and_found);
 					parent = ctx->lost_and_found;
diff --git a/e2fsck/problem.c b/e2fsck/problem.c
index 2d02468c8..46a74273e 100644
--- a/e2fsck/problem.c
+++ b/e2fsck/problem.c
@@ -1852,7 +1852,7 @@ static struct e2fsck_problem problem_table[] = {
 	/* Unconnected directory inode */
 	{ PR_3_UNCONNECTED_DIR,
 	  /* xgettext:no-c-format */
-	  N_("Unconnected @d @i %i (%p)\n"),
+	  N_("Unconnected @d @i %i (was in %q)\n"),
 	  PROMPT_CONNECT, 0, 0, 0, 0 },
 
 	/* /lost+found not found */
@@ -1989,6 +1989,12 @@ static struct e2fsck_problem problem_table[] = {
 	  N_("/@l is encrypted\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
+	/* Recursively looped directory inode */
+	{ PR_3_LOOPED_DIR,
+	  /* xgettext:no-c-format */
+	  N_("Recursively looped @d @i %i (%p)\n"),
+	  PROMPT_CONNECT, 0, 0, 0, 0 },
+
 	/* Pass 3A Directory Optimization	*/
 
 	/* Pass 3A: Optimizing directories */
diff --git a/e2fsck/problem.h b/e2fsck/problem.h
index 24cdcf9b9..e86bc889d 100644
--- a/e2fsck/problem.h
+++ b/e2fsck/problem.h
@@ -1132,6 +1132,9 @@ struct problem_context {
 /* Lost+found is encrypted */
 #define PR_3_LPF_ENCRYPTED		0x03001B
 
+/* Recursively looped directory inode */
+#define PR_3_LOOPED_DIR			0x03001D
+
 /*
  * Pass 3a --- rehashing directories
  */
diff --git a/tests/f_bad_encryption/expect.1 b/tests/f_bad_encryption/expect.1
index d743e66f7..702709596 100644
--- a/tests/f_bad_encryption/expect.1
+++ b/tests/f_bad_encryption/expect.1
@@ -54,13 +54,13 @@ Encrypted entry '\M-ggCeM-/?M-^BM-{(M-^OM-9M-^QQAM-^N=M-c^Mo' in /edir (12) refe
 Clear? yes
 
 Pass 3: Checking directory connectivity
-Unconnected directory inode 18 (/edir/???)
+Unconnected directory inode 18 (was in /edir)
 Connect to /lost+found? yes
 
-Unconnected directory inode 24 (/edir/???)
+Unconnected directory inode 24 (was in /edir)
 Connect to /lost+found? yes
 
-Unconnected directory inode 27 (/edir/???)
+Unconnected directory inode 27 (was in /edir)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_badroot/expect.1 b/tests/f_badroot/expect.1
index f9d01e570..ff9242689 100644
--- a/tests/f_badroot/expect.1
+++ b/tests/f_badroot/expect.1
@@ -9,7 +9,7 @@ Entry '..' in <2>/<11> (11) has deleted/unused inode 2.  Clear? yes
 Pass 3: Checking directory connectivity
 Root inode not allocated.  Allocate? yes
 
-Unconnected directory inode 11 (...)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes
diff --git a/tests/f_encrypted_lpf/expect.1 b/tests/f_encrypted_lpf/expect.1
index 7e215b7de..63ac5f3bf 100644
--- a/tests/f_encrypted_lpf/expect.1
+++ b/tests/f_encrypted_lpf/expect.1
@@ -1,7 +1,7 @@
 Pass 1: Checking inodes, blocks, and sizes
 Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
-Unconnected directory inode 12 (/???)
+Unconnected directory inode 12 (was in /)
 Connect to /lost+found? yes
 
 /lost+found is encrypted
@@ -13,7 +13,7 @@ Restarting e2fsck from the beginning...
 Pass 1: Checking inodes, blocks, and sizes
 Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
-Unconnected directory inode 11 (/???)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 Pass 3A: Optimizing directories
diff --git a/tests/f_expand/expect.1.gz b/tests/f_expand/expect.1.gz
index 1015e155ca93f1aea0edfad09be6e795c0ab1898..81fe7dd67f81dd64100b5fdfe2884fab129ab721 100644
GIT binary patch
literal 13461
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

literal 13462
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

diff --git a/tests/f_lpf2/expect.1 b/tests/f_lpf2/expect.1
index 633586cc6..ab5d9ba37 100644
--- a/tests/f_lpf2/expect.1
+++ b/tests/f_lpf2/expect.1
@@ -1,12 +1,12 @@
 Pass 1: Checking inodes, blocks, and sizes
 Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
-Unconnected directory inode 12 (/???)
+Unconnected directory inode 12 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes
 
-Unconnected directory inode 13 (/???)
+Unconnected directory inode 13 (was in /)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_noroot/expect.1 b/tests/f_noroot/expect.1
index 7bdd7cba9..f8f652ec0 100644
--- a/tests/f_noroot/expect.1
+++ b/tests/f_noroot/expect.1
@@ -11,12 +11,12 @@ Entry '..' in /foo (12) has deleted/unused inode 2.  Clear? yes
 Pass 3: Checking directory connectivity
 Root inode not allocated.  Allocate? yes
 
-Unconnected directory inode 11 (...)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes
 
-Unconnected directory inode 12 (...)
+Unconnected directory inode 12 (was in /lost+found)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_orphan_dotdot_ft/expect.1 b/tests/f_orphan_dotdot_ft/expect.1
index 6a1373f2a..609249584 100644
--- a/tests/f_orphan_dotdot_ft/expect.1
+++ b/tests/f_orphan_dotdot_ft/expect.1
@@ -17,13 +17,13 @@ Entry '..' in <12>/<15> (15) has an incorrect filetype (was 2, should be 6).
 Fix? yes
 
 Pass 3: Checking directory connectivity
-Unconnected directory inode 13 (<12>/<13>)
+Unconnected directory inode 13 (was in <12>)
 Connect to /lost+found? yes
 
-Unconnected directory inode 14 (<12>/<14>)
+Unconnected directory inode 14 (was in <12>)
 Connect to /lost+found? yes
 
-Unconnected directory inode 15 (<12>/<15>)
+Unconnected directory inode 15 (was in <12>)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_rebuild_csum_rootdir/expect.1 b/tests/f_rebuild_csum_rootdir/expect.1
index 91e6027df..063fb8cc3 100644
--- a/tests/f_rebuild_csum_rootdir/expect.1
+++ b/tests/f_rebuild_csum_rootdir/expect.1
@@ -13,7 +13,7 @@ Pass 3: Checking directory connectivity
 '..' in / (2) is <The NULL inode> (0), should be / (2).
 Fix? yes
 
-Unconnected directory inode 11 (/???)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes
diff --git a/tests/f_recnect_bad/expect.1 b/tests/f_recnect_bad/expect.1
index 97ffcc52b..685eedfee 100644
--- a/tests/f_recnect_bad/expect.1
+++ b/tests/f_recnect_bad/expect.1
@@ -12,7 +12,7 @@ i_faddr for inode 13 (/test/???) is 12, should be zero.
 Clear? yes
 
 Pass 3: Checking directory connectivity
-Unconnected directory inode 13 (/test/???)
+Unconnected directory inode 13 (was in /test)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_resize_inode_meta_bg/expect.1 b/tests/f_resize_inode_meta_bg/expect.1
index 769f71aea..e248083f8 100644
--- a/tests/f_resize_inode_meta_bg/expect.1
+++ b/tests/f_resize_inode_meta_bg/expect.1
@@ -45,7 +45,7 @@ Pass 3: Checking directory connectivity
 '..' in / (2) is <The NULL inode> (0), should be / (2).
 Fix? yes
 
-Unconnected directory inode 11 (/???)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes

From a26abc5a1e2fff9d679887445d313b4b9f946f64 Mon Sep 17 00:00:00 2001
From: zhanchengbin <zhanchengbin1@huawei.com>
Date: Fri, 31 Dec 2021 15:41:41 +0800
Subject: [PATCH 08/22] e2fsck: handle malloc() failure when computing the log
 file name

Link: https://lore.kernel.org/r/6d2844c7-0fd2-e432-3c7e-bb8de8c8a186@huawei.com
Signed-off-by: zhanchengbin <zhanchengbin1@huawei.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 e2fsck/logfile.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/e2fsck/logfile.c b/e2fsck/logfile.c
index 63e9a12f1..7bdeae190 100644
--- a/e2fsck/logfile.c
+++ b/e2fsck/logfile.c
@@ -32,7 +32,7 @@ static void alloc_string(struct string *s, int len)
 {
 	s->s = malloc(len);
 /* e2fsck_allocate_memory(ctx, len, "logfile name"); */
-	s->len = len;
+	s->len = s->s ? len : 0;
 	s->end = 0;
 }
 

From ba18f6efec62a1706b4bcf8fffd27611022260b8 Mon Sep 17 00:00:00 2001
From: zhanchengbin <zhanchengbin1@huawei.com>
Date: Fri, 31 Dec 2021 15:42:40 +0800
Subject: [PATCH 09/22] dumpe2fs, resize2fs: avoid memory leak on error path

Link: https://lore.kernel.org/r/cbfd9852-bc89-1e83-f101-36fd29a0e70e@huawei.com
Signed-off-by: zhanchengbin <zhanchengbin1@huawei.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 misc/dumpe2fs.c    | 1 +
 resize/resize2fs.c | 4 ++--
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/misc/dumpe2fs.c b/misc/dumpe2fs.c
index 3f4fc4ede..ef6d1cb82 100644
--- a/misc/dumpe2fs.c
+++ b/misc/dumpe2fs.c
@@ -338,6 +338,7 @@ static void list_bad_blocks(ext2_filsys fs, int dump)
 	if (retval) {
 		com_err("ext2fs_badblocks_list_iterate_begin", retval,
 			"%s", _("while printing bad block list"));
+		ext2fs_badblocks_list_free(bb_list);
 		return;
 	}
 	if (dump) {
diff --git a/resize/resize2fs.c b/resize/resize2fs.c
index d69cb01ed..916b1f4b4 100644
--- a/resize/resize2fs.c
+++ b/resize/resize2fs.c
@@ -1781,11 +1781,11 @@ static errcode_t block_mover(ext2_resize_t rfs)
 					fs->inode_blocks_per_group,
 					&rfs->itable_buf);
 		if (retval)
-			return retval;
+			goto errout;
 	}
 	retval = ext2fs_create_extent_table(&rfs->bmap, 0);
 	if (retval)
-		return retval;
+		goto errout;
 
 	/*
 	 * The first step is to figure out where all of the blocks

From fdec633fd661e79b7b81e848b5699775328d70ae Mon Sep 17 00:00:00 2001
From: zhanchengbin <zhanchengbin1@huawei.com>
Date: Fri, 31 Dec 2021 15:43:10 +0800
Subject: [PATCH 10/22] e2fsck: avoid theoretical null dereference in
 end_problem_latch()

This should only happen if there is a programming bug, but better safe
than sorry.

Link: https://lore.kernel.org/r/9a9c6658-a8b3-794a-85df-c3bdf0470111@huawei.com
Signed-off-by: zhanchengbin <zhanchengbin1@huawei.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 e2fsck/problem.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/e2fsck/problem.c b/e2fsck/problem.c
index 46a74273e..95f0ace88 100644
--- a/e2fsck/problem.c
+++ b/e2fsck/problem.c
@@ -2321,6 +2321,8 @@ int end_problem_latch(e2fsck_t ctx, int mask)
 	int answer = -1;
 
 	ldesc = find_latch(mask);
+	if (!ldesc)
+		return answer;
 	if (ldesc->end_message && (ldesc->flags & PRL_LATCHED)) {
 		clear_problem_context(&pctx);
 		answer = fix_problem(ctx, ldesc->end_message, &pctx);
@@ -2467,8 +2469,8 @@ int fix_problem(e2fsck_t ctx, problem_t code, struct problem_context *pctx)
 	 * Do special latch processing.  This is where we ask the
 	 * latch question, if it exists
 	 */
-	if (ptr->flags & PR_LATCH_MASK) {
-		ldesc = find_latch(ptr->flags & PR_LATCH_MASK);
+	if (ptr->flags & PR_LATCH_MASK &&
+	    (ldesc = find_latch(ptr->flags & PR_LATCH_MASK)) != NULL) {
 		if (ldesc->question && !(ldesc->flags & PRL_LATCHED)) {
 			ans = fix_problem(ctx, ldesc->question, pctx);
 			if (ans == 1)

From 1c966c9dffef7e823a020a2f3982e9b9b1953e8b Mon Sep 17 00:00:00 2001
From: zhanchengbin <zhanchengbin1@huawei.com>
Date: Fri, 31 Dec 2021 15:43:36 +0800
Subject: [PATCH 11/22] libext2fs: fix memory leak in error path while opening
 test_io manager

Link: https://lore.kernel.org/r/d0632bbc-9713-38a9-c914-137b702f6ae1@huawei.com
Signed-off-by: zhanchengbin <zhanchengbin1@huawei.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 lib/ext2fs/test_io.c | 2 ++
 lib/ext2fs/undo_io.c | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/lib/ext2fs/test_io.c b/lib/ext2fs/test_io.c
index 480e68fcc..6843edbcf 100644
--- a/lib/ext2fs/test_io.c
+++ b/lib/ext2fs/test_io.c
@@ -248,6 +248,8 @@ static errcode_t test_open(const char *name, int flags, io_channel *channel)
 	return 0;
 
 cleanup:
+	if (io && io->name)
+		ext2fs_free_mem(&io->name);
 	if (io)
 		ext2fs_free_mem(&io);
 	if (data)
diff --git a/lib/ext2fs/undo_io.c b/lib/ext2fs/undo_io.c
index eb56f53d5..f4a6d5267 100644
--- a/lib/ext2fs/undo_io.c
+++ b/lib/ext2fs/undo_io.c
@@ -790,6 +790,8 @@ static errcode_t undo_open(const char *name, int flags, io_channel *channel)
 		io_channel_close(data->real);
 	if (data)
 		ext2fs_free_mem(&data);
+	if (io && io->name)
+		ext2fs_free_mem(&io->name);
 	if (io)
 		ext2fs_free_mem(&io);
 	return retval;

From ed54397b414def44d8ef11b4e320d9809d5fa294 Mon Sep 17 00:00:00 2001
From: zhanchengbin <zhanchengbin1@huawei.com>
Date: Fri, 31 Dec 2021 15:42:17 +0800
Subject: [PATCH 12/22] libsupport: avoid possible null dereference in
 quota_set_sb_inum()

If the quota type is invalid, quota_sb_inump will return NULL; this
should not cause the program to crash.

Link: https://lore.kernel.org/r/ee0b034c-71f3-63b7-a8de-d8e7760b9545@huawei.com
Signed-off-by: zhanchengbin <zhanchengbin1@huawei.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 lib/support/mkquota.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/lib/support/mkquota.c b/lib/support/mkquota.c
index 5de7c48d6..c89f89590 100644
--- a/lib/support/mkquota.c
+++ b/lib/support/mkquota.c
@@ -99,6 +99,8 @@ void quota_set_sb_inum(ext2_filsys fs, ext2_ino_t ino, enum quota_type qtype)
 
 	log_debug("setting quota ino in superblock: ino=%u, type=%d", ino,
 		 qtype);
+	if (inump == NULL)
+		return;
 	*inump = ino;
 	ext2fs_mark_super_dirty(fs);
 }

From 40196f3b493a55728f8f3a6591d52867ef613e3c Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Mon, 30 May 2022 19:17:30 -0400
Subject: [PATCH 13/22] e2fsck: sanity check the journal inode number
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

E2fsck replays the journal before sanity checking the full superblock.
So it's possible that the journal inode number is not valid relative
to the number of block groups.  So to avoid potentially an array
bounds overrun, sanity check this before trying to find the journal
inode.

Reported-by: Nils Bars <nils.bars@rub.de>
Reported-by: Moritz Schlögel <moritz.schloegel@rub.de>
Reported-by: Nico Schiller <nico.schiller@rub.de>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 e2fsck/journal.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/e2fsck/journal.c b/e2fsck/journal.c
index 2e867234b..12487e3d8 100644
--- a/e2fsck/journal.c
+++ b/e2fsck/journal.c
@@ -989,7 +989,14 @@ static errcode_t e2fsck_get_journal(e2fsck_t ctx, journal_t **ret_journal)
 	journal->j_blocksize = ctx->fs->blocksize;
 
 	if (uuid_is_null(sb->s_journal_uuid)) {
-		if (!sb->s_journal_inum) {
+		/*
+		 * The full set of superblock sanity checks haven't
+		 * been performed yet, so we need to do some basic
+		 * checks here to avoid potential array overruns.
+		 */
+		if (!sb->s_journal_inum ||
+		    (sb->s_journal_inum >
+		     (ctx->fs->group_desc_count * sb->s_inodes_per_group))) {
 			retval = EXT2_ET_BAD_INODE_NUM;
 			goto errout;
 		}

From 1052048fb8f4ddcc0160eb670ef746ef7ee505a4 Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Mon, 6 Jun 2022 11:39:23 -0400
Subject: [PATCH 14/22] e2fsck: fix potential out-of-bounds read in
 inc_ea_inode_refs()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If there isn't enough space for a full extended attribute entry,
inc_ea_inode_refs() might end up reading beyond the allocated memory
buffer.

Reported-by: Nils Bars <nils.bars@rub.de>
Reported-by: Moritz Schlögel <moritz.schloegel@rub.de>
Reported-by: Nico Schiller <nico.schiller@rub.de>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 e2fsck/pass1.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/e2fsck/pass1.c b/e2fsck/pass1.c
index dde862a82..2a17bb8ae 100644
--- a/e2fsck/pass1.c
+++ b/e2fsck/pass1.c
@@ -389,13 +389,13 @@ static problem_t check_large_ea_inode(e2fsck_t ctx,
 static void inc_ea_inode_refs(e2fsck_t ctx, struct problem_context *pctx,
 			      struct ext2_ext_attr_entry *first, void *end)
 {
-	struct ext2_ext_attr_entry *entry;
+	struct ext2_ext_attr_entry *entry = first;
+	struct ext2_ext_attr_entry *np = EXT2_EXT_ATTR_NEXT(entry);
 
-	for (entry = first;
-	     (void *)entry < end && !EXT2_EXT_IS_LAST_ENTRY(entry);
-	     entry = EXT2_EXT_ATTR_NEXT(entry)) {
+	while ((void *) entry < end && (void *) np < end &&
+	       !EXT2_EXT_IS_LAST_ENTRY(entry)) {
 		if (!entry->e_value_inum)
-			continue;
+			goto next;
 		if (!ctx->ea_inode_refs) {
 			pctx->errcode = ea_refcount_create(0,
 							   &ctx->ea_inode_refs);
@@ -408,6 +408,9 @@ static void inc_ea_inode_refs(e2fsck_t ctx, struct problem_context *pctx,
 		}
 		ea_refcount_increment(ctx->ea_inode_refs, entry->e_value_inum,
 				      0);
+	next:
+		entry = np;
+		np = EXT2_EXT_ATTR_NEXT(entry);
 	}
 }
 

From d497224dfbfdc1313136488cd7fb196885d40dfb Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Mon, 6 Jun 2022 12:03:36 -0400
Subject: [PATCH 15/22] libext2fs: add check for too-short directory blocks
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If there is an inline data directory which is smaller than 8 bytes
(which should never happen but for corrupted or fuzzed file systems),
ext2fs_process_dir_block() will now abort EXT2_ET_DIR_CORRUPTED to
avoid an out-of-bounds read.

Reported-by: Nils Bars <nils.bars@rub.de>
Reported-by: Moritz Schlögel <moritz.schloegel@rub.de>
Reported-by: Nico Schiller <nico.schiller@rub.de>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 lib/ext2fs/dir_iterate.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/lib/ext2fs/dir_iterate.c b/lib/ext2fs/dir_iterate.c
index b2b77693e..7798a4827 100644
--- a/lib/ext2fs/dir_iterate.c
+++ b/lib/ext2fs/dir_iterate.c
@@ -221,6 +221,10 @@ int ext2fs_process_dir_block(ext2_filsys fs,
 	if (ext2fs_has_feature_metadata_csum(fs->super))
 		csum_size = sizeof(struct ext2_dir_entry_tail);
 
+	if (buflen < 8) {
+		ctx->errcode = EXT2_ET_DIR_CORRUPTED;
+		return BLOCK_ABORT;
+	}
 	while (offset < buflen - 8) {
 		dirent = (struct ext2_dir_entry *) (ctx->buf + offset);
 		if (ext2fs_get_rec_len(fs, dirent, &rec_len))

From f0c405f8b7bdabaf07284f1b52ba42b551152229 Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Mon, 6 Jun 2022 13:34:08 -0400
Subject: [PATCH 16/22] e2fsck: check for xattr value size integer wraparound
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When checking an extended attrbiute block for correctness, we check if
the starting offset plus the value size exceeds the end of the block.
However, we weren't checking if the size was too large, and if it is
so large that it triggers a wraparound when we added the starting
offset, we won't notice the problem.  Add the missing check.

Reported-by: Nils Bars <nils.bars@rub.de>
Reported-by: Moritz Schlögel <moritz.schloegel@rub.de>
Reported-by: Nico Schiller <nico.schiller@rub.de>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 e2fsck/pass1.c             |  5 +++--
 lib/ext2fs/ext2_ext_attr.h | 11 +++++++++++
 2 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/e2fsck/pass1.c b/e2fsck/pass1.c
index 2a17bb8ae..11d7ce93c 100644
--- a/e2fsck/pass1.c
+++ b/e2fsck/pass1.c
@@ -2556,8 +2556,9 @@ static int check_ext_attr(e2fsck_t ctx, struct problem_context *pctx,
 			break;
 		}
 		if (entry->e_value_inum == 0) {
-			if (entry->e_value_offs + entry->e_value_size >
-			    fs->blocksize) {
+			if (entry->e_value_size > EXT2_XATTR_SIZE_MAX ||
+			    (entry->e_value_offs + entry->e_value_size >
+			     fs->blocksize)) {
 				if (fix_problem(ctx, PR_1_EA_BAD_VALUE, pctx))
 					goto clear_extattr;
 				break;
diff --git a/lib/ext2fs/ext2_ext_attr.h b/lib/ext2fs/ext2_ext_attr.h
index f2042ed56..c6068c482 100644
--- a/lib/ext2fs/ext2_ext_attr.h
+++ b/lib/ext2fs/ext2_ext_attr.h
@@ -57,6 +57,17 @@ struct ext2_ext_attr_entry {
 #define EXT2_XATTR_SIZE(size) \
 	(((size) + EXT2_EXT_ATTR_ROUND) & ~EXT2_EXT_ATTR_ROUND)
 
+/*
+ * XATTR_SIZE_MAX is currently 64k, but for the purposes of checking
+ * for file system consistency errors, we use a somewhat bigger value.
+ * This allows XATTR_SIZE_MAX to grow in the future, but by using this
+ * instead of INT_MAX for certain consistency checks, we don't need to
+ * worry about arithmetic overflows.  (Actually XATTR_SIZE_MAX is
+ * defined in include/uapi/linux/limits.h, so changing it is going
+ * not going to be trivial....)
+ */
+#define EXT2_XATTR_SIZE_MAX (1 << 24)
+
 #ifdef __KERNEL__
 # ifdef CONFIG_EXT2_FS_EXT_ATTR
 extern int ext2_get_ext_attr(struct inode *, const char *, char *, size_t, int);

From 8d66e7e9316002ca9f9d558069bd56ccba9cece8 Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Mon, 6 Jun 2022 22:44:35 -0400
Subject: [PATCH 17/22] e2fsck: avoid out-of-bounds write for very deep extent
 trees
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The kernel doesn't support extent trees deeper than 5
(EXT4_MAX_EXTENT_DEPTH).  For this reason we only maintain the extent
tree statistics for 5 levels.  Avoid out-of-bounds writes and reads if
the extent tree is deeper than this.

We keep these statistics to determine whether we should rebuild the
extent tree.  If the extent tree is too deep, we don't need the
statistics because we should always rebuild the it.

Reported-by: Nils Bars <nils.bars@rub.de>
Reported-by: Moritz Schlögel <moritz.schloegel@rub.de>
Reported-by: Nico Schiller <nico.schiller@rub.de>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 e2fsck/extents.c | 10 +++++++++-
 e2fsck/pass1.c   |  3 ++-
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/e2fsck/extents.c b/e2fsck/extents.c
index 01879f56e..86fe00e79 100644
--- a/e2fsck/extents.c
+++ b/e2fsck/extents.c
@@ -526,7 +526,8 @@ errcode_t e2fsck_check_rebuild_extents(e2fsck_t ctx, ext2_ino_t ino,
 		 */
 		if (info.curr_entry == 1 &&
 		    !(extent.e_flags & EXT2_EXTENT_FLAGS_SECOND_VISIT) &&
-		    !eti.force_rebuild) {
+		    !eti.force_rebuild &&
+		    info.curr_level < MAX_EXTENT_DEPTH_COUNT) {
 			struct extent_tree_level *etl;
 
 			etl = eti.ext_info + info.curr_level;
@@ -580,6 +581,13 @@ errcode_t e2fsck_should_rebuild_extents(e2fsck_t ctx,
 	extents_per_block = (ctx->fs->blocksize -
 			     sizeof(struct ext3_extent_header)) /
 			    sizeof(struct ext3_extent);
+
+	/* If the extent tree is too deep, then rebuild it. */
+	if (info->max_depth > MAX_EXTENT_DEPTH_COUNT) {
+		pctx->blk = info->max_depth;
+		op = PR_1E_CAN_COLLAPSE_EXTENT_TREE;
+		goto rebuild;
+	}
 	/*
 	 * If we can consolidate a level or shorten the tree, schedule the
 	 * extent tree to be rebuilt.
diff --git a/e2fsck/pass1.c b/e2fsck/pass1.c
index 11d7ce93c..43972e7c6 100644
--- a/e2fsck/pass1.c
+++ b/e2fsck/pass1.c
@@ -2842,7 +2842,8 @@ static void scan_extent_node(e2fsck_t ctx, struct problem_context *pctx,
 	if (pctx->errcode)
 		return;
 	if (!(ctx->options & E2F_OPT_FIXES_ONLY) &&
-	    !pb->eti.force_rebuild) {
+	    !pb->eti.force_rebuild &&
+	    info.curr_level < MAX_EXTENT_DEPTH_COUNT) {
 		struct extent_tree_level *etl;
 
 		etl = pb->eti.ext_info + info.curr_level;

From 2d30ab20ae4eda6660ead5c79367e91e85322233 Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Mon, 6 Jun 2022 22:49:47 -0400
Subject: [PATCH 18/22] libext2fs: check for cyclic loops in the extent tree
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

In the extent tree handling code in libext2fs, when we go move down
the extent tree, if a cyclic loop is detected, return an error.

Reported-by: Nils Bars <nils.bars@rub.de>
Reported-by: Moritz Schlögel <moritz.schloegel@rub.de>
Reported-by: Nico Schiller <nico.schiller@rub.de>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 lib/ext2fs/ext2_err.et.in |  3 +++
 lib/ext2fs/extent.c       | 11 +++++++++--
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/lib/ext2fs/ext2_err.et.in b/lib/ext2fs/ext2_err.et.in
index cf0e00ea3..bb1dcf149 100644
--- a/lib/ext2fs/ext2_err.et.in
+++ b/lib/ext2fs/ext2_err.et.in
@@ -551,4 +551,7 @@ ec	EXT2_ET_NO_GDESC,
 ec	EXT2_FILSYS_CORRUPTED,
 	"The internal ext2_filsys data structure appears to be corrupted"
 
+ec	EXT2_ET_EXTENT_CYCLE,
+	"Found cyclic loop in extent tree"
+
 	end
diff --git a/lib/ext2fs/extent.c b/lib/ext2fs/extent.c
index 1a206a16c..82e75ccd7 100644
--- a/lib/ext2fs/extent.c
+++ b/lib/ext2fs/extent.c
@@ -47,6 +47,7 @@ struct extent_path {
 	int		visit_num;
 	int		flags;
 	blk64_t		end_blk;
+	blk64_t		blk;
 	void		*curr;
 };
 
@@ -286,6 +287,7 @@ errcode_t ext2fs_extent_open2(ext2_filsys fs, ext2_ino_t ino,
 	handle->path[0].end_blk =
 		(EXT2_I_SIZE(handle->inode) + fs->blocksize - 1) >>
 		 EXT2_BLOCK_SIZE_BITS(fs->super);
+	handle->path[0].blk = 0;
 	handle->path[0].visit_num = 1;
 	handle->level = 0;
 	handle->magic = EXT2_ET_MAGIC_EXTENT_HANDLE;
@@ -305,14 +307,14 @@ errcode_t ext2fs_extent_open2(ext2_filsys fs, ext2_ino_t ino,
 errcode_t ext2fs_extent_get(ext2_extent_handle_t handle,
 			    int flags, struct ext2fs_extent *extent)
 {
-	struct extent_path	*path, *newpath;
+	struct extent_path	*path, *newpath, *tp;
 	struct ext3_extent_header	*eh;
 	struct ext3_extent_idx		*ix = 0;
 	struct ext3_extent		*ex;
 	errcode_t			retval;
 	blk64_t				blk;
 	blk64_t				end_blk;
-	int				orig_op, op;
+	int				orig_op, op, l;
 	int				failed_csum = 0;
 
 	EXT2_CHECK_MAGIC(handle, EXT2_ET_MAGIC_EXTENT_HANDLE);
@@ -467,6 +469,11 @@ errcode_t ext2fs_extent_get(ext2_extent_handle_t handle,
 		}
 		blk = ext2fs_le32_to_cpu(ix->ei_leaf) +
 			((__u64) ext2fs_le16_to_cpu(ix->ei_leaf_hi) << 32);
+		for (l = handle->level, tp = path; l > 0; l--, tp--) {
+			if (blk == tp->blk)
+				return EXT2_ET_EXTENT_CYCLE;
+		}
+		newpath->blk = blk;
 		if ((handle->fs->flags & EXT2_FLAG_IMAGE_FILE) &&
 		    (handle->fs->io != handle->fs->image_io))
 			memset(newpath->buf, 0, handle->fs->blocksize);

From 6772d4969e9c90460945bbf02b87c227b93a9832 Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Mon, 6 Jun 2022 23:48:37 -0400
Subject: [PATCH 19/22] libext2fs: check for invalid blocks in
 ext2fs_punch_blocks()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If the extent tree has out-of-range physical block numbers, don't try
to release them.

Also add a similar check in ext2fs_block_alloc_stats2() to avoid a
NULL pointer dereference.

Reported-by: Nils Bars <nils.bars@rub.de>
Reported-by: Moritz Schlögel <moritz.schloegel@rub.de>
Reported-by: Nico Schiller <nico.schiller@rub.de>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 lib/ext2fs/alloc_stats.c | 3 ++-
 lib/ext2fs/punch.c       | 4 ++++
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/lib/ext2fs/alloc_stats.c b/lib/ext2fs/alloc_stats.c
index 3949f618c..6f98bcc7c 100644
--- a/lib/ext2fs/alloc_stats.c
+++ b/lib/ext2fs/alloc_stats.c
@@ -62,7 +62,8 @@ void ext2fs_block_alloc_stats2(ext2_filsys fs, blk64_t blk, int inuse)
 {
 	int	group = ext2fs_group_of_blk2(fs, blk);
 
-	if (blk >= ext2fs_blocks_count(fs->super)) {
+	if (blk < fs->super->s_first_data_block ||
+	    blk >= ext2fs_blocks_count(fs->super)) {
 #ifndef OMIT_COM_ERR
 		com_err("ext2fs_block_alloc_stats", 0,
 			"Illegal block number: %lu", (unsigned long) blk);
diff --git a/lib/ext2fs/punch.c b/lib/ext2fs/punch.c
index effa1e2d6..e2543e1e7 100644
--- a/lib/ext2fs/punch.c
+++ b/lib/ext2fs/punch.c
@@ -200,6 +200,10 @@ static errcode_t punch_extent_blocks(ext2_filsys fs, ext2_ino_t ino,
 	__u32		cluster_freed;
 	errcode_t	retval = 0;
 
+	if (free_start < fs->super->s_first_data_block ||
+	    (free_start + free_count) >= ext2fs_blocks_count(fs->super))
+		return EXT2_ET_BAD_BLOCK_NUM;
+
 	/* No bigalloc?  Just free each block. */
 	if (EXT2FS_CLUSTER_RATIO(fs) == 1) {
 		*freed += free_count;

From 0288b1fd6909e92e3668dde8f1f6401fdabd1494 Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Thu, 4 Aug 2022 15:18:15 -0400
Subject: [PATCH 20/22] resize2fs: fix to respect the environment variable
 E2FSPROGS_FAKE_TIME

When performing an off-line resize, if an inode's block map needs to
be updated, resize2fs will update the inode's ctime.  In addition, if
inode numbers need to be renumbered due to the file system shrinking
forcing the inode table to be shrunk, any directories which need to be
modified will have their ctime and mtime updated.

If the E2FSPROGS_FAkE_TIME environment variable is set, when the file
system is opened, fs->now will be set to this value, and resize2fs
needs to use it instead of calling time(0) to get their current time.

Addresses-Google-Bug: 230874381
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 resize/resize2fs.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/resize/resize2fs.c b/resize/resize2fs.c
index 916b1f4b4..cfc81fc78 100644
--- a/resize/resize2fs.c
+++ b/resize/resize2fs.c
@@ -2266,7 +2266,8 @@ static errcode_t inode_scan_and_fix(ext2_resize_t rfs)
 		if (inode->i_flags & EXT4_EA_INODE_FL)
 			update_ea_inode_refs = 1;
 		else
-			inode->i_ctime = time(0);
+			inode->i_ctime = rfs->old_fs->now ?
+				rfs->old_fs->now : time(0);
 
 		retval = ext2fs_write_inode_full(rfs->old_fs, new_inode,
 						inode, inode_size);
@@ -2419,7 +2420,8 @@ static int check_and_change_inodes(ext2_ino_t dir,
 	/* Update the directory mtime and ctime */
 	retval = ext2fs_read_inode(is->rfs->old_fs, dir, &inode);
 	if (retval == 0) {
-		inode.i_mtime = inode.i_ctime = time(0);
+		inode.i_mtime = inode.i_ctime = is->rfs->old_fs->now ?
+			is->rfs->old_fs->now : time(0);
 		is->err = ext2fs_write_inode(is->rfs->old_fs, dir, &inode);
 		if (is->err)
 			return ret | DIRENT_ABORT;

From 2a2b9ceb99c226952a96abbcfb95b2540f8b7ecd Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Sat, 6 Aug 2022 01:37:20 -0400
Subject: [PATCH 21/22] libext2fs: teach ext2fs_open() to reject file systems
 with an invalid cluster size

If the cluster size is smaller than the block size, this can result in
a negative shift, which is undefined.  When such a file system is
opened, immediately return an error indicating that the file system is
corrupted.

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 lib/ext2fs/openfs.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/lib/ext2fs/openfs.c b/lib/ext2fs/openfs.c
index 5ec8ed5c1..05839ad68 100644
--- a/lib/ext2fs/openfs.c
+++ b/lib/ext2fs/openfs.c
@@ -295,8 +295,11 @@ errcode_t ext2fs_open2(const char *name, const char *io_options,
 		}
 	}
 
-	if (fs->super->s_log_block_size >
-	    (unsigned) (EXT2_MAX_BLOCK_LOG_SIZE - EXT2_MIN_BLOCK_LOG_SIZE)) {
+	if ((fs->super->s_log_block_size >
+	     (unsigned) (EXT2_MAX_BLOCK_LOG_SIZE - EXT2_MIN_BLOCK_LOG_SIZE)) ||
+	    (fs->super->s_log_cluster_size >
+	     (unsigned) (EXT2_MAX_CLUSTER_LOG_SIZE - EXT2_MIN_CLUSTER_LOG_SIZE)) ||
+	    (fs->super->s_log_block_size > fs->super->s_log_cluster_size)) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}

From 80e1504f2ce33c9ebc5045009c7bcde9315526c0 Mon Sep 17 00:00:00 2001
From: Theodore Ts'o <tytso@mit.edu>
Date: Sat, 6 Aug 2022 02:21:49 -0400
Subject: [PATCH 22/22] libext2fs: teach ext2fs_open() to reject file systems
 with an invalid flex_bg size

If s_log_groups_per_flex is greater than 31, it will result in an
UBSAN error, since it will result in an invalid shift exponent when
calculating the flex_bg size.  So reject such file systems when they
are opened.  (The mke2fs program will not allow the creation of such
file systems, so they can only occur due to corruption.)

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 lib/ext2fs/openfs.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/lib/ext2fs/openfs.c b/lib/ext2fs/openfs.c
index 05839ad68..bda8274fb 100644
--- a/lib/ext2fs/openfs.c
+++ b/lib/ext2fs/openfs.c
@@ -299,7 +299,8 @@ errcode_t ext2fs_open2(const char *name, const char *io_options,
 	     (unsigned) (EXT2_MAX_BLOCK_LOG_SIZE - EXT2_MIN_BLOCK_LOG_SIZE)) ||
 	    (fs->super->s_log_cluster_size >
 	     (unsigned) (EXT2_MAX_CLUSTER_LOG_SIZE - EXT2_MIN_CLUSTER_LOG_SIZE)) ||
-	    (fs->super->s_log_block_size > fs->super->s_log_cluster_size)) {
+	    (fs->super->s_log_block_size > fs->super->s_log_cluster_size) ||
+	    (fs->super->s_log_groups_per_flex > 31)) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}
