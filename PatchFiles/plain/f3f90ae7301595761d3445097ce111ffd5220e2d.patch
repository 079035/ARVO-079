From f3f90ae7301595761d3445097ce111ffd5220e2d Mon Sep 17 00:00:00 2001
From: Jan <31709392+cuellius@users.noreply.github.com>
Date: Fri, 7 Oct 2022 17:34:20 +0300
Subject: [PATCH] Code modernization

(cherry picked from commit 46b3ad0a710f3210b6a1d7de15ca51182e4ccd13)
---
 src/hunspell/affentry.cxx   |  14 +-
 src/hunspell/affentry.hxx   |   6 +-
 src/hunspell/affixmgr.cxx   | 272 +++++++++++++++---------------------
 src/hunspell/affixmgr.hxx   |   2 +-
 src/hunspell/baseaffix.hxx  |   6 +-
 src/hunspell/csutil.cxx     |  94 ++++++-------
 src/hunspell/csutil.hxx     |  14 +-
 src/hunspell/filemgr.cxx    |   6 +-
 src/hunspell/filemgr.hxx    |   8 +-
 src/hunspell/hashmgr.cxx    | 130 +++++++++--------
 src/hunspell/hashmgr.hxx    |   2 +-
 src/hunspell/hunspell.cxx   | 188 ++++++++++++-------------
 src/hunspell/hunspell.hxx   |   6 +-
 src/hunspell/hunzip.cxx     |   9 +-
 src/hunspell/hunzip.hxx     |   8 +-
 src/hunspell/phonet.cxx     |  17 +--
 src/hunspell/replist.cxx    |  14 +-
 src/hunspell/replist.hxx    |   6 +-
 src/hunspell/suggestmgr.cxx | 223 ++++++++++++-----------------
 src/hunspell/suggestmgr.hxx |   6 +-
 20 files changed, 446 insertions(+), 585 deletions(-)

diff --git a/src/hunspell/affentry.cxx b/src/hunspell/affentry.cxx
index bfd6cf5bd..46e8b5826 100644
--- a/src/hunspell/affentry.cxx
+++ b/src/hunspell/affentry.cxx
@@ -68,10 +68,10 @@
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
 
 #include "affentry.hxx"
 #include "csutil.hxx"
@@ -99,7 +99,7 @@ std::string PfxEntry::add(const char* word, size_t len) {
   std::string result;
   if ((len > strip.size() || (len == 0 && pmyMgr->get_fullstrip())) &&
       (len >= numconds) && test_condition(word) &&
-      (!strip.size() ||
+      (strip.empty() ||
       (len >= strip.size() && strncmp(word, strip.c_str(), strip.size()) == 0))) {
     /* we have a match so add prefix */
     result.assign(appnd);
@@ -469,7 +469,7 @@ std::string SfxEntry::add(const char* word, size_t len) {
   /* make sure all conditions match */
   if ((len > strip.size() || (len == 0 && pmyMgr->get_fullstrip())) &&
       (len >= numconds) && test_condition(word + len, word) &&
-      (!strip.size() ||
+      (strip.empty() ||
        (len >= strip.size() && strcmp(word + len - strip.size(), strip.c_str()) == 0))) {
     result.assign(word, len);
     /* we have a match so add suffix */
@@ -649,7 +649,7 @@ struct hentry* SfxEntry::checkword(const std::string& word,
     // or null terminating the shorter string
 
     std::string tmpstring(word, start, tmpl);
-    if (strip.size()) {
+    if (!strip.empty()) {
       tmpstring.append(strip);
     }
 
diff --git a/src/hunspell/affentry.hxx b/src/hunspell/affentry.hxx
index 8d35a83b1..01002f870 100644
--- a/src/hunspell/affentry.hxx
+++ b/src/hunspell/affentry.hxx
@@ -78,10 +78,6 @@
 /* A Prefix Entry  */
 
 class PfxEntry : public AffEntry {
- private:
-  PfxEntry(const PfxEntry&);
-  PfxEntry& operator=(const PfxEntry&);
-
  private:
   AffixMgr* pmyMgr;
 
@@ -92,6 +88,8 @@ class PfxEntry : public AffEntry {
 
  public:
   explicit PfxEntry(AffixMgr* pmgr);
+  PfxEntry(const PfxEntry&) = delete;
+  PfxEntry& operator=(const PfxEntry&) = delete;
 
   bool allowCross() const { return ((opts & aeXPRODUCT) != 0); }
   struct hentry* checkword(const std::string& word,
diff --git a/src/hunspell/affixmgr.cxx b/src/hunspell/affixmgr.cxx
index e6576d601..3be09977a 100644
--- a/src/hunspell/affixmgr.cxx
+++ b/src/hunspell/affixmgr.cxx
@@ -68,11 +68,11 @@
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
-#include <time.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
+#include <ctime>
 
 #include <algorithm>
 #include <memory>
@@ -164,9 +164,7 @@ AffixMgr::AffixMgr(const char* affpath,
     sFlag[i] = NULL;
   }
 
-  for (int j = 0; j < CONTSIZE; j++) {
-    contclasses[j] = 0;
-  }
+  memset(contclasses, 0, CONTSIZE * sizeof(char));
 
   if (parse_file(affpath, key)) {
     HUNSPELL_WARNING(stderr, "Failure loading aff file %s\n", affpath);
@@ -185,9 +183,9 @@ AffixMgr::AffixMgr(const char* affpath,
 
   // default BREAK definition
   if (!parsedbreaktable) {
-    breaktable.push_back("-");
-    breaktable.push_back("^-");
-    breaktable.push_back("-$");
+    breaktable.emplace_back("-");
+    breaktable.emplace_back("^-");
+    breaktable.emplace_back("-$");
     parsedbreaktable = true;
   }
 
@@ -764,7 +762,7 @@ int AffixMgr::build_pfxtree(PfxEntry* pfxptr) {
 
   // get the right starting points
   const char* key = ep->getKey();
-  const unsigned char flg = (unsigned char)(ep->getFlag() & 0x00FF);
+  const auto flg = (unsigned char)(ep->getFlag() & 0x00FF);
 
   // first index by flag which must exist
   ptr = pFlag[flg];
@@ -828,7 +826,7 @@ int AffixMgr::build_sfxtree(SfxEntry* sfxptr) {
 
   /* get the right starting point */
   const char* key = ep->getKey();
-  const unsigned char flg = (unsigned char)(ep->getFlag() & 0x00FF);
+  const auto flg = (unsigned char)(ep->getFlag() & 0x00FF);
 
   // first index by flag which must exist
   ptr = sFlag[flg];
@@ -1028,8 +1026,7 @@ std::string& AffixMgr::debugflag(std::string& result, unsigned short flag) {
 int AffixMgr::condlen(const std::string& s) {
   int l = 0;
   bool group = false;
-  std::string::const_iterator st = s.begin();
-  std::string::const_iterator end = s.end();
+  auto st = s.begin(), end = s.end();
   while (st != end) {
     if (*st == '[') {
       group = true;
@@ -1283,15 +1280,15 @@ int AffixMgr::cpdrep_check(const std::string& in_word, int wl) {
 
   std::string word(in_word, 0, wl);
 
-  for (size_t i = 0; i < get_reptable().size(); ++i) {
+  for (const auto& i : get_reptable()) {
     // use only available mid patterns
-    if (!get_reptable()[i].outstrings[0].empty()) {
+    if (!i.outstrings[0].empty()) {
       size_t r = 0;
-      const size_t lenp = get_reptable()[i].pattern.size();
+      const size_t lenp = i.pattern.size();
       // search every occurence of the pattern in the word
-      while (word.find(get_reptable()[i].pattern, r) != std::string::npos) {
+      while (word.find(i.pattern, r) != std::string::npos) {
         std::string candidate(word);
-        candidate.replace(r, lenp, get_reptable()[i].outstrings[0]);
+        candidate.replace(r, lenp, i.outstrings[0]);
         if (candidate_check(candidate))
           return 1;
         ++r;  // search for the next letter
@@ -1327,21 +1324,21 @@ int AffixMgr::cpdpat_check(const char* word,
                            hentry* r1,
                            hentry* r2,
                            const char /*affixed*/) {
-  for (size_t i = 0; i < checkcpdtable.size(); ++i) {
+  for (auto& i : checkcpdtable) {
     size_t len;
-    if (isSubset(checkcpdtable[i].pattern2.c_str(), word + pos) &&
-        (!r1 || !checkcpdtable[i].cond ||
-         (r1->astr && TESTAFF(r1->astr, checkcpdtable[i].cond, r1->alen))) &&
-        (!r2 || !checkcpdtable[i].cond2 ||
-         (r2->astr && TESTAFF(r2->astr, checkcpdtable[i].cond2, r2->alen))) &&
+    if (isSubset(i.pattern2.c_str(), word + pos) &&
+        (!r1 || !i.cond ||
+         (r1->astr && TESTAFF(r1->astr, i.cond, r1->alen))) &&
+        (!r2 || !i.cond2 ||
+         (r2->astr && TESTAFF(r2->astr, i.cond2, r2->alen))) &&
         // zero length pattern => only TESTAFF
         // zero pattern (0/flag) => unmodified stem (zero affixes allowed)
-        (checkcpdtable[i].pattern.empty() ||
-         ((checkcpdtable[i].pattern[0] == '0' && r1->blen <= pos &&
+        (i.pattern.empty() ||
+         ((i.pattern[0] == '0' && r1->blen <= pos &&
            strncmp(word + pos - r1->blen, r1->word, r1->blen) == 0) ||
-          (checkcpdtable[i].pattern[0] != '0' &&
-           ((len = checkcpdtable[i].pattern.size()) != 0) && len <= pos &&
-           strncmp(word + pos - len, checkcpdtable[i].pattern.c_str(), len) == 0)))) {
+          (i.pattern[0] != '0' &&
+           ((len = i.pattern.size()) != 0) && len <= pos &&
+           strncmp(word + pos - len, i.pattern.c_str(), len) == 0)))) {
       return 1;
     }
   }
@@ -1358,15 +1355,14 @@ int AffixMgr::cpdcase_check(const char* word, int pos) {
     std::string pair(p);
     std::vector<w_char> pair_u;
     u8_u16(pair_u, pair);
-    unsigned short a = pair_u.size() > 1 ? (unsigned short)pair_u[1] : 0;
-    unsigned short b = !pair_u.empty() ? (unsigned short)pair_u[0] : 0;
+    unsigned short a = pair_u.size() > 1 ? (unsigned short)pair_u[1] : 0,
+                   b = !pair_u.empty() ? (unsigned short)pair_u[0] : 0;
     if (((unicodetoupper(a, langnum) == a) ||
          (unicodetoupper(b, langnum) == b)) &&
         (a != '-') && (b != '-'))
       return 1;
   } else {
-    unsigned char a = *(word + pos - 1);
-    unsigned char b = *(word + pos);
+    const unsigned char a = *(word + pos - 1), b = *(word + pos);
     if ((csconv[a].ccase || csconv[b].ccase) && (a != '-') && (b != '-'))
       return 1;
   }
@@ -1410,10 +1406,10 @@ int AffixMgr::defcpd_check(hentry*** words,
     return 0;
   }
   int ok = 0;
-  for (size_t i = 0; i < defcpdtable.size(); ++i) {
-    for (size_t j = 0; j < defcpdtable[i].size(); ++j) {
-      if (defcpdtable[i][j] != '*' && defcpdtable[i][j] != '?' &&
-          TESTAFF(rv->astr, defcpdtable[i][j], rv->alen)) {
+  for (auto& i : defcpdtable) {
+    for (auto& j : i) {
+      if (j != '*' && j != '?' &&
+          TESTAFF(rv->astr, j, rv->alen)) {
         ok = 1;
         break;
       }
@@ -1426,18 +1422,17 @@ int AffixMgr::defcpd_check(hentry*** words,
     return 0;
   }
 
-  for (size_t i = 0; i < defcpdtable.size(); ++i) {
+  for (auto& i : defcpdtable) {
     size_t pp = 0;  // pattern position
     signed short wp = 0;  // "words" position
-    int ok2;
+    int ok2 = 1;
     ok = 1;
-    ok2 = 1;
     do {
-      while ((pp < defcpdtable[i].size()) && (wp <= wnum)) {
-        if (((pp + 1) < defcpdtable[i].size()) &&
-            ((defcpdtable[i][pp + 1] == '*') ||
-             (defcpdtable[i][pp + 1] == '?'))) {
-          int wend = (defcpdtable[i][pp + 1] == '?') ? wp : wnum;
+      while ((pp < i.size()) && (wp <= wnum)) {
+        if (((pp + 1) < i.size()) &&
+            ((i[pp + 1] == '*') ||
+             (i[pp + 1] == '?'))) {
+          int wend = (i[pp + 1] == '?') ? wp : wnum;
           ok2 = 1;
           pp += 2;
           btinfo[bt].btpp = pp;
@@ -1445,7 +1440,7 @@ int AffixMgr::defcpd_check(hentry*** words,
           while (wp <= wend) {
             if (!(*words)[wp] ||
                 !(*words)[wp]->alen ||
-                !TESTAFF((*words)[wp]->astr, defcpdtable[i][pp - 2],
+                !TESTAFF((*words)[wp]->astr, i[pp - 2],
                          (*words)[wp]->alen)) {
               ok2 = 0;
               break;
@@ -1464,24 +1459,24 @@ int AffixMgr::defcpd_check(hentry*** words,
         } else {
           ok2 = 1;
           if (!(*words)[wp] || !(*words)[wp]->alen ||
-              !TESTAFF((*words)[wp]->astr, defcpdtable[i][pp],
+              !TESTAFF((*words)[wp]->astr, i[pp],
                        (*words)[wp]->alen)) {
             ok = 0;
             break;
           }
           pp++;
           wp++;
-          if ((defcpdtable[i].size() == pp) && !(wp > wnum))
+          if ((i.size() == pp) && !(wp > wnum))
             ok = 0;
         }
       }
       if (ok && ok2) {
         size_t r = pp;
-        while ((defcpdtable[i].size() > r) && ((r + 1) < defcpdtable[i].size()) &&
-               ((defcpdtable[i][r + 1] == '*') ||
-                (defcpdtable[i][r + 1] == '?')))
+        while ((i.size() > r) && ((r + 1) < i.size()) &&
+               ((i[r + 1] == '*') ||
+                (i[r + 1] == '?')))
           r += 2;
-        if (defcpdtable[i].size() <= r)
+        if (i.size() <= r)
           return 1;
       }
       // backtrack
@@ -1494,16 +1489,16 @@ int AffixMgr::defcpd_check(hentry*** words,
         } while ((btinfo[bt - 1].btnum < 0) && --bt);
     } while (bt);
 
-    if (ok && ok2 && (!all || (defcpdtable[i].size() <= pp)))
+    if (ok && ok2 && (!all || (i.size() <= pp)))
       return 1;
 
     // check zero ending
-    while (ok && ok2 && (defcpdtable[i].size() > pp) &&
-           ((pp + 1) < defcpdtable[i].size()) &&
-           ((defcpdtable[i][pp + 1] == '*') ||
-            (defcpdtable[i][pp + 1] == '?')))
+    while (ok && ok2 && (i.size() > pp) &&
+           ((pp + 1) < i.size()) &&
+           ((i[pp + 1] == '*') ||
+            (i[pp + 1] == '?')))
       pp += 2;
-    if (ok && ok2 && (defcpdtable[i].size() <= pp))
+    if (ok && ok2 && (i.size() <= pp))
       return 1;
   }
   (*words)[wnum] = NULL;
@@ -1535,22 +1530,17 @@ short AffixMgr::get_syllable(const std::string& word) {
   short num = 0;
 
   if (!utf8) {
-    for (size_t i = 0; i < word.size(); ++i) {
-      if (std::binary_search(cpdvowels.begin(), cpdvowels.end(),
-                             word[i])) {
-        ++num;
-      }
-    }
+    num = (short)std::count_if(word.begin(), word.end(), 
+          [&](char c) {
+            return std::binary_search(cpdvowels.begin(), cpdvowels.end(), c);
+          });
   } else if (!cpdvowels_utf16.empty()) {
     std::vector<w_char> w;
     u8_u16(w, word);
-    for (size_t i = 0; i < w.size(); ++i) {
-      if (std::binary_search(cpdvowels_utf16.begin(),
-                             cpdvowels_utf16.end(),
-                             w[i])) {
-        ++num;
-      }
-    }
+    num = (short)std::count_if(w.begin(), w.end(),
+          [&](w_char wc) {
+            return std::binary_search(cpdvowels_utf16.begin(), cpdvowels_utf16.end(), wc);
+          });
   }
 
   return num;
@@ -1586,22 +1576,12 @@ struct hentry* AffixMgr::compound_check(const std::string& word,
                                         char is_sug = 0,
                                         int* info = NULL) {
   short oldnumsyllable, oldnumsyllable2, oldwordnum, oldwordnum2;
-  struct hentry* rv = NULL;
-  struct hentry* rv_first;
+  hentry *rv = NULL, *rv_first;
   std::string st;
-  char ch = '\0';
-  int cmin;
-  int cmax;
-  int striple = 0;
-  size_t scpd = 0;
-  int soldi = 0;
-  int oldcmin = 0;
-  int oldcmax = 0;
-  int oldlen = 0;
-  int checkedstriple = 0;
-  char affixed = 0;
+  char ch = '\0', affixed;
+  int cmin, cmax, striple = 0, soldi = 0, oldcmin = 0, oldcmax = 0, oldlen = 0, checkedstriple = 0;
   hentry** oldwords = words;
-  size_t len = word.size();
+  size_t scpd, len = word.size();
 
   int checked_prefix;
 
@@ -2203,20 +2183,10 @@ int AffixMgr::compound_check_morph(const std::string& word,
                                    std::string& result,
                                    const std::string* partresult) {
   short oldnumsyllable, oldnumsyllable2, oldwordnum, oldwordnum2;
-  int ok = 0;
-
-  struct hentry* rv = NULL;
-  struct hentry* rv_first;
-  std::string st;
-  char ch;
-
-  int checked_prefix;
-  std::string presult;
-
-  int cmin;
-  int cmax;
-
-  char affixed = 0;
+  hentry* rv = NULL, *rv_first;
+  std::string st, presult;
+  char ch, affixed = 0;
+  int checked_prefix, cmin, cmax, ok = 0;
   hentry** oldwords = words;
   size_t len = word.size();
 
@@ -2941,7 +2911,7 @@ std::string AffixMgr::suffix_check_twosfx_morph(const std::string& word,
 
   // now handle the general case
   if (len == 0)
-    return std::string();  // FULLSTRIP
+    return { };  // FULLSTRIP
   unsigned char sp = word[start + len - 1];
   SfxEntry* sptr = sStart[sp];
 
@@ -3057,7 +3027,7 @@ std::string AffixMgr::suffix_check_morph(const std::string& word,
 
   // now handle the general case
   if (len == 0)
-    return std::string();  // FULLSTRIP
+    return { };  // FULLSTRIP
   unsigned char sp = word[start + len - 1];
   SfxEntry* sptr = sStart[sp];
 
@@ -3206,8 +3176,7 @@ std::string AffixMgr::affix_check_morph(const std::string& word,
 // return 1, if inputs may equal with a secondary suffix
 // otherwise return -1
 static int morphcmp(const char* s, const char* t) {
-  int se = 0;
-  int te = 0;
+  int se = 0, te = 0;
   const char* sl;
   const char* tl;
   const char* olds;
@@ -3292,11 +3261,11 @@ std::string AffixMgr::morphgen(const char* ts,
                          int level) {
   // handle suffixes
   if (!morph)
-    return std::string();
+    return {};
 
   // check substandard flag
   if (TESTAFF(ap, substandard, al))
-    return std::string();
+    return {};
 
   if (morphcmp(morph, targetmorph) == 0)
     return ts;
@@ -3314,7 +3283,7 @@ std::string AffixMgr::morphgen(const char* ts,
   }
 
   for (int i = 0; i < al; i++) {
-    const unsigned char c = (unsigned char)(ap[i] & 0x00FF);
+    const auto c = (unsigned char)(ap[i] & 0x00FF);
     SfxEntry* sptr = sFlag[c];
     while (sptr) {
       if (sptr->getFlag() == ap[i] && sptr->getMorph() &&
@@ -3361,7 +3330,7 @@ std::string AffixMgr::morphgen(const char* ts,
       sptr = sptr->getFlgNxt();
     }
   }
-  return std::string();
+  return { };
 }
 
 namespace {
@@ -3406,7 +3375,7 @@ int AffixMgr::expand_rootword(struct guessword* wlst,
 
   // handle suffixes
   for (int i = 0; i < al; i++) {
-    const unsigned char c = (unsigned char)(ap[i] & 0x00FF);
+    const auto c = (unsigned char)(ap[i] & 0x00FF);
     SfxEntry* sptr = sFlag[c];
     while (sptr) {
       if ((sptr->getFlag() == ap[i]) &&
@@ -3452,7 +3421,7 @@ int AffixMgr::expand_rootword(struct guessword* wlst,
   for (int j = 1; j < n; j++)
     if (wlst[j].allow) {
       for (int k = 0; k < al; k++) {
-        const unsigned char c = (unsigned char)(ap[k] & 0x00FF);
+        const auto c = (unsigned char)(ap[k] & 0x00FF);
         PfxEntry* cptr = pFlag[c];
         while (cptr) {
           if ((cptr->getFlag() == ap[k]) && cptr->allowCross() &&
@@ -3477,7 +3446,7 @@ int AffixMgr::expand_rootword(struct guessword* wlst,
 
   // now handle pure prefixes
   for (int m = 0; m < al; m++) {
-    const unsigned char c = (unsigned char)(ap[m] & 0x00FF);
+    const auto c = (unsigned char)(ap[m] & 0x00FF);
     PfxEntry* ptr = pFlag[c];
     while (ptr) {
       if ((ptr->getFlag() == ap[m]) &&
@@ -3750,8 +3719,7 @@ bool AffixMgr::parse_num(const std::string& line, int* out, FileMgr* af) {
 bool AffixMgr::parse_cpdsyllable(const std::string& line, FileMgr* af) {
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -3804,8 +3772,7 @@ bool AffixMgr::parse_convtable(const std::string& line,
   int i = 0;
   int np = 0;
   int numrl = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -3898,8 +3865,7 @@ bool AffixMgr::parse_phonetable(const std::string& line, FileMgr* af) {
   int num = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -3952,11 +3918,11 @@ bool AffixMgr::parse_phonetable(const std::string& line, FileMgr* af) {
             break;
           }
           case 1: {
-            new_phone->rules.push_back(std::string(start_piece, iter));
+            new_phone->rules.emplace_back(start_piece, iter);
             break;
           }
           case 2: {
-            new_phone->rules.push_back(std::string(start_piece, iter));
+            new_phone->rules.emplace_back(start_piece, iter);
             mystrrep(new_phone->rules.back(), "_", "");
             break;
           }
@@ -3973,8 +3939,8 @@ bool AffixMgr::parse_phonetable(const std::string& line, FileMgr* af) {
       return false;
     }
   }
-  new_phone->rules.push_back("");
-  new_phone->rules.push_back("");
+  new_phone->rules.emplace_back("");
+  new_phone->rules.emplace_back("");
   init_phonet_hash(*new_phone);
   phone = new_phone.release();
   return true;
@@ -3991,8 +3957,7 @@ bool AffixMgr::parse_checkcpdtable(const std::string& line, FileMgr* af) {
   int numcheckcpd = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -4029,7 +3994,7 @@ bool AffixMgr::parse_checkcpdtable(const std::string& line, FileMgr* af) {
       return false;
     mychomp(nl);
     i = 0;
-    checkcpdtable.push_back(patentry());
+    checkcpdtable.emplace_back();
     iter = nl.begin();
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
@@ -4088,8 +4053,7 @@ bool AffixMgr::parse_defcpdtable(const std::string& line, FileMgr* af) {
   int numdefcpd = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -4126,7 +4090,7 @@ bool AffixMgr::parse_defcpdtable(const std::string& line, FileMgr* af) {
       return false;
     mychomp(nl);
     i = 0;
-    defcpdtable.push_back(flagentry());
+    defcpdtable.emplace_back();
     iter = nl.begin();
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
@@ -4142,11 +4106,10 @@ bool AffixMgr::parse_defcpdtable(const std::string& line, FileMgr* af) {
         }
         case 1: {  // handle parenthesized flags
           if (std::find(start_piece, iter, '(') != iter) {
-            for (std::string::const_iterator k = start_piece; k != iter; ++k) {
-              std::string::const_iterator chb = k;
-              std::string::const_iterator che = k + 1;
+            for (auto k = start_piece; k != iter; ++k) {
+              auto chb = k, che = k + 1;
               if (*k == '(') {
-                std::string::const_iterator parpos = std::find(k, iter, ')');
+	            auto parpos = std::find(k, iter, ')');
                 if (parpos != iter) {
                   chb = k + 1;
                   che = parpos;
@@ -4191,8 +4154,7 @@ bool AffixMgr::parse_maptable(const std::string& line, FileMgr* af) {
   int nummap = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -4229,7 +4191,7 @@ bool AffixMgr::parse_maptable(const std::string& line, FileMgr* af) {
       return false;
     mychomp(nl);
     i = 0;
-    maptable.push_back(mapentry());
+    maptable.emplace_back();
     iter = nl.begin();
     start_piece = mystrsep(nl, iter);
     while (start_piece != nl.end()) {
@@ -4244,11 +4206,10 @@ bool AffixMgr::parse_maptable(const std::string& line, FileMgr* af) {
           break;
         }
         case 1: {
-          for (std::string::const_iterator k = start_piece; k != iter; ++k) {
-            std::string::const_iterator chb = k;
-            std::string::const_iterator che = k + 1;
+          for (auto k = start_piece; k != iter; ++k) {
+            auto chb = k, che = k + 1;
             if (*k == '(') {
-              std::string::const_iterator parpos = std::find(k, iter, ')');
+              auto parpos = std::find(k, iter, ')');
               if (parpos != iter) {
                 chb = k + 1;
                 che = parpos;
@@ -4268,7 +4229,7 @@ bool AffixMgr::parse_maptable(const std::string& line, FileMgr* af) {
                               af->getlinenum());
             }
 
-            maptable.back().push_back(std::string(chb, che));
+            maptable.back().emplace_back(chb, che);
           }
           break;
         }
@@ -4298,8 +4259,7 @@ bool AffixMgr::parse_breaktable(const std::string& line, FileMgr* af) {
   int numbreak = -1;
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -4352,7 +4312,7 @@ bool AffixMgr::parse_breaktable(const std::string& line, FileMgr* af) {
           break;
         }
         case 1: {
-          breaktable.push_back(std::string(start_piece, iter));
+          breaktable.emplace_back(start_piece, iter);
           break;
         }
         default:
@@ -4377,7 +4337,7 @@ void AffixMgr::reverse_condition(std::string& piece) {
       return;
 
   int neg = 0;
-  for (std::string::reverse_iterator k = piece.rbegin(); k != piece.rend(); ++k) {
+  for (auto k = piece.rbegin(); k != piece.rend(); ++k) {
     switch (*k) {
       case '[': {
         if (neg)
@@ -4450,8 +4410,8 @@ class entries_container {
   }
 
   ~entries_container() {
-    for (size_t i = 0; i < entries.size(); ++i) {
-        delete entries[i];
+    for (auto& entry : entries) {
+      delete entry;
     }
   }
 
@@ -4480,8 +4440,7 @@ bool AffixMgr::parse_affix(const std::string& line,
   // split affix header line into pieces
 
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       // piece 1 - is type of affix
@@ -4753,13 +4712,12 @@ bool AffixMgr::parse_affix(const std::string& line,
 
   // now create SfxEntry or PfxEntry objects and use links to
   // build an ordered (sorted by affix string) list
-  std::vector<AffEntry*>::iterator start = affentries.begin();
-  std::vector<AffEntry*>::iterator end = affentries.end();
-  for (std::vector<AffEntry*>::iterator affentry = start; affentry != end; ++affentry) {
+  auto start = affentries.begin(), end = affentries.end();
+  for (auto affentry = start; affentry != end; ++affentry) {
     if (at == 'P') {
-      build_pfxtree(static_cast<PfxEntry*>(*affentry));
+      build_pfxtree(dynamic_cast<PfxEntry*>(*affentry));
     } else {
-      build_sfxtree(static_cast<SfxEntry*>(*affentry));
+      build_sfxtree(dynamic_cast<SfxEntry*>(*affentry));
     }
   }
 
@@ -4773,10 +4731,7 @@ int AffixMgr::redundant_condition(char ft,
                                   const std::string& strip,
                                   const std::string& cond,
                                   int linenum) {
-  int stripl = strip.size(), condl = cond.size();
-  int i, j;
-  int neg;
-  int in;
+  int stripl = strip.size(), condl = cond.size(), i, j, neg, in;
   if (ft == 'P') {  // prefix
     if (strip.compare(0, condl, cond) == 0)
       return 1;
@@ -4866,8 +4821,7 @@ std::vector<std::string> AffixMgr::get_suffix_words(short unsigned* suff,
                                const std::string& root_word) {
   std::vector<std::string> slst;
   short unsigned* start_ptr = suff;
-  for (int j = 0; j < SETSIZE; j++) {
-    SfxEntry* ptr = sStart[j];
+  for (auto ptr : sStart) {
     while (ptr) {
       suff = start_ptr;
       for (int i = 0; i < len; i++) {
diff --git a/src/hunspell/affixmgr.hxx b/src/hunspell/affixmgr.hxx
index a0ba103dd..174ce3325 100644
--- a/src/hunspell/affixmgr.hxx
+++ b/src/hunspell/affixmgr.hxx
@@ -71,7 +71,7 @@
 #ifndef AFFIXMGR_HXX_
 #define AFFIXMGR_HXX_
 
-#include <stdio.h>
+#include <cstdio>
 
 #include <string>
 #include <vector>
diff --git a/src/hunspell/baseaffix.hxx b/src/hunspell/baseaffix.hxx
index bd2f3f2b8..b1f24046c 100644
--- a/src/hunspell/baseaffix.hxx
+++ b/src/hunspell/baseaffix.hxx
@@ -41,10 +41,6 @@
 #include <string>
 
 class AffEntry {
- private:
-  AffEntry(const AffEntry&);
-  AffEntry& operator=(const AffEntry&);
-
  public:
   AffEntry()
       : numconds(0),
@@ -53,6 +49,8 @@ class AffEntry {
         morphcode(0),
         contclass(NULL),
         contclasslen(0) {}
+  AffEntry(const AffEntry&) = delete;
+  AffEntry& operator=(const AffEntry&) = delete;
   virtual ~AffEntry();
   std::string appnd;
   std::string strip;
diff --git a/src/hunspell/csutil.cxx b/src/hunspell/csutil.cxx
index f3a9d61dc..4589e77e0 100644
--- a/src/hunspell/csutil.cxx
+++ b/src/hunspell/csutil.cxx
@@ -70,10 +70,10 @@
 
 #include <algorithm>
 #include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
 #include <sstream>
 #if __cplusplus >= 202002L
 #include <bit>
@@ -127,8 +127,7 @@ void myopen(std::ifstream& stream, const char* path, std::ios_base::openmode mod
 std::string& u16_u8(std::string& dest, const std::vector<w_char>& src) {
   dest.clear();
   dest.reserve(src.size());
-  std::vector<w_char>::const_iterator u2 = src.begin();
-  std::vector<w_char>::const_iterator u2_max = src.end();
+  auto u2 = src.begin(), u2_max = src.end();
   while (u2 < u2_max) {
     signed char u8;
     if (u2->h) {  // > 0xFF
@@ -166,9 +165,8 @@ int u8_u16(std::vector<w_char>& dest, const std::string& src, bool only_convert_
   // faster to oversize initially, assign to elements and resize to what's used
   // than to reserve and push_back
   dest.resize(only_convert_first_letter ? 1 : src.size());
-  std::vector<w_char>::iterator u16 = dest.begin();
-  std::string::const_iterator u8 = src.begin();
-  std::string::const_iterator u8_max = src.end();
+  auto u16 = dest.begin();
+  auto u8 = src.begin(), u8_max = src.end();
 
   while (u8 < u8_max) {
     w_char u2;
@@ -270,7 +268,7 @@ class is_any_of {
  public:
   explicit is_any_of(const std::string& in) : chars(in) {}
 
-  bool operator()(char c) { return chars.find(c) != std::string::npos; }
+  bool operator()(char c) const { return chars.find(c) != std::string::npos; }
 
  private:
   std::string chars;
@@ -279,16 +277,16 @@ class is_any_of {
 
 std::string::const_iterator mystrsep(const std::string &str,
                                      std::string::const_iterator& start) {
-  std::string::const_iterator end = str.end();
+  auto end = str.end();
 
   is_any_of op(" \t");
   // don't use isspace() here, the string can be in some random charset
   // that's way different than the locale's
-  std::string::const_iterator sp = start;
+  auto sp = start;
   while (sp != end && op(*sp))
       ++sp;
 
-  std::string::const_iterator dp = sp;
+  auto dp = sp;
   while (dp != end && !op(*dp))
       ++dp;
 
@@ -383,9 +381,9 @@ void line_uniq_app(std::string& text, char breakchar) {
   }
 
   text.assign(" ( ");
-  for (size_t i = 0; i < lines.size(); ++i) {
-      text.append(lines[i]);
-      text.append(" | ");
+  for (auto& line : lines) {
+    text.append(line);
+    text.append(" | ");
   }
   text[text.size() - 2] = ')';  // " ) "
 }
@@ -421,9 +419,8 @@ bool copy_field(std::string& dest,
   dest.clear();
   std::string beg(morph.substr(pos + MORPH_TAG_LEN, std::string::npos));
 
-  for (size_t i = 0; i < beg.size(); ++i) {
-    const char c(beg[i]);
-    if (c == ' ' || c == '\t' || c == '\n')
+  for (const char c : beg) {
+	if (c == ' ' || c == '\t' || c == '\n')
       break;
     dest.push_back(c);
   }
@@ -614,30 +611,30 @@ w_char lower_utf(w_char u, int langnum) {
 
 // convert std::string to all caps
 std::string& mkallcap(std::string& s, const struct cs_info* csconv) {
-  for (std::string::iterator aI = s.begin(), aEnd = s.end(); aI != aEnd; ++aI) {
-    *aI = cupper(csconv, static_cast<unsigned char>(*aI));
+  for (char& aI : s) {
+    aI = cupper(csconv, static_cast<unsigned char>(aI));
   }
   return s;
 }
 
 // convert std::string to all little
 std::string& mkallsmall(std::string& s, const struct cs_info* csconv) {
-  for (std::string::iterator aI = s.begin(), aEnd = s.end(); aI != aEnd; ++aI) {
-    *aI = clower(csconv, static_cast<unsigned char>(*aI));
+  for (char& aI : s) {
+    aI = clower(csconv, static_cast<unsigned char>(aI));
   }
   return s;
 }
 
 std::vector<w_char>& mkallsmall_utf(std::vector<w_char>& u, int langnum) {
-  for (size_t i = 0; i < u.size(); ++i) {
-	u[i] = lower_utf(u[i], langnum);
+  for (auto& i : u) {
+    i = lower_utf(i, langnum);
   }
   return u;
 }
 
 std::vector<w_char>& mkallcap_utf(std::vector<w_char>& u, int langnum) {
-  for (size_t i = 0; i < u.size(); i++) {
-	u[i] = upper_utf(u[i], langnum);
+  for (auto& i : u) {
+    i = upper_utf(i, langnum);
   }
   return u;
 }
@@ -2331,10 +2328,9 @@ struct cs_info* get_current_cs(const std::string& es) {
   toAsciiLowerAndRemoveNonAlphanumeric(es.c_str(), normalized_encoding);
 
   struct cs_info* ccs = NULL;
-  int n = sizeof(encds) / sizeof(encds[0]);
-  for (int i = 0; i < n; i++) {
-    if (strcmp(normalized_encoding, encds[i].enc_name) == 0) {
-      ccs = encds[i].cs_table;
+  for (const auto& encd : encds) {
+    if (strcmp(normalized_encoding, encd.enc_name) == 0) {
+      ccs = encd.cs_table;
       break;
     }
   }
@@ -2480,10 +2476,9 @@ static struct lang_map lang2enc[] =
      {"ru", LANG_ru},    {"uk", LANG_uk}};
 
 int get_lang_num(const std::string& lang) {
-  int n = sizeof(lang2enc) / sizeof(lang2enc[0]);
-  for (int i = 0; i < n; i++) {
-    if (strcmp(lang.c_str(), lang2enc[i].lang) == 0) {
-      return lang2enc[i].num;
+  for (const auto& i : lang2enc) {
+    if (strcmp(lang.c_str(), i.lang) == 0) {
+      return i.num;
     }
   }
   return LANG_xx;
@@ -2539,15 +2534,15 @@ int get_captype(const std::string& word, cs_info* csconv) {
   size_t firstcap = 0;
   if (csconv == NULL)
     return NOCAP;
-  for (std::string::const_iterator q = word.begin(); q != word.end(); ++q) {
-    unsigned char nIndex = static_cast<unsigned char>(*q);
+  for (auto q = word.begin(); q != word.end(); ++q) {
+    const auto nIndex = static_cast<unsigned char>(*q);
     if (ccase(csconv, nIndex))
       ncap++;
     if (cupper(csconv, nIndex) == clower(csconv, nIndex))
       nneutral++;
   }
   if (ncap) {
-    unsigned char nIndex = static_cast<unsigned char>(word[0]);
+    const auto nIndex = static_cast<unsigned char>(word[0]);
     firstcap = csconv[nIndex].ccase;
   }
 
@@ -2570,11 +2565,10 @@ int get_captype_utf8(const std::vector<w_char>& word, int langnum) {
   size_t nneutral = 0;
   size_t firstcap = 0;
 
-  std::vector<w_char>::const_iterator it = word.begin();
-  std::vector<w_char>::const_iterator it_end = word.end();
+  auto it = word.begin(), it_end = word.end();
   while (it != it_end) {
-    unsigned short idx = (unsigned short)(*it);
-    unsigned short lwridx = unicodetolower(idx, langnum);
+    const auto idx = (unsigned short)*it;
+    const auto lwridx = unicodetolower(idx, langnum);
     if (idx != lwridx)
       ncap++;
     if (unicodetoupper(idx, langnum) == lwridx)
@@ -2582,7 +2576,7 @@ int get_captype_utf8(const std::vector<w_char>& word, int langnum) {
     ++it;
   }
   if (ncap) {
-    unsigned short idx = (unsigned short)(word[0]);
+    const auto idx = (unsigned short)word[0];
     firstcap = (idx != unicodetolower(idx, langnum));
   }
 
@@ -2606,13 +2600,10 @@ size_t remove_ignored_chars_utf(std::string& word,
   std::vector<w_char> w2;
   u8_u16(w, word);
 
-  for (size_t i = 0; i < w.size(); ++i) {
-    if (!std::binary_search(ignored_chars.begin(),
-                            ignored_chars.end(),
-                            w[i])) {
-      w2.push_back(w[i]);
-    }
-  }
+  std::copy_if(w.begin(), w.end(), std::back_inserter(w2), 
+  [&ignored_chars](w_char wc) {
+    return !std::binary_search(ignored_chars.begin(), ignored_chars.end(), wc);
+  });
 
   u16_u8(word, w2);
   return w2.size();
@@ -2634,8 +2625,7 @@ bool parse_string(const std::string& line, std::string& out, int ln) {
   }
   int i = 0;
   int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
diff --git a/src/hunspell/csutil.hxx b/src/hunspell/csutil.hxx
index 1635543db..808087d1f 100644
--- a/src/hunspell/csutil.hxx
+++ b/src/hunspell/csutil.hxx
@@ -78,8 +78,9 @@
 #include <fstream>
 #include <string>
 #include <vector>
-#include <assert.h>
-#include <string.h>
+#include <cassert>
+#include <cstring>
+#include <algorithm>
 #include "w_char.hxx"
 #include "htypes.hxx"
 
@@ -273,10 +274,8 @@ LIBHUNSPELL_DLL_EXPORTED char* get_stored_pointer(const char* s);
 // "likely false", if ignored_chars characters are not ASCII)
 inline bool has_no_ignored_chars(const std::string& word,
                             const std::string& ignored_chars) {
-  for (std::string::const_iterator it = ignored_chars.begin(), end = ignored_chars.end(); it != end; ++it)
-    if (word.find(*it) != std::string::npos)
-      return false;
-  return true;
+  return std::all_of(ignored_chars.begin(), ignored_chars.end(), 
+    [&word](char ic) { return word.find(ic) == std::string::npos; });
 }
 
 // hash entry macros
@@ -316,8 +315,7 @@ inline const char* HENTRY_DATA2(
   return ret;
 }
 
-inline char* HENTRY_FIND(struct hentry* h,
-                                                  const char* p) {
+inline char* HENTRY_FIND(struct hentry* h, const char* p) {
   char* data = HENTRY_DATA(h);
   return data ? strstr(data, p) : NULL;
 }
diff --git a/src/hunspell/filemgr.cxx b/src/hunspell/filemgr.cxx
index 4a754e52a..10729ea2b 100644
--- a/src/hunspell/filemgr.cxx
+++ b/src/hunspell/filemgr.cxx
@@ -68,9 +68,9 @@
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
 
 #include "filemgr.hxx"
 #include "csutil.hxx"
diff --git a/src/hunspell/filemgr.hxx b/src/hunspell/filemgr.hxx
index 88fe88388..b933f95e5 100644
--- a/src/hunspell/filemgr.hxx
+++ b/src/hunspell/filemgr.hxx
@@ -73,15 +73,11 @@
 #define FILEMGR_HXX_
 
 #include "hunzip.hxx"
-#include <stdio.h>
+#include <cstdio>
 #include <string>
 #include <fstream>
 
 class FileMgr {
- private:
-  FileMgr(const FileMgr&);
-  FileMgr& operator=(const FileMgr&);
-
  protected:
   std::ifstream fin;
   Hunzip* hin;
@@ -91,6 +87,8 @@ class FileMgr {
 
  public:
   FileMgr(const char* filename, const char* key = NULL);
+  FileMgr(const FileMgr&) = delete;
+  FileMgr& operator=(const FileMgr&) = delete;
   ~FileMgr();
   bool getline(std::string&);
   int getlinenum();
diff --git a/src/hunspell/hashmgr.cxx b/src/hunspell/hashmgr.cxx
index f9ddcb567..cde8952c3 100644
--- a/src/hunspell/hashmgr.cxx
+++ b/src/hunspell/hashmgr.cxx
@@ -68,12 +68,15 @@
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
 #include <limits>
 #include <sstream>
+#if __cplusplus >= 202002L
+#include <bit>
+#endif
 
 #include "hashmgr.hxx"
 #include "csutil.hxx"
@@ -111,14 +114,13 @@ void HashMgr::free_flag(unsigned short* astr, short alen) {
 void HashMgr::free_table() {
   // now pass through hash table freeing up everything
   // go through column by column of the table
-  for (size_t i = 0; i < tableptr.size(); ++i) {
-    struct hentry* pt = tableptr[i];
-    struct hentry* nt = NULL;
-    while (pt) {
-      nt = pt->next;
-      free_flag(pt->astr, pt->alen);
-      free(pt);
-      pt = nt;
+  for (auto ptr : tableptr) {
+    hentry* nt = NULL;
+    while (ptr) {
+      nt = ptr->next;
+      free_flag(ptr->astr, ptr->alen);
+      free(ptr);
+      ptr = nt;
     }
   }
   tableptr.clear();
@@ -127,12 +129,12 @@ void HashMgr::free_table() {
 HashMgr::~HashMgr() {
   free_table();
 
-  for (size_t j = 0, numaliasf = aliasf.size(); j < numaliasf; ++j)
-    delete[] aliasf[j];
+  for (auto& j : aliasf)
+    delete[] j;
   aliasf.clear();
 
-  for (size_t j = 0, numaliasm = aliasm.size(); j < numaliasm; ++j)
-    delete[] aliasm[j];
+  for (auto& j : aliasm)
+    delete[] j;
   aliasm.clear();
 
 #ifdef MOZILLA_CLIENT
@@ -218,7 +220,7 @@ int HashMgr::add_word(const std::string& in_word,
   bool upcasehomonym = false;
   int descl = desc ? (!aliasm.empty() ? sizeof(char*) : desc->size() + 1) : 0;
   // variable-length hash record with word and optional fields
-  struct hentry* hp =
+  auto hp =
       (struct hentry*)malloc(sizeof(struct hentry) + word->size() + descl);
   if (!hp) {
     delete desc_copy;
@@ -258,12 +260,11 @@ int HashMgr::add_word(const std::string& in_word,
       if (reptable.capacity() < predicted)
           reptable.reserve(predicted);
       std::string fields = HENTRY_DATA(hp);
-      std::string::const_iterator iter = fields.begin();
-      std::string::const_iterator start_piece = mystrsep(fields, iter);
+      std::string::const_iterator iter = fields.begin(), start_piece = mystrsep(fields, iter);
       while (start_piece != fields.end()) {
         if (std::string(start_piece, iter).find(MORPH_PHON) == 0) {
           std::string ph = std::string(start_piece, iter).substr(sizeof MORPH_PHON - 1);
-          if (ph.size() > 0) {
+          if (!ph.empty()) {
             std::vector<w_char> w;
             size_t strippatt;
             std::string wordpart;
@@ -304,7 +305,7 @@ int HashMgr::add_word(const std::string& in_word,
             // good suggestions also for capitalized misspellings, eg.
             // Wednesday ph:wendsay
             // results wendsay -> Wednesday and Wendsay -> Wednesday, too.
-            if (captype==INITCAP) {
+            if (captype == INITCAP) {
               std::string ph_capitalized;
               if (utf8) {
                 u8_u16(w, ph);
@@ -315,7 +316,7 @@ int HashMgr::add_word(const std::string& in_word,
               } else if (get_captype(ph, csconv) == NOCAP)
                   mkinitcap(ph_capitalized, csconv);
 
-              if (ph_capitalized.size() > 0) {
+              if (!ph_capitalized.empty()) {
                 // add also lowercase word in the case of German or
                 // Hungarian to support lowercase suggestions lowercased by
                 // compound word generation or derivational suffixes
@@ -335,16 +336,16 @@ int HashMgr::add_word(const std::string& in_word,
                   } else {
                     mkallsmall(wordpart_lower, csconv);
                   }
-                  reptable.push_back(replentry());
+                  reptable.emplace_back();
                   reptable.back().pattern.assign(ph);
                   reptable.back().outstrings[0].assign(wordpart_lower);
                 }
-                reptable.push_back(replentry());
+                reptable.emplace_back();
                 reptable.back().pattern.assign(ph_capitalized);
                 reptable.back().outstrings[0].assign(wordpart);
               }
             }
-            reptable.push_back(replentry());
+            reptable.emplace_back();
             reptable.back().pattern.assign(ph);
             reptable.back().outstrings[0].assign(wordpart);
           }
@@ -476,7 +477,7 @@ int HashMgr::remove(const std::string& word) {
   struct hentry* dp = lookup(word.c_str(), word.size());
   while (dp) {
     if (dp->alen == 0 || !TESTAFF(dp->astr, forbiddenword, dp->alen)) {
-      unsigned short* flags = new unsigned short[dp->alen + 1];
+      auto flags = new unsigned short[dp->alen + 1];
       for (int i = 0; i < dp->alen; i++)
         flags[i] = dp->astr[i];
       flags[dp->alen] = forbiddenword;
@@ -506,8 +507,7 @@ int HashMgr::remove_forbidden_flag(const std::string& word) {
 // add a custom dic. word to the hash table (public)
 int HashMgr::add(const std::string& word) {
   if (remove_forbidden_flag(word)) {
-    int captype;
-    int al = 0;
+    int captype, al = 0;
     unsigned short* flags = NULL;
     int wcl = get_clen_and_captype(word, &captype);
     add_word(word, wcl, flags, al, NULL, false, captype);
@@ -527,9 +527,8 @@ int HashMgr::add_with_affix(const std::string& word, const std::string& example)
     if (!aliasf.empty()) {
       add_word(word, wcl, dp->astr, dp->alen, NULL, false, captype);
     } else {
-      unsigned short* flags = new unsigned short[dp->alen];
-      memcpy((void*)flags, (void*)dp->astr,
-             dp->alen * sizeof(unsigned short));
+      auto flags = new unsigned short[dp->alen];
+      memcpy(flags, dp->astr, dp->alen * sizeof(unsigned short));
       add_word(word, wcl, flags, dp->alen, NULL, false, captype);
     }
     return add_hidden_capitalized_word(word, wcl, dp->astr,
@@ -658,7 +657,7 @@ int HashMgr::load_tables(const char* tpath, const char* key) {
                            dict->getlinenum());
         }
       } else {
-        al = decode_flags(&flags, ap.c_str(), dict);
+        al = decode_flags(&flags, ap, dict);
         if (al == -1) {
           HUNSPELL_WARNING(stderr, "Can't allocate memory.\n");
           delete dict;
@@ -731,14 +730,9 @@ int HashMgr::decode_flags(unsigned short** result, const std::string& flags, Fil
     }
     case FLAG_NUM: {  // decimal numbers separated by comma (4521,23,233 -> 4521
                       // 23 233)
-      len = 1;
-      unsigned short* dest;
-      for (size_t i = 0; i < flags.size(); ++i) {
-        if (flags[i] == ',')
-          len++;
-      }
+      len = int(1 + std::count_if(flags.begin(), flags.end(), [](char c) { return c == ','; }));
       *result = new unsigned short[len];
-      dest = *result;
+      unsigned short* dest = *result;
       const char* src = flags.c_str();
       for (size_t p = 0; p < flags.size(); ++p) {
         if (flags[p] == ',') {
@@ -779,12 +773,11 @@ int HashMgr::decode_flags(unsigned short** result, const std::string& flags, Fil
       break;
     }
     default: {  // Ispell's one-character flags (erfg -> e r f g)
-      unsigned short* dest;
-      len = flags.size();
+	  len = flags.size();
       *result = new unsigned short[len];
-      dest = *result;
-      for (size_t i = 0; i < flags.size(); ++i) {
-        *dest = (unsigned char)flags[i];
+      unsigned short* dest = *result;
+      for (const char flag : flags) {
+        *dest = (unsigned char)flag;
         dest++;
       }
     }
@@ -845,16 +838,15 @@ bool HashMgr::decode_flags(std::vector<unsigned short>& result, const std::strin
     case FLAG_UNI: {  // UTF-8 characters
       std::vector<w_char> w;
       u8_u16(w, flags);
-      size_t len = w.size();
-      size_t origsize = result.size();
+      size_t len = w.size(), origsize = result.size();
       result.resize(origsize + len);
       memcpy(result.data() + origsize, w.data(), len * sizeof(short));
       break;
     }
     default: {  // Ispell's one-character flags (erfg -> e r f g)
       result.reserve(flags.size());
-      for (size_t i = 0; i < flags.size(); ++i) {
-        result.push_back((unsigned char)flags[i]);
+      for (const char flag : flags) {
+        result.push_back((unsigned char)flag);
       }
     }
   }
@@ -904,8 +896,23 @@ std::string HashMgr::encode_flag(unsigned short f) const {
     stream << f;
     ch = stream.str();
   } else if (flag_mode == FLAG_UNI) {
-    const w_char* w_c = (const w_char*)&f;
-    std::vector<w_char> w(w_c, w_c + 1);
+
+#if defined(__i386__) || defined(_M_IX86) || defined(_M_X64)
+
+#if __cplusplus >= 202002L
+    auto wc = std::bit_cast<w_char>(f);
+#else
+    w_char wc;
+    memcpy(&wc, &f, sizeof(unsigned short));
+#endif
+
+#else
+    w_char wc;
+    wc.h = (unsigned char)(f >> 8);
+    wc.l = (unsigned char)(f & 0xff);
+#endif
+    //const w_char* w_c = (const w_char*)&f; <- this will not work properly on big endian architecture 
+    const std::vector<w_char> w = { wc };
     u16_u8(ch, w);
   } else {
     ch.push_back((unsigned char)(f));
@@ -1044,11 +1051,8 @@ bool HashMgr::parse_aliasf(const std::string& line, FileMgr* af) {
                      af->getlinenum());
     return false;
   }
-  int i = 0;
-  int np = 0;
-  int numaliasf = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  int i = 0, np = 0, numaliasf = 0;
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -1156,11 +1160,8 @@ bool HashMgr::parse_aliasm(const std::string& line, FileMgr* af) {
                      af->getlinenum());
     return false;
   }
-  int i = 0;
-  int np = 0;
-  int numaliasm = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  int i = 0, np = 0, numaliasm = 0;
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -1264,11 +1265,8 @@ bool HashMgr::parse_reptable(const std::string& line, FileMgr* af) {
                      af->getlinenum());
     return false;
   }
-  int numrep = -1;
-  int i = 0;
-  int np = 0;
-  std::string::const_iterator iter = line.begin();
-  std::string::const_iterator start_piece = mystrsep(line, iter);
+  int numrep = -1, i = 0, np = 0;
+  auto iter = line.begin(), start_piece = mystrsep(line, iter);
   while (start_piece != line.end()) {
     switch (i) {
       case 0: {
@@ -1301,7 +1299,7 @@ bool HashMgr::parse_reptable(const std::string& line, FileMgr* af) {
   /* now parse the numrep lines to read in the remainder of the table */
   for (int j = 0; j < numrep; ++j) {
     std::string nl;
-    reptable.push_back(replentry());
+    reptable.emplace_back();
     int type = 0;
     if (af->getline(nl)) {
       mychomp(nl);
diff --git a/src/hunspell/hashmgr.hxx b/src/hunspell/hashmgr.hxx
index a21b78463..3c82e4c62 100644
--- a/src/hunspell/hashmgr.hxx
+++ b/src/hunspell/hashmgr.hxx
@@ -71,7 +71,7 @@
 #ifndef HASHMGR_HXX_
 #define HASHMGR_HXX_
 
-#include <stdio.h>
+#include <cstdio>
 #include <string>
 #include <vector>
 
diff --git a/src/hunspell/hunspell.cxx b/src/hunspell/hunspell.cxx
index cddcb4c54..d2ad84754 100644
--- a/src/hunspell/hunspell.cxx
+++ b/src/hunspell/hunspell.cxx
@@ -68,10 +68,10 @@
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <time.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <ctime>
 
 #include "affixmgr.hxx"
 #include "hunspell.hxx"
@@ -88,6 +88,8 @@ class HunspellImpl
 {
 public:
   HunspellImpl(const char* affpath, const char* dpath, const char* key = NULL);
+  HunspellImpl(const HunspellImpl&) = delete;
+  HunspellImpl& operator=(const HunspellImpl&) = delete;
   ~HunspellImpl();
   int add_dic(const char* dpath, const char* key = NULL);
   std::vector<std::string> suffix_suggest(const std::string& root_word);
@@ -169,9 +171,6 @@ class HunspellImpl
   std::string::size_type get_xml_pos(const std::string& s, std::string::size_type pos, const char* attr);
   std::vector<std::string> get_xml_list(const std::string& list, std::string::size_type pos, const char* tag);
   int check_xml_par(const std::string& q, std::string::size_type pos, const char* attr, const char* value);
-private:
-  HunspellImpl(const HunspellImpl&);
-  HunspellImpl& operator=(const HunspellImpl&);
 };
 
 HunspellImpl::HunspellImpl(const char* affpath, const char* dpath, const char* key)
@@ -205,8 +204,8 @@ HunspellImpl::HunspellImpl(const char* affpath, const char* dpath, const char* k
 HunspellImpl::~HunspellImpl() {
   delete pSMgr;
   delete pAMgr;
-  for (size_t i = 0; i < m_HMgrs.size(); ++i)
-    delete m_HMgrs[i];
+  for (auto& m_HMgr : m_HMgrs)
+    delete m_HMgr;
   pSMgr = NULL;
   pAMgr = NULL;
 #ifdef MOZILLA_CLIENT
@@ -342,9 +341,9 @@ void HunspellImpl::cleanword(std::string& dest,
   } else {
     std::vector<w_char> t;
     u8_u16(t, src);
-    for (size_t i = 0; i < t.size(); ++i) {
-      unsigned short idx = (unsigned short)t[i];
-      unsigned short low = unicodetolower(idx, langnum);
+    for (auto& wc : t) {
+      const auto idx = (unsigned short)wc;
+      const auto low = unicodetolower(idx, langnum);
       if (idx != low)
         ncap++;
       if (unicodetoupper(idx, langnum) == low)
@@ -352,7 +351,7 @@ void HunspellImpl::cleanword(std::string& dest,
     }
     u16_u8(dest, t);
     if (ncap) {
-      unsigned short idx = (unsigned short)t[0];
+      const auto idx = (unsigned short)t[0];
       firstcap = (idx != unicodetolower(idx, langnum));
     }
   }
@@ -563,8 +562,7 @@ bool HunspellImpl::spell_internal(const std::string& word, std::vector<std::stri
         //conversion may result in string with different len to pre-mkallsmall2
         //so re-scan
         if (apos != std::string::npos && apos < scw.size() - 1) {
-          std::string part1 = scw.substr(0, apos+1);
-          std::string part2 = scw.substr(apos+1);
+          std::string part1 = scw.substr(0, apos + 1), part2 = scw.substr(apos + 1);
           if (utf8) {
             std::vector<w_char> part1u, part2u;
             u8_u16(part1u, part1);
@@ -690,28 +688,28 @@ bool HunspellImpl::spell_internal(const std::string& word, std::vector<std::stri
     wl = scw.size();
 
     // calculate break points for recursion limit
-    for (size_t j = 0; j < wordbreak.size(); ++j) {
+    for (auto& j : wordbreak) {
       size_t pos = 0;
-      while ((pos = scw.find(wordbreak[j], pos)) != std::string::npos) {
+      while ((pos = scw.find(j, pos)) != std::string::npos) {
         ++nbr;
-        pos += wordbreak[j].size();
+        pos += j.size();
       }
     }
     if (nbr >= 10)
       return false;
 
     // check boundary patterns (^begin and end$)
-    for (size_t j = 0; j < wordbreak.size(); ++j) {
-      size_t plen = wordbreak[j].size();
+    for (auto& j : wordbreak) {
+      size_t plen = j.size();
       if (plen == 1 || plen > wl)
         continue;
 
-      if (wordbreak[j][0] == '^' &&
-          scw.compare(0, plen - 1, wordbreak[j], 1, plen -1) == 0 && spell(scw.substr(plen - 1), candidate_stack))
+      if (j[0] == '^' &&
+          scw.compare(0, plen - 1, j, 1, plen -1) == 0 && spell(scw.substr(plen - 1), candidate_stack))
         return true;
 
-      if (wordbreak[j][plen - 1] == '$' &&
-          scw.compare(wl - plen + 1, plen - 1, wordbreak[j], 0, plen - 1) == 0) {
+      if (j[plen - 1] == '$' &&
+          scw.compare(wl - plen + 1, plen - 1, j, 0, plen - 1) == 0) {
         std::string suffix(scw.substr(wl - plen + 1));
         scw.resize(wl - plen + 1);
         if (spell(scw, candidate_stack))
@@ -721,11 +719,11 @@ bool HunspellImpl::spell_internal(const std::string& word, std::vector<std::stri
     }
 
     // other patterns
-    for (size_t j = 0; j < wordbreak.size(); ++j) {
-      size_t plen = wordbreak[j].size();
-      size_t found = scw.find(wordbreak[j]);
+    for (auto& j : wordbreak) {
+      size_t plen = j.size();
+      size_t found = scw.find(j);
       if ((found > 0) && (found < wl - plen)) {
-        size_t found2 = scw.find(wordbreak[j], found + 1);
+        size_t found2 = scw.find(j, found + 1);
         // try to break at the second occurance
         // to recognize dictionary words with wordbreak
         if (found2 > 0 && (found2 < wl - plen))
@@ -741,7 +739,7 @@ bool HunspellImpl::spell_internal(const std::string& word, std::vector<std::stri
         scw.append(suffix);
 
         // LANG_hu: spec. dash rule
-        if (langnum == LANG_hu && wordbreak[j] == "-") {
+        if (langnum == LANG_hu && j == "-") {
           suffix = scw.substr(found + 1);
           scw.resize(found + 1);
           if (spell(scw, candidate_stack))
@@ -753,9 +751,8 @@ bool HunspellImpl::spell_internal(const std::string& word, std::vector<std::stri
     }
 
     // other patterns (break at first break point)
-    for (size_t j = 0; j < wordbreak.size(); ++j) {
-      size_t plen = wordbreak[j].size();
-      size_t found = scw.find(wordbreak[j]);
+    for (auto& j : wordbreak) {
+      size_t plen = j.size(), found = scw.find(j);
       if ((found > 0) && (found < wl - plen)) {
         if (!spell(scw.substr(found + plen), candidate_stack))
           continue;
@@ -767,7 +764,7 @@ bool HunspellImpl::spell_internal(const std::string& word, std::vector<std::stri
         scw.append(suffix);
 
         // LANG_hu: spec. dash rule
-        if (langnum == LANG_hu && wordbreak[j] == "-") {
+        if (langnum == LANG_hu && j == "-") {
           suffix = scw.substr(found + 1);
           scw.resize(found + 1);
           if (spell(scw, candidate_stack))
@@ -897,7 +894,7 @@ std::vector<std::string> HunspellImpl::suggest(const std::string& word, std::vec
   if (suggest_candidate_stack.size() > 2048 || // apply a fairly arbitrary depth limit
       // something very broken if suggest ends up calling itself with the same word
       std::find(suggest_candidate_stack.begin(), suggest_candidate_stack.end(), word) != suggest_candidate_stack.end()) {
-    return std::vector<std::string>();
+    return { };
   }
 
   bool capwords;
@@ -910,24 +907,24 @@ std::vector<std::string> HunspellImpl::suggest(const std::string& word, std::vec
   suggest_candidate_stack.pop_back();
   // word reversing wrapper for complex prefixes
   if (complexprefixes) {
-    for (size_t j = 0; j < slst.size(); ++j) {
+    for (auto& j : slst) {
       if (utf8)
-        reverseword_utf(slst[j]);
+        reverseword_utf(j);
       else
-        reverseword(slst[j]);
+        reverseword(j);
     }
   }
 
   // capitalize
   if (capwords)
-    for (size_t j = 0; j < slst.size(); ++j) {
-      mkinitcap(slst[j]);
+    for (auto& j : slst) {
+      mkinitcap(j);
     }
 
   // expand suggestions with dot(s)
   if (abbv && pAMgr && pAMgr->get_sugswithdots()) {
-    for (size_t j = 0; j < slst.size(); ++j) {
-      slst[j].append(word.substr(word.size() - abbv));
+    for (auto& j : slst) {
+	    j.append(word.substr(word.size() - abbv));
     }
   }
 
@@ -1068,13 +1065,13 @@ std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
 
   switch (captype) {
     case NOCAP: {
-      good |= pSMgr->suggest(slst, scw.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, scw, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       if (abbv) {
         std::string wspace(scw);
         wspace.push_back('.');
-        good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+        good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
       }
@@ -1083,12 +1080,12 @@ std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
 
     case INITCAP: {
       capwords = true;
-      good |= pSMgr->suggest(slst, scw.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, scw, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       std::string wspace(scw);
       mkallsmall2(wspace, sunicw);
-      good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       break;
@@ -1097,7 +1094,7 @@ std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
       capwords = true;
       /* FALLTHROUGH */
     case HUHCAP: {
-      good |= pSMgr->suggest(slst, scw.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, scw, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       // something.The -> something. The
@@ -1125,23 +1122,23 @@ std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
         // TheOpenOffice.org -> The OpenOffice.org
         wspace = scw;
         mkinitsmall2(wspace, sunicw);
-        good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+        good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
       }
       wspace = scw;
       mkallsmall2(wspace, sunicw);
-      if (spell(wspace.c_str(), spell_candidate_stack))
+      if (spell(wspace, spell_candidate_stack))
         insert_sug(slst, wspace);
       size_t prevns = slst.size();
-      good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
       if (captype == HUHINITCAP) {
         mkinitcap2(wspace, sunicw);
-        if (spell(wspace.c_str(), spell_candidate_stack))
+        if (spell(wspace, spell_candidate_stack))
           insert_sug(slst, wspace);
-        good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+        good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
       }
@@ -1170,22 +1167,22 @@ std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
     case ALLCAP: {
       std::string wspace(scw);
       mkallsmall2(wspace, sunicw);
-      good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
-      if (pAMgr && pAMgr->get_keepcase() && spell(wspace.c_str(), spell_candidate_stack))
+      if (pAMgr && pAMgr->get_keepcase() && spell(wspace, spell_candidate_stack))
         insert_sug(slst, wspace);
       mkinitcap2(wspace, sunicw);
-      good |= pSMgr->suggest(slst, wspace.c_str(), &onlycmpdsug);
+      good |= pSMgr->suggest(slst, wspace, &onlycmpdsug);
       if (clock() > timelimit + TIMELIMIT_GLOBAL)
           return slst;
-      for (size_t j = 0; j < slst.size(); ++j) {
-        mkallcap(slst[j]);
+      for (auto& j : slst) {
+        mkallcap(j);
         if (pAMgr && pAMgr->get_checksharps()) {
           if (utf8) {
-            mystrrep(slst[j], "\xC3\x9F", "SS");
+            mystrrep(j, "\xC3\x9F", "SS");
           } else {
-            mystrrep(slst[j], "\xDF", "SS");
+            mystrrep(j, "\xDF", "SS");
           }
         }
       }
@@ -1195,17 +1192,17 @@ std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
 
   // LANG_hu section: replace '-' with ' ' in Hungarian
   if (langnum == LANG_hu) {
-    for (size_t j = 0; j < slst.size(); ++j) {
-      size_t pos = slst[j].find('-');
+    for (auto& j : slst) {
+      size_t pos = j.find('-');
       if (pos != std::string::npos) {
         int info;
-        std::string w(slst[j].substr(0, pos));
-        w.append(slst[j].substr(pos + 1));
+        std::string w(j.substr(0, pos));
+        w.append(j.substr(pos + 1));
         (void)spell(w, spell_candidate_stack, &info, NULL);
         if ((info & SPELL_COMPOUND) && (info & SPELL_FORBIDDEN)) {
-          slst[j][pos] = ' ';
+	        j[pos] = ' ';
         } else
-          slst[j][pos] = '-';
+	        j[pos] = '-';
       }
     }
   }
@@ -1280,7 +1277,7 @@ std::vector<std::string> HunspellImpl::suggest_internal(const std::string& word,
         std::vector<std::string> nlst = suggest(chunk, suggest_candidate_stack);
         if (clock() > timelimit + TIMELIMIT_GLOBAL)
             return slst;
-        for (std::vector<std::string>::reverse_iterator j = nlst.rbegin(); j != nlst.rend(); ++j) {
+        for (auto j = nlst.rbegin(); j != nlst.rend(); ++j) {
           std::string wspace = scw.substr(0, prev_pos);
           wspace.append(*j);
           if (!last) {
@@ -1316,12 +1313,11 @@ std::vector<std::string> HunspellImpl::stem(const std::vector<std::string>& desc
   std::string result2;
   if (desc.empty())
     return slst;
-  for (size_t i = 0; i < desc.size(); ++i) {
-
+  for (const auto& i : desc) {
     std::string result;
 
     // add compound word parts (except the last one)
-    const char* s = desc[i].c_str();
+    const char* s = i.c_str();
     const char* part = strstr(s, MORPH_PART);
     if (part) {
       const char* nextpart = strstr(part + 1, MORPH_PART);
@@ -1341,34 +1337,34 @@ std::vector<std::string> HunspellImpl::stem(const std::vector<std::string>& desc
       tok[alt + 1] = MSEP_ALT;
     }
     std::vector<std::string> pl = line_tok(tok, MSEP_ALT);
-    for (size_t k = 0; k < pl.size(); ++k) {
+    for (auto& k : pl) {
       // add derivational suffixes
-      if (pl[k].find(MORPH_DERI_SFX) != std::string::npos) {
+      if (k.find(MORPH_DERI_SFX) != std::string::npos) {
         // remove inflectional suffixes
-        const size_t is = pl[k].find(MORPH_INFL_SFX);
+        const size_t is = k.find(MORPH_INFL_SFX);
         if (is != std::string::npos)
-          pl[k].resize(is);
+	        k.resize(is);
         std::vector<std::string> singlepl;
-        singlepl.push_back(pl[k]);
-        std::string sg = pSMgr->suggest_gen(singlepl, pl[k]);
+        singlepl.push_back(k);
+        std::string sg = pSMgr->suggest_gen(singlepl, k);
         if (!sg.empty()) {
           std::vector<std::string> gen = line_tok(sg, MSEP_REC);
-          for (size_t j = 0; j < gen.size(); ++j) {
+          for (auto& j : gen) {
             result2.push_back(MSEP_REC);
             result2.append(result);
-            result2.append(gen[j]);
+            result2.append(j);
           }
         }
       } else {
         result2.push_back(MSEP_REC);
         result2.append(result);
-        if (pl[k].find(MORPH_SURF_PFX) != std::string::npos) {
+        if (k.find(MORPH_SURF_PFX) != std::string::npos) {
           std::string field;
-          copy_field(field, pl[k], MORPH_SURF_PFX);
+          copy_field(field, k, MORPH_SURF_PFX);
           result2.append(field);
         }
         std::string field;
-        copy_field(field, pl[k], MORPH_STEM);
+        copy_field(field, k, MORPH_STEM);
         result2.append(field);
       }
     }
@@ -1471,8 +1467,7 @@ std::vector<std::string> HunspellImpl::analyze(const std::string& word) {
 }
 
 std::vector<std::string> HunspellImpl::analyze_internal(const std::string& word) {
-  std::vector<std::string> candidate_stack;
-  std::vector<std::string> slst;
+  std::vector<std::string> candidate_stack, slst;
   if (!pSMgr || m_HMgrs.empty())
     return slst;
   if (utf8) {
@@ -1624,8 +1619,7 @@ std::vector<std::string> HunspellImpl::analyze_internal(const std::string& word)
   if (dash_pos != std::string::npos) {
     int nresult = 0;
 
-    std::string part1 = scw.substr(0, dash_pos);
-    std::string part2 = scw.substr(dash_pos+1);
+    std::string part1 = scw.substr(0, dash_pos), part2 = scw.substr(dash_pos + 1);
 
     // examine 2 sides of the dash
     if (part2.empty()) {  // base word ending with dash
@@ -1709,14 +1703,13 @@ std::vector<std::string> HunspellImpl::generate(const std::string& word, const s
   if (!pSMgr || pl.empty())
     return slst;
   std::vector<std::string> pl2 = analyze(word);
-  int captype = NOCAP;
-  int abbv = 0;
+  int captype = NOCAP, abbv = 0;
   std::string cw;
   cleanword(cw, word, &captype, &abbv);
   std::string result;
 
-  for (size_t i = 0; i < pl.size(); ++i) {
-    cat_result(result, pSMgr->suggest_gen(pl2, pl[i]));
+  for (const auto& i : pl) {
+    cat_result(result, pSMgr->suggest_gen(pl2, i));
   }
 
   if (!result.empty()) {
@@ -1729,14 +1722,14 @@ std::vector<std::string> HunspellImpl::generate(const std::string& word, const s
 
     // capitalize
     if (captype == INITCAP || captype == HUHINITCAP) {
-      for (size_t j = 0; j < slst.size(); ++j) {
-        mkinitcap(slst[j]);
+      for (auto& str : slst) {
+        mkinitcap(str);
       }
     }
 
     // temporary filtering of prefix related errors (eg.
     // generate("undrinkable", "eats") --> "undrinkables" and "*undrinks")
-    std::vector<std::string>::iterator it = slst.begin();
+    auto it = slst.begin();
     while (it != slst.end()) {
       std::vector<std::string> candidate_stack;
       if (!spell(*it, candidate_stack)) {
@@ -1810,10 +1803,8 @@ std::string::size_type HunspellImpl::get_xml_pos(const std::string& s, std::stri
 int HunspellImpl::check_xml_par(const std::string& q, std::string::size_type pos,
                                 const char* attr,
                                 const char* value) {
-  std::string cw = get_xml_par(q, get_xml_pos(q, pos, attr));
-  if (cw == value)
-    return 1;
-  return 0;
+  const std::string cw = get_xml_par(q, get_xml_pos(q, pos, attr));
+  return cw == value ? 1 : 0;
 }
 
 std::vector<std::string> HunspellImpl::get_xml_list(const std::string& list, std::string::size_type pos, const char* tag) {
@@ -1858,10 +1849,9 @@ std::vector<std::string> HunspellImpl::spellml(const std::string& in_word) {
     // convert the result to <code><a>ana1</a><a>ana2</a></code> format
     std::string r;
     r.append("<code>");
-    for (size_t i = 0; i < slst.size(); ++i) {
+    for (auto entry : slst) {
       r.append("<a>");
 
-      std::string entry(slst[i]);
       mystrrep(entry, "\t", " ");
       mystrrep(entry, "&", "&amp;");
       mystrrep(entry, "<", "&lt;");
@@ -2026,8 +2016,7 @@ int HunspellImpl::stem(char*** slst, const char* word) {
 int HunspellImpl::stem(char*** slst, char** desc, int n) {
   std::vector<std::string> morph;
   morph.reserve(n);
-  for (int i = 0; i < n; ++i)
-    morph.push_back(desc[i]);
+  for (int i = 0; i < n; ++i) morph.emplace_back(desc[i]);
 
   std::vector<std::string> stems = stem(morph);
   return munge_vector(slst, stems);
@@ -2041,8 +2030,7 @@ int HunspellImpl::generate(char*** slst, const char* word, const char* pattern)
 int HunspellImpl::generate(char*** slst, const char* word, char** pl, int pln) {
   std::vector<std::string> morph;
   morph.reserve(pln);
-  for (int i = 0; i < pln; ++i)
-    morph.push_back(pl[i]);
+  for (int i = 0; i < pln; ++i) morph.emplace_back(pl[i]);
 
   std::vector<std::string> stems = generate(word, morph);
   return munge_vector(slst, stems);
diff --git a/src/hunspell/hunspell.hxx b/src/hunspell/hunspell.hxx
index 8640a35ca..13d42d33c 100644
--- a/src/hunspell/hunspell.hxx
+++ b/src/hunspell/hunspell.hxx
@@ -99,10 +99,6 @@
 class HunspellImpl;
 
 class LIBHUNSPELL_DLL_EXPORTED Hunspell {
- private:
-  Hunspell(const Hunspell&);
-  Hunspell& operator=(const Hunspell&);
-
  private:
   HunspellImpl* m_Impl;
 
@@ -116,6 +112,8 @@ class LIBHUNSPELL_DLL_EXPORTED Hunspell {
    * with system-dependent character encoding instead of _wfopen()).
    */
   Hunspell(const char* affpath, const char* dpath, const char* key = NULL);
+  Hunspell(const Hunspell&) = delete;
+  Hunspell& operator=(const Hunspell&) = delete;
   ~Hunspell();
 
   /* load extra dictionaries (only dic files) */
diff --git a/src/hunspell/hunzip.cxx b/src/hunspell/hunzip.cxx
index edbbad49e..41c8b9811 100644
--- a/src/hunspell/hunzip.cxx
+++ b/src/hunspell/hunzip.cxx
@@ -35,9 +35,9 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
 
 #include "hunzip.hxx"
 #include "csutil.hxx"
@@ -67,8 +67,7 @@ Hunzip::Hunzip(const char* file, const char* key)
 
 int Hunzip::getcode(const char* key) {
   unsigned char c[2];
-  int i, j, n;
-  int allocatedbit = BASEBITREC;
+  int i, j, n, allocatedbit = BASEBITREC;
   const char* enc = key;
 
   if (filename.empty())
diff --git a/src/hunspell/hunzip.hxx b/src/hunspell/hunzip.hxx
index 05c72a04c..5cd74b33c 100644
--- a/src/hunspell/hunzip.hxx
+++ b/src/hunspell/hunzip.hxx
@@ -43,7 +43,7 @@
 
 #include "hunvisapi.h"
 
-#include <stdio.h>
+#include <cstdio>
 #include <fstream>
 #include <vector>
 
@@ -61,10 +61,6 @@ struct bit {
 };
 
 class LIBHUNSPELL_DLL_EXPORTED Hunzip {
- private:
-  Hunzip(const Hunzip&);
-  Hunzip& operator=(const Hunzip&);
-
  protected:
   std::string filename;
   std::ifstream fin;
@@ -79,6 +75,8 @@ class LIBHUNSPELL_DLL_EXPORTED Hunzip {
 
  public:
   Hunzip(const char* filename, const char* key = NULL);
+  Hunzip(const Hunzip&) = delete;
+  Hunzip& operator=(const Hunzip&) = delete;
   ~Hunzip();
   bool is_open() { return fin.is_open(); }
   bool getline(std::string& dest);
diff --git a/src/hunspell/phonet.cxx b/src/hunspell/phonet.cxx
index fd4b6b64a..4f71e9141 100644
--- a/src/hunspell/phonet.cxx
+++ b/src/hunspell/phonet.cxx
@@ -27,18 +27,16 @@
                 Porting from Aspell to Hunspell using C-like structs
 */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
 
 #include "csutil.hxx"
 #include "phonet.hxx"
 
 void init_phonet_hash(phonetable& parms) {
-  for (int i = 0; i < HASHSIZE; i++) {
-    parms.hash[i] = -1;
-  }
+  memset(parms.hash, 0xff, HASHSIZE * sizeof(int));
 
   for (int i = 0; parms.rules[i][0] != '\0'; i += 2) {
     /**  set hash value  **/
@@ -70,14 +68,13 @@ static int myisalpha(char ch) {
 /*  convert string to uppercase before this call       */
 std::string phonet(const std::string& inword, phonetable& parms) {
 
-  int i, k = 0, p, z;
-  int k0, n0, p0 = -333;
+  int i, k = 0, p, z, k0, n0, p0 = -333;
   char c;
   typedef unsigned char uchar;
 
   size_t len = inword.size();
   if (len > MAXPHONETUTF8LEN)
-    return std::string();
+    return {};
   char word[MAXPHONETUTF8LEN + 1];
   strncpy(word, inword.c_str(), MAXPHONETUTF8LEN);
   word[MAXPHONETUTF8LEN] = '\0';
diff --git a/src/hunspell/replist.cxx b/src/hunspell/replist.cxx
index bbdaa0bed..f3cde4d87 100644
--- a/src/hunspell/replist.cxx
+++ b/src/hunspell/replist.cxx
@@ -81,8 +81,8 @@ RepList::RepList(int n) {
 }
 
 RepList::~RepList() {
-  for (size_t i = 0, pos = dat.size(); i < pos; ++i) {
-    delete dat[i];
+  for (auto& i : dat) {
+    delete i;
   }
 }
 
@@ -163,7 +163,7 @@ int RepList::add(const std::string& in_pat1, const std::string& pat2) {
 bool RepList::conv(const std::string& in_word, std::string& dest) {
   dest.clear();
 
-  size_t wordlen = in_word.size();
+  const size_t wordlen = in_word.size();
   const char* word = in_word.c_str();
 
   bool change = false;
@@ -193,10 +193,10 @@ bool RepList::conv(const std::string& in_word, std::string& dest) {
 }
 
 bool RepList::check_against_breaktable(const std::vector<std::string>& breaktable) const {
-  for (size_t i = 0, pos = dat.size(); i < pos; ++i) {
-    for (int j = 0; j < 4; ++j) {
-      for (size_t k = 0; k < breaktable.size(); ++k) {
-        if (dat[i]->outstrings[j].find(breaktable[k]) != std::string::npos) {
+  for (const auto i : dat) {
+    for (auto& outstring : i->outstrings) {
+      for (const auto& str : breaktable) {
+        if (outstring.find(str) != std::string::npos) {
           return false;
         }
       }
diff --git a/src/hunspell/replist.hxx b/src/hunspell/replist.hxx
index e82940e70..e3462b9f6 100644
--- a/src/hunspell/replist.hxx
+++ b/src/hunspell/replist.hxx
@@ -79,13 +79,11 @@
 
 class RepList {
  private:
-  RepList(const RepList&);
-  RepList& operator=(const RepList&);
-
   std::vector<replentry*> dat;
-
  public:
   explicit RepList(int n);
+  RepList(const RepList&) = delete;
+  RepList& operator=(const RepList&) = delete;
   ~RepList();
 
   bool check_against_breaktable(const std::vector<std::string>& breaktable) const;
diff --git a/src/hunspell/suggestmgr.cxx b/src/hunspell/suggestmgr.cxx
index a977330dd..b1d1568b7 100644
--- a/src/hunspell/suggestmgr.cxx
+++ b/src/hunspell/suggestmgr.cxx
@@ -68,11 +68,11 @@
  * SUCH DAMAGE.
  */
 
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <ctype.h>
-#include <time.h>
+#include <cstdlib>
+#include <cstring>
+#include <cstdio>
+#include <cctype>
+#include <ctime>
 
 #include "suggestmgr.hxx"
 #include "htypes.hxx"
@@ -161,15 +161,11 @@ void SuggestMgr::testsug(std::vector<std::string>& wlst,
                         int cpdsuggest,
                         int* timer,
                         clock_t* timelimit) {
-  int cwrd = 1;
   if (wlst.size() == maxSug)
     return;
-  for (size_t k = 0; k < wlst.size(); ++k) {
-    if (wlst[k] == candidate) {
-      cwrd = 0;
-      break;
-    }
-  }
+
+  const int cwrd = std::find(wlst.begin(), wlst.end(), candidate) != wlst.end() ? 0 : 1;
+  
   if ((cwrd) && checkword(candidate, cpdsuggest, timer, timelimit)) {
     wlst.push_back(candidate);
   }
@@ -186,9 +182,8 @@ bool SuggestMgr::suggest(std::vector<std::string>& slst,
                         int* onlycompoundsug) {
   int nocompoundtwowords = 0;
   std::vector<w_char> word_utf;
-  size_t nsugorig = slst.size();
+  size_t nsugorig = slst.size(), oldSug = 0;
   std::string w2;
-  size_t oldSug = 0;
   bool good_suggestion = false;
 
   // word reversing wrapper for complex prefixes
@@ -212,9 +207,8 @@ bool SuggestMgr::suggest(std::vector<std::string>& slst,
   for (int cpdsuggest = 0; (cpdsuggest < 2) && (nocompoundtwowords == 0) && !good_suggestion;
        cpdsuggest++) {
 
-    clock_t timelimit;
     // initialize both in non-compound and compound cycles
-    timelimit = clock();
+    clock_t timelimit = clock();
 
     // limit compound suggestion
     if (cpdsuggest > 0)
@@ -402,13 +396,7 @@ int SuggestMgr::map_related(const std::string& word,
                             clock_t* timelimit,
                             int depth) {
   if (word.size() == wn) {
-    int cwrd = 1;
-    for (size_t m = 0; m < wlst.size(); ++m) {
-      if (wlst[m] == candidate) {
-        cwrd = 0;
-        break;
-      }
-    }
+    const int cwrd = std::find(wlst.begin(), wlst.end(), candidate) != wlst.end() ? 0 : 1;
     if ((cwrd) && checkword(candidate, cpdsuggest, timer, timelimit)) {
       if (wlst.size() < maxSug) {
         wlst.push_back(candidate);
@@ -458,23 +446,23 @@ int SuggestMgr::replchars(std::vector<std::string>& wlst,
   if (wl < 2 || !pAMgr)
     return wlst.size();
   const std::vector<replentry>& reptable = pAMgr->get_reptable();
-  for (size_t i = 0; i < reptable.size(); ++i) {
+  for (const auto& entry : reptable) {
     size_t r = 0;
     // search every occurence of the pattern in the word
-    while ((r = word.find(reptable[i].pattern, r)) != std::string::npos) {
+    while ((r = word.find(entry.pattern, r)) != std::string::npos) {
       int type = (r == 0) ? 1 : 0;
-      if (r + reptable[i].pattern.size() == word.size())
+      if (r + entry.pattern.size() == word.size())
         type += 2;
-      while (type && reptable[i].outstrings[type].empty())
+      while (type && entry.outstrings[type].empty())
         type = (type == 2 && r != 0) ? 0 : type - 1;
-      const std::string&out = reptable[i].outstrings[type];
+      const std::string&out = entry.outstrings[type];
       if (out.empty()) {
         ++r;
         continue;
       }
       candidate.assign(word, 0, r);
-      candidate.append(reptable[i].outstrings[type]);
-      candidate.append(word, r + reptable[i].pattern.size(), std::string::npos);
+      candidate.append(entry.outstrings[type]);
+      candidate.append(word, r + entry.pattern.size(), std::string::npos);
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
       // check REP suggestions with space
       size_t sp = candidate.find(' ');
@@ -789,11 +777,7 @@ bool SuggestMgr::twowords(std::vector<std::string>& wlst,
                          const std::string& word,
                          int cpdsuggest,
                          bool good) {
-  int c2;
-  int forbidden = 0;
-  int cwrd;
-
-  int wl = word.size();
+  int c2, forbidden = 0, cwrd, wl = word.size();
   if (wl < 3)
     return false;
 
@@ -864,31 +848,25 @@ bool SuggestMgr::twowords(std::vector<std::string>& wlst,
           else
             *p = ' ';
 
-          cwrd = 1;
-          for (size_t k = 0; k < wlst.size(); ++k) {
-            if (wlst[k] == candidate) {
-              cwrd = 0;
-              break;
-            }
-          }
+          cwrd = std::find(wlst.begin(), wlst.end(), candidate) != wlst.end() ? 0 : 1;
 
           if (cwrd && (wlst.size() < maxSug))
-              wlst.push_back(candidate);
+              wlst.emplace_back(candidate);
 
           // add two word suggestion with dash, depending on the language
           // Note that cwrd doesn't modified for REP twoword sugg.
           if ( !nosplitsugs && lang_with_dash_usage &&
               mystrlen(p + 1) > 1 && mystrlen(candidate) - mystrlen(p) > 1) {
             *p = '-';
-            for (size_t k = 0; k < wlst.size(); ++k) {
-              if (wlst[k] == candidate) {
+            for (auto& k : wlst) {
+              if (k == candidate) {
                 cwrd = 0;
                 break;
               }
             }
 
             if ((wlst.size() < maxSug) && cwrd)
-              wlst.push_back(candidate);
+              wlst.emplace_back(candidate);
           }
         }
       }
@@ -979,9 +957,9 @@ int SuggestMgr::longswapchar(std::vector<std::string>& wlst,
                              int cpdsuggest) {
   std::string candidate(word);
   // try swapping not adjacent chars one by one
-  for (std::string::iterator p = candidate.begin(); p < candidate.end(); ++p) {
-    for (std::string::iterator q = candidate.begin(); q < candidate.end(); ++q) {
-      size_t distance = std::abs(std::distance(q, p));
+  for (auto p = candidate.begin(); p < candidate.end(); ++p) {
+    for (auto q = candidate.begin(); q < candidate.end(); ++q) {
+      const auto distance = std::abs(std::distance(q, p));
       if (distance > 1 && distance <= MAX_CHAR_DISTANCE) {
         std::swap(*p, *q);
         testsug(wlst, candidate, cpdsuggest, NULL, NULL);
@@ -998,9 +976,9 @@ int SuggestMgr::longswapchar_utf(std::vector<std::string>& wlst,
                                  int cpdsuggest) {
   std::vector<w_char> candidate_utf(word);
   // try swapping not adjacent chars
-  for (std::vector<w_char>::iterator p = candidate_utf.begin(); p < candidate_utf.end(); ++p) {
-    for (std::vector<w_char>::iterator q = candidate_utf.begin(); q < candidate_utf.end(); ++q) {
-      size_t distance = std::abs(std::distance(q, p));
+  for (auto p = candidate_utf.begin(); p < candidate_utf.end(); ++p) {
+    for (auto q = candidate_utf.begin(); q < candidate_utf.end(); ++q) {
+      const auto distance = std::abs(std::distance(q, p));
       if (distance > 1 && distance <= MAX_CHAR_DISTANCE) {
         std::swap(*p, *q);
         std::string candidate;
@@ -1023,26 +1001,26 @@ int SuggestMgr::movechar(std::vector<std::string>& wlst,
   std::string candidate(word);
 
   // try moving a char
-  for (std::string::iterator p = candidate.begin(); p < candidate.end(); ++p) {
-    for (std::string::iterator q = p + 1; q < candidate.end() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
+  for (auto p = candidate.begin(); p < candidate.end(); ++p) {
+    for (auto q = p + 1; q < candidate.end() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
       std::swap(*q, *(q - 1));
       if (std::distance(p, q) < 2)
         continue;  // omit swap char
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
     }
-    auto word_iter = word.begin();
-    std::copy(word_iter, word_iter + candidate.size(), candidate.begin());
+    const auto word_iter = word.begin();
+    std::copy_n(word_iter, candidate.size(), candidate.begin());
   }
 
-  for (std::string::reverse_iterator p = candidate.rbegin(), pEnd = candidate.rend() - 1; p != pEnd; ++p) {
-    for (std::string::reverse_iterator q = p + 1, qEnd = candidate.rend(); q != qEnd && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
+  for (auto p = candidate.rbegin(), pEnd = candidate.rend() - 1; p != pEnd; ++p) {
+    for (auto q = p + 1, qEnd = candidate.rend(); q != qEnd && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
       std::swap(*q, *(q - 1));
       if (std::distance(p, q) < 2)
         continue;  // omit swap char
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
     }
-    auto word_iter = word.begin();
-    std::copy(word_iter, word_iter + candidate.size(), candidate.begin());
+    const auto word_iter = word.begin();
+    std::copy_n(word_iter, candidate.size(), candidate.begin());
   }
 
   return wlst.size();
@@ -1058,8 +1036,8 @@ int SuggestMgr::movechar_utf(std::vector<std::string>& wlst,
   std::vector<w_char> candidate_utf(word);
 
   // try moving a char
-  for (std::vector<w_char>::iterator p = candidate_utf.begin(); p < candidate_utf.end(); ++p) {
-    for (std::vector<w_char>::iterator q = p + 1; q < candidate_utf.end() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
+  for (auto p = candidate_utf.begin(); p < candidate_utf.end(); ++p) {
+    for (auto q = p + 1; q < candidate_utf.end() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
       std::swap(*q, *(q - 1));
       if (std::distance(p, q) < 2)
         continue;  // omit swap char
@@ -1067,12 +1045,12 @@ int SuggestMgr::movechar_utf(std::vector<std::string>& wlst,
       u16_u8(candidate, candidate_utf);
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
     }
-    auto word_iter = word.begin();
-    std::copy(word_iter, word_iter + candidate_utf.size(), candidate_utf.begin());
+    const auto word_iter = word.begin();
+    std::copy_n(word_iter, candidate_utf.size(), candidate_utf.begin());
   }
 
-  for (std::vector<w_char>::reverse_iterator p = candidate_utf.rbegin(); p < candidate_utf.rend(); ++p) {
-    for (std::vector<w_char>::reverse_iterator q = p + 1; q < candidate_utf.rend() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
+  for (auto p = candidate_utf.rbegin(); p < candidate_utf.rend(); ++p) {
+    for (auto q = p + 1; q < candidate_utf.rend() && std::distance(p, q) <= MAX_CHAR_DISTANCE; ++q) {
       std::swap(*q, *(q - 1));
       if (std::distance(p, q) < 2)
         continue;  // omit swap char
@@ -1080,8 +1058,8 @@ int SuggestMgr::movechar_utf(std::vector<std::string>& wlst,
       u16_u8(candidate, candidate_utf);
       testsug(wlst, candidate, cpdsuggest, NULL, NULL);
     }
-    auto word_iter = word.begin();
-    std::copy(word_iter, word_iter + candidate_utf.size(), candidate_utf.begin());
+    const auto word_iter = word.begin();
+    std::copy_n(word_iter, candidate_utf.size(), candidate_utf.begin());
   }
 
   return wlst.size();
@@ -1092,10 +1070,7 @@ void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
                           const char* w,
                           const std::vector<HashMgr*>& rHMgr,
                           int captype) {
-  int lval;
-  int sc;
-  int lp, lpphon;
-  int nonbmp = 0;
+  int lval, sc, lp, lpphon, nonbmp = 0;
 
   // exhaustively search through all root words
   // keeping track of the MAX_ROOTS most similar root words
@@ -1343,9 +1318,9 @@ void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
 
   std::vector<guessword> glst(MAX_WORDS);
 
-  for (int i = 0; i < MAX_ROOTS; i++) {
-    if (roots[i]) {
-      struct hentry* rp = roots[i];
+  for (auto& root : roots) {
+    if (root) {
+      struct hentry* rp = root;
 
       f.clear();
       const char *field = NULL;
@@ -1566,11 +1541,11 @@ void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
             continue;
           }
         }
-        for (size_t j = 0; j < wlst.size(); ++j) {
+        for (auto& j : wlst) {
           // don't suggest previous suggestions or a previous suggestion with
           // prefixes or affixes
-          if ((!guessorig[i] && strstr(guess[i], wlst[j].c_str())) ||
-              (guessorig[i] && strstr(guessorig[i], wlst[j].c_str())) ||
+          if ((!guessorig[i] && strstr(guess[i], j.c_str())) ||
+              (guessorig[i] && strstr(guessorig[i], j.c_str())) ||
               // check forbidden words
               !checkword(guess[i], 0, NULL, NULL)) {
             unique = 0;
@@ -1579,9 +1554,9 @@ void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
         }
         if (unique) {
           if (guessorig[i]) {
-            wlst.push_back(guessorig[i]);
+            wlst.emplace_back(guessorig[i]);
           } else {
-            wlst.push_back(guess[i]);
+            wlst.emplace_back(guess[i]);
           }
         }
         delete[] guess[i];
@@ -1595,22 +1570,22 @@ void SuggestMgr::ngsuggest(std::vector<std::string>& wlst,
 
   oldns = wlst.size();
   if (ph)
-    for (int i = 0; i < MAX_ROOTS; i++) {
-      if (rootsphon[i]) {
+    for (auto& i : rootsphon) {
+      if (i) {
         if ((wlst.size() < oldns + MAXPHONSUGS) && (wlst.size() < maxSug)) {
           int unique = 1;
-          for (size_t j = 0; j < wlst.size(); ++j) {
+          for (auto& j : wlst) {
             // don't suggest previous suggestions or a previous suggestion with
             // prefixes or affixes
-            if (strstr(rootsphon[i], wlst[j].c_str()) ||
+            if (strstr(i, j.c_str()) ||
                 // check forbidden words
-                !checkword(rootsphon[i], 0, NULL, NULL)) {
+                !checkword(i, 0, NULL, NULL)) {
               unique = 0;
               break;
             }
           }
           if (unique) {
-            wlst.push_back(rootsphon[i]);
+            wlst.emplace_back(i);
           }
         }
       }
@@ -1738,7 +1713,7 @@ std::string SuggestMgr::suggest_morph(const std::string& in_w) {
   struct hentry* rv = NULL;
 
   if (!pAMgr)
-    return std::string();
+    return {};
 
   std::string w(in_w);
 
@@ -1859,7 +1834,7 @@ std::string SuggestMgr::suggest_hentry_gen(hentry* rv, const char* pattern) {
 
 std::string SuggestMgr::suggest_gen(const std::vector<std::string>& desc, const std::string& in_pattern) {
   if (desc.empty() || !pAMgr)
-    return std::string();
+    return {};
 
   const char* pattern = in_pattern.c_str();
   std::string result2;
@@ -1893,37 +1868,37 @@ std::string SuggestMgr::suggest_gen(const std::vector<std::string>& desc, const
         pos = tok.find(" | ", pos);
       }
       std::vector<std::string> pl = line_tok(tok, MSEP_ALT);
-      for (size_t i = 0; i < pl.size(); ++i) {
+      for (auto& i : pl) {
         // remove inflectional and terminal suffixes
-        size_t is = pl[i].find(MORPH_INFL_SFX);
+        size_t is = i.find(MORPH_INFL_SFX);
         if (is != std::string::npos)
-          pl[i].resize(is);
-        size_t ts = pl[i].find(MORPH_TERM_SFX);
+	        i.resize(is);
+        size_t ts = i.find(MORPH_TERM_SFX);
         while (ts != std::string::npos) {
-          pl[i][ts] = '_';
-          ts = pl[i].find(MORPH_TERM_SFX);
+	        i[ts] = '_';
+          ts = i.find(MORPH_TERM_SFX);
         }
         const char* st = strstr(s, MORPH_STEM);
         if (st) {
           copy_field(tok, st, MORPH_STEM);
           rv = pAMgr->lookup(tok.c_str(), tok.size());
           while (rv) {
-            std::string newpat(pl[i]);
+            std::string newpat(i);
             newpat.append(pattern);
             std::string sg = suggest_hentry_gen(rv, newpat.c_str());
             if (sg.empty())
               sg = suggest_hentry_gen(rv, pattern);
             if (!sg.empty()) {
               std::vector<std::string> gen = line_tok(sg, MSEP_REC);
-              for (size_t j = 0; j < gen.size(); ++j) {
+              for (auto& j : gen) {
                 result2.push_back(MSEP_REC);
                 result2.append(result);
-                if (pl[i].find(MORPH_SURF_PFX) != std::string::npos) {
+                if (i.find(MORPH_SURF_PFX) != std::string::npos) {
                   std::string field;
-                  copy_field(field, pl[i], MORPH_SURF_PFX);
+                  copy_field(field, i, MORPH_SURF_PFX);
                   result2.append(field);
                 }
-                result2.append(gen[j]);
+                result2.append(j);
               }
             }
             rv = rv->next_homonym;
@@ -1947,14 +1922,8 @@ int SuggestMgr::ngram(int n,
                       const std::vector<w_char>& su1,
                       const std::vector<w_char>& su2,
                       int opt) {
-  int nscore = 0;
-  int ns;
-  int l1;
-  int l2;
-  int test = 0;
-
-  l1 = su1.size();
-  l2 = su2.size();
+  int nscore = 0, ns, test = 0, l1 = su1.size(), l2 = su2.size();
+
   if (l2 == 0)
     return 0;
   for (int j = 1; j <= n; j++) {
@@ -1997,13 +1966,8 @@ int SuggestMgr::ngram(int n,
                       const std::string& s1,
                       const std::string& s2,
                       int opt) {
-  int nscore = 0;
-  int ns;
-  int l1;
-  int l2;
-  int test = 0;
-
-  l2 = s2.size();
+  int nscore = 0, ns, l1, l2 = s2.size(), test = 0;
+  
   if (l2 == 0)
     return 0;
   l1 = s1.size();
@@ -2038,15 +2002,14 @@ int SuggestMgr::ngram(int n,
 int SuggestMgr::leftcommonsubstring(
     const std::vector<w_char>& su1,
     const std::vector<w_char>& su2) {
-  int l1 = su1.size();
-  int l2 = su2.size();
+  int l1 = su1.size(), l2 = su2.size();
   // decapitalize dictionary word
   if (complexprefixes) {
     if (l1 && l2 && su1[l1 - 1] == su2[l2 - 1])
       return 1;
   } else {
-    unsigned short idx = su2.empty() ? 0 : (unsigned short)(su2[0]);
-    unsigned short otheridx = su1.empty() ? 0 : (unsigned short)(su1[0]);
+    unsigned short idx = su2.empty() ? 0 : (unsigned short)(su2[0]),
+  	               otheridx = su1.empty() ? 0 : (unsigned short)(su1[0]);
     if (otheridx != idx && (otheridx != unicodetolower(idx, langnum)))
       return 0;
     int i;
@@ -2063,8 +2026,7 @@ int SuggestMgr::leftcommonsubstring(
     const char* s1,
     const char* s2) {
   if (complexprefixes) {
-    int l1 = strlen(s1);
-    int l2 = strlen(s2);
+    int l1 = strlen(s1), l2 = strlen(s2);
     if (l1 && l1 <= l2 && s2[l1 - 1] == s2[l2 - 1])
       return 1;
   } else if (csconv) {
@@ -2084,15 +2046,12 @@ int SuggestMgr::leftcommonsubstring(
 int SuggestMgr::commoncharacterpositions(const char* s1,
                                          const char* s2,
                                          int* is_swap) {
-  int num = 0;
-  int diff = 0;
-  int diffpos[2];
+  int num = 0, diff = 0, diffpos[2];
   *is_swap = 0;
   if (utf8) {
     std::vector<w_char> su1;
     std::vector<w_char> su2;
-    int l1 = u8_u16(su1, s1);
-    int l2 = u8_u16(su2, s2);
+    int l1 = u8_u16(su1, s1), l2 = u8_u16(su2, s2);
 
     if (l1 <= 0 || l2 <= 0)
       return 0;
@@ -2175,7 +2134,6 @@ void SuggestMgr::bubblesort(char** rword, char** rword2, int* rsc, int n) {
     }
     m++;
   }
-  return;
 }
 
 // longest common subsequence
@@ -2183,11 +2141,9 @@ char* SuggestMgr::lcs(const char* s,
                       const char* s2,
                       int* l1,
                       int* l2) {
-  int n, m;
+  int n, m, i, j;
   std::vector<w_char> su;
   std::vector<w_char> su2;
-  int i;
-  int j;
   if (utf8) {
     m = u8_u16(su, s);
     n = u8_u16(su2, s2);
@@ -2223,14 +2179,9 @@ char* SuggestMgr::lcs(const char* s,
 }
 
 int SuggestMgr::lcslen(const char* s, const char* s2) {
-  int m;
-  int n;
-  int i;
-  int j;
-  int len = 0;
+  int m, n, len = 0;
   char* result = lcs(s, s2, &m, &n);
-  i = m;
-  j = n;
+  int i = m, j = n;
   while ((i != 0) && (j != 0)) {
     if (result[i * (n + 1) + j] == LCS_UPLEFT) {
       len++;
diff --git a/src/hunspell/suggestmgr.hxx b/src/hunspell/suggestmgr.hxx
index cde1db461..8838a0f01 100644
--- a/src/hunspell/suggestmgr.hxx
+++ b/src/hunspell/suggestmgr.hxx
@@ -91,10 +91,6 @@
 enum { LCS_UP, LCS_LEFT, LCS_UPLEFT };
 
 class SuggestMgr {
- private:
-  SuggestMgr(const SuggestMgr&);
-  SuggestMgr& operator=(const SuggestMgr&);
-
  private:
   std::string ckey;
   size_t ckeyl;
@@ -117,6 +113,8 @@ class SuggestMgr {
 
  public:
   SuggestMgr(const std::string& tryme, unsigned int maxn, AffixMgr* aptr);
+  SuggestMgr(const SuggestMgr&) = delete;
+  SuggestMgr& operator=(const SuggestMgr&) = delete;
   ~SuggestMgr();
 
   bool suggest(std::vector<std::string>& slst, const std::string& word, int* onlycmpdsug);
